From 35a91d97b6e738642246315ca0e0c5428ec68fda Mon Sep 17 00:00:00 2001
From: Oleksandr Natalenko <oleksandr@natalenko.name>
Date: Tue, 11 Feb 2025 11:55:49 +0100
Subject: [PATCH 2/3] v4l2loopback-6.14: update against latest git HEAD

Signed-off-by: Oleksandr Natalenko <oleksandr@natalenko.name>
---
 drivers/media/v4l2-core/v4l2loopback.c | 2113 +++++++++++++-----------
 1 file changed, 1119 insertions(+), 994 deletions(-)

diff --git a/drivers/media/v4l2-core/v4l2loopback.c b/drivers/media/v4l2-core/v4l2loopback.c
index 25cb1beb2..1fa11ac8f 100644
--- a/drivers/media/v4l2-core/v4l2loopback.c
+++ b/drivers/media/v4l2-core/v4l2loopback.c
@@ -104,6 +104,7 @@ static inline void v4l2l_get_timestamp(struct v4l2_buffer *b)
 	b->timestamp.tv_sec = ts.tv_sec;
 	b->timestamp.tv_usec = (ts.tv_nsec / NSEC_PER_USEC);
 	b->flags |= V4L2_BUF_FLAG_TIMESTAMP_MONOTONIC;
+	b->flags &= ~V4L2_BUF_FLAG_TIMESTAMP_COPY;
 }
 
 #if BITS_PER_LONG == 32
@@ -230,7 +231,8 @@ static DEFINE_IDR(v4l2loopback_index_idr);
 static DEFINE_MUTEX(v4l2loopback_ctl_mutex);
 
 /* frame intervals */
-#define V4L2LOOPBACK_FPS_MIN 0
+#define V4L2LOOPBACK_FRAME_INTERVAL_MAX __UINT32_MAX__
+#define V4L2LOOPBACK_FPS_DEFAULT 30
 #define V4L2LOOPBACK_FPS_MAX 1000
 
 /* control IDs */
@@ -287,8 +289,8 @@ static const struct v4l2_ctrl_config v4l2loopback_ctrl_timeoutimageio = {
 	.name	= "timeout_image_io",
 	.type	= V4L2_CTRL_TYPE_BUTTON,
 	.min	= 0,
-	.max	= 1,
-	.step	= 1,
+	.max	= 0,
+	.step	= 0,
 	.def	= 0,
 	// clang-format on
 };
@@ -312,6 +314,16 @@ struct v4l2_loopback_device {
 	struct v4l2_device v4l2_dev;
 	struct v4l2_ctrl_handler ctrl_handler;
 	struct video_device *vdev;
+
+	/* loopback device-specific parameters */
+	char card_label[32];
+	bool announce_all_caps; /* announce both OUTPUT and CAPTURE capabilities
+				 * when true; else announce OUTPUT when no
+				 * writer is streaming, otherwise CAPTURE. */
+	int max_openers; /* how many times can this device be opened */
+	int min_width, max_width;
+	int min_height, max_height;
+
 	/* pixel and stream format */
 	struct v4l2_pix_format pix_format;
 	bool pix_format_has_valid_sizeimage;
@@ -319,79 +331,70 @@ struct v4l2_loopback_device {
 	unsigned long frame_jiffies;
 
 	/* ctrls */
-	int keep_format; /* CID_KEEP_FORMAT; stay ready_for_capture even when all
-			    openers close() the device */
+	int keep_format; /* CID_KEEP_FORMAT; lock the format, do not free
+			  * on close(), and when `!announce_all_caps` do NOT
+			  * fall back to OUTPUT when no writers attached (clear
+			  * `keep_format` to attach a new writer) */
 	int sustain_framerate; /* CID_SUSTAIN_FRAMERATE; duplicate frames to maintain
 				  (close to) nominal framerate */
+	unsigned long timeout_jiffies; /* CID_TIMEOUT; 0 means disabled */
+	int timeout_image_io; /* CID_TIMEOUT_IMAGE_IO; next opener will
+			       * queue/dequeue the timeout image buffer */
 
-	/* buffers stuff */
+	/* buffers for OUTPUT and CAPTURE */
 	u8 *image; /* pointer to actual buffers data */
-	unsigned long int imagesize; /* size of buffers data */
-	int buffers_number; /* should not be big, 4 is a good choice */
+	unsigned long image_size; /* number of bytes alloc'd for all buffers */
 	struct v4l2l_buffer buffers[MAX_BUFFERS]; /* inner driver buffers */
-	int used_buffers; /* number of the actually used buffers */
-	int max_openers; /* how many times can this device be opened */
-
-	s64 write_position; /* number of last written frame + 1 */
-	struct list_head outbufs_list; /* buffers in output DQBUF order */
-	int bufpos2index
-		[MAX_BUFFERS]; /* mapping of (read/write_position % used_buffers)
-                        * to inner buffer index */
-	long buffer_size;
+	u32 buffer_count; /* should not be big, 4 is a good choice */
+	u32 buffer_size; /* number of bytes alloc'd per buffer */
+	u32 used_buffer_count; /* number of buffers allocated to openers */
+	struct list_head outbufs_list; /* FIFO queue for OUTPUT buffers */
+	u32 bufpos2index[MAX_BUFFERS]; /* mapping of `(position % used_buffers)`
+					* to `buffers[index]` */
+	s64 write_position; /* sequence number of last 'displayed' buffer plus
+			     * one */
+
+	/* synchronization between openers */
+	atomic_t open_count;
+	struct mutex image_mutex; /* mutex for allocating image(s) and
+				   * exchanging format tokens */
+	spinlock_t lock; /* lock for the timeout and framerate timers */
+	spinlock_t list_lock; /* lock for the OUTPUT buffer queue */
+	wait_queue_head_t read_event;
+	u32 format_tokens; /* tokens to 'set format' for OUTPUT, CAPTURE, or
+			    * timeout buffers */
+	u32 stream_tokens; /* tokens to 'start' OUTPUT, CAPTURE, or timeout
+			    * stream */
 
-	/* sustain_framerate stuff */
+	/* sustain framerate */
 	struct timer_list sustain_timer;
 	unsigned int reread_count;
 
-	/* timeout stuff */
-	unsigned long timeout_jiffies; /* CID_TIMEOUT; 0 means disabled */
-	int timeout_image_io; /* CID_TIMEOUT_IMAGE_IO; next opener will
-			       * read/write to timeout_image */
-	u8 *timeout_image; /* copy of it will be captured when timeout passes */
-	struct v4l2l_buffer timeout_image_buffer;
+	/* timeout */
+	u8 *timeout_image; /* copied to outgoing buffers when timeout passes */
+	struct v4l2l_buffer timeout_buffer;
+	u32 timeout_buffer_size; /* number bytes alloc'd for timeout buffer */
 	struct timer_list timeout_timer;
 	int timeout_happened;
-
-	/* sync stuff */
-	atomic_t open_count;
-
-	int ready_for_capture; /* set to the number of writers that opened the
-                                * device and negotiated format. */
-	int ready_for_output; /* set to true when no writer is currently attached
-			       * this differs slightly from !ready_for_capture,
-			       * e.g. when using fallback images */
-	int active_readers; /* increase if any reader starts streaming */
-	int announce_all_caps; /* set to false, if device caps (OUTPUT/CAPTURE)
-                                * should only be announced if the resp. "ready"
-                                * flag is set; default=TRUE */
-
-	int min_width, max_width;
-	int min_height, max_height;
-
-	char card_label[32];
-
-	wait_queue_head_t read_event;
-	spinlock_t lock, list_lock;
 };
 
-/* types of opener shows what opener wants to do with loopback */
-enum opener_type {
-	// clang-format off
-	UNNEGOTIATED	= 0,
-	READER		= 1,
-	WRITER		= 2,
-	// clang-format on
+enum v4l2l_io_method {
+	V4L2L_IO_NONE = 0,
+	V4L2L_IO_MMAP = 1,
+	V4L2L_IO_FILE = 2,
+	V4L2L_IO_TIMEOUT = 3,
 };
 
 /* struct keeping state and type of opener */
 struct v4l2_loopback_opener {
-	enum opener_type type;
-	s64 read_position; /* number of last processed frame + 1 or
-			    * write_position - 1 if reader went out of sync */
+	u32 format_token; /* token (if any) for type used in call to S_FMT or
+			   * REQBUFS */
+	u32 stream_token; /* token (if any) for type used in call to STREAMON */
+	u32 buffer_count; /* number of buffers (if any) that opener acquired via
+			   * REQBUFS */
+	s64 read_position; /* sequence number of the next 'captured' frame */
 	unsigned int reread_count;
-	struct v4l2_buffer *buffers;
-	int buffers_number; /* should not be big, 4 is a good choice */
-	int timeout_image_io;
+	enum v4l2l_io_method io_method;
 
 	struct v4l2_fh fh;
 };
@@ -422,23 +425,43 @@ struct v4l2l_format {
 	 (type) == V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE)
 #endif /* V4L2_TYPE_IS_OUTPUT */
 
-/* whether the format can be changed */
-/* the format is fixated if we
-   - have writers (ready_for_capture>0)
-   - and/or have readers (active_readers>0)
-*/
-#define V4L2LOOPBACK_IS_FIXED_FMT(device)                               \
-	(device->ready_for_capture > 0 || device->active_readers > 0 || \
-	 device->keep_format)
+/* token values for privilege to set format or start/stop stream */
+#define V4L2L_TOKEN_CAPTURE 0x01
+#define V4L2L_TOKEN_OUTPUT 0x02
+#define V4L2L_TOKEN_TIMEOUT 0x04
+#define V4L2L_TOKEN_MASK \
+	(V4L2L_TOKEN_CAPTURE | V4L2L_TOKEN_OUTPUT | V4L2L_TOKEN_TIMEOUT)
+
+/* helpers for token exchange and token status */
+#define token_from_type(type) \
+	(V4L2_TYPE_IS_CAPTURE(type) ? V4L2L_TOKEN_CAPTURE : V4L2L_TOKEN_OUTPUT)
+#define acquire_token(dev, opener, label, token) \
+	do {                                     \
+		(opener)->label##_token = token; \
+		(dev)->label##_tokens &= ~token; \
+	} while (0)
+#define release_token(dev, opener, label)                         \
+	do {                                                      \
+		(dev)->label##_tokens |= (opener)->label##_token; \
+		(opener)->label##_token = 0;                      \
+	} while (0)
+#define has_output_token(token) (token & V4L2L_TOKEN_OUTPUT)
+#define has_capture_token(token) (token & V4L2L_TOKEN_CAPTURE)
+#define has_no_owners(dev) ((~((dev)->format_tokens) & V4L2L_TOKEN_MASK) == 0)
+#define has_other_owners(opener, dev) \
+	(~((dev)->format_tokens ^ (opener)->format_token) & V4L2L_TOKEN_MASK)
+#define need_timeout_buffer(dev, token) \
+	((dev)->timeout_jiffies > 0 || (token) & V4L2L_TOKEN_TIMEOUT)
 
 static const unsigned int FORMATS = ARRAY_SIZE(formats);
 
-static char *fourcc2str(unsigned int fourcc, char buf[4])
+static char *fourcc2str(unsigned int fourcc, char buf[5])
 {
 	buf[0] = (fourcc >> 0) & 0xFF;
 	buf[1] = (fourcc >> 8) & 0xFF;
 	buf[2] = (fourcc >> 16) & 0xFF;
 	buf[3] = (fourcc >> 24) & 0xFF;
+	buf[4] = 0;
 
 	return buf;
 }
@@ -446,15 +469,14 @@ static char *fourcc2str(unsigned int fourcc, char buf[4])
 static const struct v4l2l_format *format_by_fourcc(int fourcc)
 {
 	unsigned int i;
+	char buf[5];
 
 	for (i = 0; i < FORMATS; i++) {
 		if (formats[i].fourcc == fourcc)
 			return formats + i;
 	}
 
-	dprintk("unsupported format '%c%c%c%c'\n", (fourcc >> 0) & 0xFF,
-		(fourcc >> 8) & 0xFF, (fourcc >> 16) & 0xFF,
-		(fourcc >> 24) & 0xFF);
+	dprintk("unsupported format '%4s'\n", fourcc2str(fourcc, buf));
 	return NULL;
 }
 
@@ -478,26 +500,21 @@ static void pix_format_set_size(struct v4l2_pix_format *f,
 	}
 }
 
-static int v4l2l_fill_format(struct v4l2_format *fmt, int capture,
-			     const u32 minwidth, const u32 maxwidth,
-			     const u32 minheight, const u32 maxheight)
+static int v4l2l_fill_format(struct v4l2_format *fmt, const u32 minwidth,
+			     const u32 maxwidth, const u32 minheight,
+			     const u32 maxheight)
 {
 	u32 width = fmt->fmt.pix.width, height = fmt->fmt.pix.height;
 	u32 pixelformat = fmt->fmt.pix.pixelformat;
 	struct v4l2_format fmt0 = *fmt;
 	u32 bytesperline = 0, sizeimage = 0;
+
 	if (!width)
 		width = V4L2LOOPBACK_SIZE_DEFAULT_WIDTH;
 	if (!height)
 		height = V4L2LOOPBACK_SIZE_DEFAULT_HEIGHT;
-	if (width < minwidth)
-		width = minwidth;
-	if (width > maxwidth)
-		width = maxwidth;
-	if (height < minheight)
-		height = minheight;
-	if (height > maxheight)
-		height = maxheight;
+	width = clamp_val(width, minwidth, maxwidth);
+	height = clamp_val(height, minheight, maxheight);
 
 	/* sets: width,height,pixelformat,bytesperline,sizeimage */
 	if (!(V4L2_TYPE_IS_MULTIPLANAR(fmt0.type))) {
@@ -532,10 +549,6 @@ static int v4l2l_fill_format(struct v4l2_format *fmt, int capture,
 			fmt->fmt.pix_mp.colorspace = V4L2_COLORSPACE_SRGB;
 		if (V4L2_FIELD_ANY == fmt->fmt.pix_mp.field)
 			fmt->fmt.pix_mp.field = V4L2_FIELD_NONE;
-		if (capture)
-			fmt->type = V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE;
-		else
-			fmt->type = V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE;
 	} else {
 		bytesperline = fmt->fmt.pix.bytesperline;
 		sizeimage = fmt->fmt.pix.sizeimage;
@@ -552,10 +565,6 @@ static int v4l2l_fill_format(struct v4l2_format *fmt, int capture,
 			fmt->fmt.pix.colorspace = V4L2_COLORSPACE_SRGB;
 		if (V4L2_FIELD_ANY == fmt->fmt.pix.field)
 			fmt->fmt.pix.field = V4L2_FIELD_NONE;
-		if (capture)
-			fmt->type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
-		else
-			fmt->type = V4L2_BUF_TYPE_VIDEO_OUTPUT;
 	}
 
 	return 0;
@@ -604,55 +613,27 @@ static int pix_format_eq(const struct v4l2_pix_format *ref,
 	return result;
 }
 
-static struct v4l2_loopback_device *v4l2loopback_getdevice(struct file *f);
-static int inner_try_setfmt(struct file *file, struct v4l2_format *fmt)
+static void set_timeperframe(struct v4l2_loopback_device *dev,
+			     struct v4l2_fract *tpf)
 {
-	int capture = V4L2_TYPE_IS_CAPTURE(fmt->type);
-	struct v4l2_loopback_device *dev;
-	int needschange = 0;
-	char buf[5];
-	buf[4] = 0;
-
-	dev = v4l2loopback_getdevice(file);
-
-	needschange = !(pix_format_eq(&dev->pix_format, &fmt->fmt.pix, 0));
-	if (V4L2LOOPBACK_IS_FIXED_FMT(dev)) {
-		fmt->fmt.pix = dev->pix_format;
-		if (needschange) {
-			if (dev->active_readers > 0 && capture) {
-				/* cannot call fmt_cap while there are readers */
-				return -EBUSY;
-			}
-			if (dev->ready_for_capture > 0 && !capture) {
-				/* cannot call fmt_out while there are writers */
-				return -EBUSY;
-			}
-		}
-	}
-	if (v4l2l_fill_format(fmt, capture, dev->min_width, dev->max_width,
-			      dev->min_height, dev->max_height) != 0) {
-		return -EINVAL;
-	}
-
-	if (1) {
-		char buf[5];
-		buf[4] = 0;
-		dprintk("capFOURCC=%s\n",
-			fourcc2str(dev->pix_format.pixelformat, buf));
+	if (!tpf->denominator && !tpf->numerator) {
+		tpf->numerator = 1;
+		tpf->denominator = V4L2LOOPBACK_FPS_DEFAULT;
+	} else if (tpf->numerator >
+		   V4L2LOOPBACK_FRAME_INTERVAL_MAX * tpf->denominator) {
+		/* divide-by-zero or greater than maximum interval => min FPS */
+		tpf->numerator = V4L2LOOPBACK_FRAME_INTERVAL_MAX;
+		tpf->denominator = 1;
+	} else if (tpf->numerator * V4L2LOOPBACK_FPS_MAX < tpf->denominator) {
+		/* zero or lower than minimum interval => max FPS */
+		tpf->numerator = 1;
+		tpf->denominator = V4L2LOOPBACK_FPS_MAX;
 	}
-	return 0;
-}
 
-static int set_timeperframe(struct v4l2_loopback_device *dev,
-			    struct v4l2_fract *tpf)
-{
-	if ((tpf->denominator < 1) || (tpf->numerator < 1)) {
-		return -EINVAL;
-	}
 	dev->capture_param.timeperframe = *tpf;
-	dev->frame_jiffies = max(1UL, msecs_to_jiffies(1000) * tpf->numerator /
-					      tpf->denominator);
-	return 0;
+	dev->frame_jiffies =
+		max(1UL, (msecs_to_jiffies(1000) * tpf->numerator) /
+				 tpf->denominator);
 }
 
 static struct v4l2_loopback_device *v4l2loopback_cd2dev(struct device *cd);
@@ -668,18 +649,17 @@ static ssize_t attr_show_format(struct device *cd,
 	const struct v4l2_fract *tpf;
 	char buf4cc[5], buf_fps[32];
 
-	if (!dev || !V4L2LOOPBACK_IS_FIXED_FMT(dev))
+	if (!dev || (has_no_owners(dev) && !dev->keep_format))
 		return 0;
 	tpf = &dev->capture_param.timeperframe;
 
 	fourcc2str(dev->pix_format.pixelformat, buf4cc);
-	buf4cc[4] = 0;
 	if (tpf->numerator == 1)
-		snprintf(buf_fps, sizeof(buf_fps), "%d", tpf->denominator);
+		snprintf(buf_fps, sizeof(buf_fps), "%u", tpf->denominator);
 	else
-		snprintf(buf_fps, sizeof(buf_fps), "%d/%d", tpf->denominator,
+		snprintf(buf_fps, sizeof(buf_fps), "%u/%u", tpf->denominator,
 			 tpf->numerator);
-	return sprintf(buf, "%4s:%dx%d@%s\n", buf4cc, dev->pix_format.width,
+	return sprintf(buf, "%4s:%ux%u@%s\n", buf4cc, dev->pix_format.width,
 		       dev->pix_format.height, buf_fps);
 }
 
@@ -694,12 +674,10 @@ static ssize_t attr_store_format(struct device *cd,
 		return -ENODEV;
 
 	/* only fps changing is supported */
-	if (sscanf(buf, "@%d/%d", &fps_num, &fps_den) > 0) {
+	if (sscanf(buf, "@%u/%u", &fps_num, &fps_den) > 0) {
 		struct v4l2_fract f = { .numerator = fps_den,
 					.denominator = fps_num };
-		int err = 0;
-		if ((err = set_timeperframe(dev, &f)) < 0)
-			return err;
+		set_timeperframe(dev, &f);
 		return len;
 	}
 	return -EINVAL;
@@ -716,7 +694,7 @@ static ssize_t attr_show_buffers(struct device *cd,
 	if (!dev)
 		return -ENODEV;
 
-	return sprintf(buf, "%d\n", dev->used_buffers);
+	return sprintf(buf, "%u\n", dev->used_buffer_count);
 }
 
 static DEVICE_ATTR(buffers, S_IRUGO, attr_show_buffers, NULL);
@@ -770,9 +748,9 @@ static ssize_t attr_show_state(struct device *cd, struct device_attribute *attr,
 	if (!dev)
 		return -ENODEV;
 
-	if (dev->ready_for_capture)
+	if (!has_output_token(dev->stream_tokens) || dev->keep_format) {
 		return sprintf(buf, "capture\n");
-	if (dev->ready_for_output)
+	} else
 		return sprintf(buf, "output\n");
 
 	return -EAGAIN;
@@ -862,14 +840,14 @@ static int v4l2loopback_lookup(int device_nr,
 	}
 	return -ENODEV;
 }
+#define v4l2loopback_get_vdev_nr(vdev) \
+	((struct v4l2loopback_private *)video_get_drvdata(vdev))->device_nr
 static struct v4l2_loopback_device *v4l2loopback_cd2dev(struct device *cd)
 {
 	struct video_device *loopdev = to_video_device(cd);
-	struct v4l2loopback_private *ptr =
-		(struct v4l2loopback_private *)video_get_drvdata(loopdev);
-	int nr = ptr->device_nr;
+	int device_nr = v4l2loopback_get_vdev_nr(loopdev);
 
-	return idr_find(&v4l2loopback_index_idr, nr);
+	return idr_find(&v4l2loopback_index_idr, device_nr);
 }
 
 static struct v4l2_loopback_device *v4l2loopback_getdevice(struct file *f)
@@ -882,46 +860,28 @@ static struct v4l2_loopback_device *v4l2loopback_getdevice(struct file *f)
 
 /* forward declarations */
 static void client_usage_queue_event(struct video_device *vdev);
-static void init_buffers(struct v4l2_loopback_device *dev);
-static int allocate_buffers(struct v4l2_loopback_device *dev);
+static bool any_buffers_mapped(struct v4l2_loopback_device *dev);
+static int allocate_buffers(struct v4l2_loopback_device *dev,
+			    struct v4l2_pix_format *pix_format);
+static void init_buffers(struct v4l2_loopback_device *dev, u32 bytes_used,
+			 u32 buffer_size);
 static void free_buffers(struct v4l2_loopback_device *dev);
-static void try_free_buffers(struct v4l2_loopback_device *dev);
-static int allocate_timeout_image(struct v4l2_loopback_device *dev);
+static int allocate_timeout_buffer(struct v4l2_loopback_device *dev);
+static void free_timeout_buffer(struct v4l2_loopback_device *dev);
 static void check_timers(struct v4l2_loopback_device *dev);
 static const struct v4l2_file_operations v4l2_loopback_fops;
 static const struct v4l2_ioctl_ops v4l2_loopback_ioctl_ops;
 
-/* Queue helpers */
-/* next functions sets buffer flags and adjusts counters accordingly */
-static inline void set_done(struct v4l2l_buffer *buffer)
-{
-	buffer->buffer.flags &= ~V4L2_BUF_FLAG_QUEUED;
-	buffer->buffer.flags |= V4L2_BUF_FLAG_DONE;
-}
-
-static inline void set_queued(struct v4l2l_buffer *buffer)
-{
-	buffer->buffer.flags &= ~V4L2_BUF_FLAG_DONE;
-	buffer->buffer.flags |= V4L2_BUF_FLAG_QUEUED;
-}
-
-static inline void unset_flags(struct v4l2l_buffer *buffer)
-{
-	buffer->buffer.flags &= ~V4L2_BUF_FLAG_QUEUED;
-	buffer->buffer.flags &= ~V4L2_BUF_FLAG_DONE;
-}
-
 /* V4L2 ioctl caps and params calls */
 /* returns device capabilities
  * called on VIDIOC_QUERYCAP
  */
-static int vidioc_querycap(struct file *file, void *priv,
+static int vidioc_querycap(struct file *file, void *fh,
 			   struct v4l2_capability *cap)
 {
 	struct v4l2_loopback_device *dev = v4l2loopback_getdevice(file);
-	int device_nr =
-		((struct v4l2loopback_private *)video_get_drvdata(dev->vdev))
-			->device_nr;
+	struct v4l2_loopback_opener *opener = fh_to_opener(fh);
+	int device_nr = v4l2loopback_get_vdev_nr(dev->vdev);
 	__u32 capabilities = V4L2_CAP_STREAMING | V4L2_CAP_READWRITE;
 
 	strscpy(cap->driver, "v4l2 loopback", sizeof(cap->driver));
@@ -932,12 +892,12 @@ static int vidioc_querycap(struct file *file, void *priv,
 	if (dev->announce_all_caps) {
 		capabilities |= V4L2_CAP_VIDEO_CAPTURE | V4L2_CAP_VIDEO_OUTPUT;
 	} else {
-		if (dev->ready_for_capture) {
-			capabilities |= V4L2_CAP_VIDEO_CAPTURE;
-		}
-		if (dev->ready_for_output) {
+		if (opener->io_method == V4L2L_IO_TIMEOUT ||
+		    (has_output_token(dev->stream_tokens) &&
+		     !dev->keep_format)) {
 			capabilities |= V4L2_CAP_VIDEO_OUTPUT;
-		}
+		} else
+			capabilities |= V4L2_CAP_VIDEO_CAPTURE;
 	}
 
 #if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 7, 0)
@@ -954,17 +914,15 @@ static int vidioc_querycap(struct file *file, void *priv,
 static int vidioc_enum_framesizes(struct file *file, void *fh,
 				  struct v4l2_frmsizeenum *argp)
 {
-	struct v4l2_loopback_device *dev;
+	struct v4l2_loopback_device *dev = v4l2loopback_getdevice(file);
+	struct v4l2_loopback_opener *opener = fh_to_opener(fh);
 
 	/* there can be only one... */
 	if (argp->index)
 		return -EINVAL;
 
-	dev = v4l2loopback_getdevice(file);
-	if (V4L2LOOPBACK_IS_FIXED_FMT(dev)) {
-		/* format has already been negotiated
-		 * cannot change during runtime
-		 */
+	if (dev->keep_format || has_other_owners(opener, dev)) {
+		/* only current frame size supported */
 		if (argp->pixel_format != dev->pix_format.pixelformat)
 			return -EINVAL;
 
@@ -973,8 +931,7 @@ static int vidioc_enum_framesizes(struct file *file, void *fh,
 		argp->discrete.width = dev->pix_format.width;
 		argp->discrete.height = dev->pix_format.height;
 	} else {
-		/* if the format has not been negotiated yet, we accept anything
-		 */
+		/* return continuous sizes if pixel format is supported */
 		if (NULL == format_by_fourcc(argp->pixel_format))
 			return -EINVAL;
 
@@ -1000,6 +957,39 @@ static int vidioc_enum_framesizes(struct file *file, void *fh,
 	return 0;
 }
 
+/* Test if the device is currently 'capable' of the buffer (stream) type when
+ * the `exclusive_caps` parameter is set. `keep_format` should lock the format
+ * and prevent free of buffers */
+static int check_buffer_capability(struct v4l2_loopback_device *dev,
+				   struct v4l2_loopback_opener *opener,
+				   enum v4l2_buf_type type)
+{
+	/* short-circuit for (non-compliant) timeout image mode */
+	if (opener->io_method == V4L2L_IO_TIMEOUT)
+		return 0;
+	if (dev->announce_all_caps)
+		return (type == V4L2_BUF_TYPE_VIDEO_CAPTURE ||
+			type == V4L2_BUF_TYPE_VIDEO_OUTPUT) ?
+			       0 :
+			       -EINVAL;
+	/* CAPTURE if opener has a capture format or a writer is streaming;
+	 * else OUTPUT. */
+	switch (type) {
+	case V4L2_BUF_TYPE_VIDEO_CAPTURE:
+		if (!(has_capture_token(opener->format_token) ||
+		      !has_output_token(dev->stream_tokens)))
+			return -EINVAL;
+		break;
+	case V4L2_BUF_TYPE_VIDEO_OUTPUT:
+		if (!(has_output_token(opener->format_token) ||
+		      has_output_token(dev->stream_tokens)))
+			return -EINVAL;
+		break;
+	default:
+		return -EINVAL;
+	}
+	return 0;
+}
 /* returns frameinterval (fps) for the set resolution
  * called on VIDIOC_ENUM_FRAMEINTERVALS
  */
@@ -1007,12 +997,14 @@ static int vidioc_enum_frameintervals(struct file *file, void *fh,
 				      struct v4l2_frmivalenum *argp)
 {
 	struct v4l2_loopback_device *dev = v4l2loopback_getdevice(file);
+	struct v4l2_loopback_opener *opener = fh_to_opener(fh);
 
 	/* there can be only one... */
 	if (argp->index)
 		return -EINVAL;
 
-	if (V4L2LOOPBACK_IS_FIXED_FMT(dev)) {
+	if (dev->keep_format || has_other_owners(opener, dev)) {
+		/* keep_format also locks the frame rate */
 		if (argp->width != dev->pix_format.width ||
 		    argp->height != dev->pix_format.height ||
 		    argp->pixel_format != dev->pix_format.pixelformat)
@@ -1025,14 +1017,14 @@ static int vidioc_enum_frameintervals(struct file *file, void *fh,
 		    argp->width > dev->max_width ||
 		    argp->height < dev->min_height ||
 		    argp->height > dev->max_height ||
-		    NULL == format_by_fourcc(argp->pixel_format))
+		    !format_by_fourcc(argp->pixel_format))
 			return -EINVAL;
 
 		argp->type = V4L2_FRMIVAL_TYPE_CONTINUOUS;
 		argp->stepwise.min.numerator = 1;
 		argp->stepwise.min.denominator = V4L2LOOPBACK_FPS_MAX;
-		argp->stepwise.max.numerator = 1;
-		argp->stepwise.max.denominator = V4L2LOOPBACK_FPS_MIN;
+		argp->stepwise.max.numerator = V4L2LOOPBACK_FRAME_INTERVAL_MAX;
+		argp->stepwise.max.denominator = 1;
 		argp->stepwise.step.numerator = 1;
 		argp->stepwise.step.denominator = 1;
 	}
@@ -1040,164 +1032,177 @@ static int vidioc_enum_frameintervals(struct file *file, void *fh,
 	return 0;
 }
 
-/* ------------------ CAPTURE ----------------------- */
-
-/* returns device formats
- * called on VIDIOC_ENUM_FMT, with v4l2_buf_type set to V4L2_BUF_TYPE_VIDEO_CAPTURE
- */
-static int vidioc_enum_fmt_cap(struct file *file, void *fh,
+/* Enumerate device formats
+ * Returns:
+ * -   EINVAL the index is out of bounds; or if non-zero when format is fixed
+ * -   EFAULT unexpected null pointer */
+static int vidioc_enum_fmt_vid(struct file *file, void *fh,
 			       struct v4l2_fmtdesc *f)
 {
-	struct v4l2_loopback_device *dev;
+	struct v4l2_loopback_device *dev = v4l2loopback_getdevice(file);
+	struct v4l2_loopback_opener *opener = fh_to_opener(fh);
+	int fixed = dev->keep_format || has_other_owners(opener, dev);
 	const struct v4l2l_format *fmt;
-	MARK();
 
-	dev = v4l2loopback_getdevice(file);
-
-	if (f->index)
+	if (check_buffer_capability(dev, opener, f->type) < 0)
 		return -EINVAL;
 
-	if (V4L2LOOPBACK_IS_FIXED_FMT(dev)) {
-		/* format has been fixed, so only one single format is supported */
-		const __u32 format = dev->pix_format.pixelformat;
+	if (!(f->index < FORMATS))
+		return -EINVAL;
+	/* TODO: Support 6.14 V4L2_FMTDESC_FLAG_ENUM_ALL */
+	if (fixed && f->index)
+		return -EINVAL;
 
-		if ((fmt = format_by_fourcc(format))) {
-			snprintf(f->description, sizeof(f->description), "%s",
-				 fmt->name);
-		} else {
-			snprintf(f->description, sizeof(f->description),
-				 "[%c%c%c%c]", (format >> 0) & 0xFF,
-				 (format >> 8) & 0xFF, (format >> 16) & 0xFF,
-				 (format >> 24) & 0xFF);
-		}
+	fmt = fixed ? format_by_fourcc(dev->pix_format.pixelformat) :
+		      &formats[f->index];
+	if (!fmt)
+		return -EFAULT;
 
-		f->pixelformat = dev->pix_format.pixelformat;
-	} else {
-		return -EINVAL;
-	}
 	f->flags = 0;
-	MARK();
+	if (fmt->flags & FORMAT_FLAGS_COMPRESSED)
+		f->flags |= V4L2_FMT_FLAG_COMPRESSED;
+	snprintf(f->description, sizeof(f->description), fmt->name);
+	f->pixelformat = fmt->fourcc;
 	return 0;
 }
 
-/* returns current video format
- * called on VIDIOC_G_FMT, with v4l2_buf_type set to V4L2_BUF_TYPE_VIDEO_CAPTURE
+/* Tests (or tries) the format.
+ * Returns:
+ * -   EINVAL if the buffer type or format is not supported
  */
-static int vidioc_g_fmt_cap(struct file *file, void *priv,
-			    struct v4l2_format *fmt)
+static int vidioc_try_fmt_vid(struct file *file, void *fh,
+			      struct v4l2_format *f)
 {
-	struct v4l2_loopback_device *dev;
-	MARK();
+	struct v4l2_loopback_device *dev = v4l2loopback_getdevice(file);
+	struct v4l2_loopback_opener *opener = fh_to_opener(fh);
 
-	dev = v4l2loopback_getdevice(file);
-	if (!dev->ready_for_capture && !dev->ready_for_output)
+	if (check_buffer_capability(dev, opener, f->type) < 0)
+		return -EINVAL;
+	if (v4l2l_fill_format(f, dev->min_width, dev->max_width,
+			      dev->min_height, dev->max_height) != 0)
 		return -EINVAL;
+	if (dev->keep_format || has_other_owners(opener, dev))
+		/* use existing format - including colorspace info */
+		f->fmt.pix = dev->pix_format;
 
-	fmt->fmt.pix = dev->pix_format;
-	MARK();
 	return 0;
 }
 
-/* checks if it is OK to change to format fmt;
- * actual check is done by inner_try_setfmt
- * just checking that pixelformat is OK and set other parameters, app should
- * obey this decision
- * called on VIDIOC_TRY_FMT, with v4l2_buf_type set to V4L2_BUF_TYPE_VIDEO_CAPTURE
- */
-static int vidioc_try_fmt_cap(struct file *file, void *priv,
-			      struct v4l2_format *fmt)
-{
-	int ret = 0;
-	if (!V4L2_TYPE_IS_CAPTURE(fmt->type))
-		return -EINVAL;
-	ret = inner_try_setfmt(file, fmt);
-	if (-EBUSY == ret)
-		return 0;
-	return ret;
-}
-
-/* sets new output format, if possible
- * actually format is set  by input and we even do not check it, just return
- * current one, but it is possible to set subregions of input TODO(vasaka)
- * called on VIDIOC_S_FMT, with v4l2_buf_type set to V4L2_BUF_TYPE_VIDEO_CAPTURE
+/* Sets new format. Fills 'f' argument with the requested or existing format.
+ * Side-effect: buffers are allocated for the (returned) format.
+ * Returns:
+ * -   EINVAL if the type is not supported
+ * -   EBUSY if buffers are already allocated
+ * TODO: (vasaka) set subregions of input
  */
-static int vidioc_s_fmt_cap(struct file *file, void *priv,
-			    struct v4l2_format *fmt)
+static int vidioc_s_fmt_vid(struct file *file, void *fh, struct v4l2_format *f)
 {
-	int ret;
 	struct v4l2_loopback_device *dev = v4l2loopback_getdevice(file);
-	if (!V4L2_TYPE_IS_CAPTURE(fmt->type))
-		return -EINVAL;
-	ret = inner_try_setfmt(file, fmt);
-	if (!ret) {
-		dev->pix_format = fmt->fmt.pix;
+	struct v4l2_loopback_opener *opener = fh_to_opener(fh);
+	u32 token = opener->io_method == V4L2L_IO_TIMEOUT ?
+			    V4L2L_TOKEN_TIMEOUT :
+			    token_from_type(f->type);
+	int changed, result;
+	char buf[5];
+
+	result = vidioc_try_fmt_vid(file, fh, f);
+	if (result < 0)
+		return result;
+
+	if (opener->buffer_count > 0)
+		/* must free buffers before format can be set */
+		return -EBUSY;
+
+	result = mutex_lock_killable(&dev->image_mutex);
+	if (result < 0)
+		return result;
+
+	if (opener->format_token)
+		release_token(dev, opener, format);
+	if (!(dev->format_tokens & token)) {
+		result = -EBUSY;
+		goto exit_s_fmt_unlock;
+	}
+
+	dprintk("S_FMT[%s] %4s:%ux%u size=%u\n",
+		V4L2_TYPE_IS_CAPTURE(f->type) ? "CAPTURE" : "OUTPUT",
+		fourcc2str(f->fmt.pix.pixelformat, buf), f->fmt.pix.width,
+		f->fmt.pix.height, f->fmt.pix.sizeimage);
+	changed = !pix_format_eq(&dev->pix_format, &f->fmt.pix, 0);
+	if (changed || has_no_owners(dev)) {
+		result = allocate_buffers(dev, &f->fmt.pix);
+		if (result < 0)
+			goto exit_s_fmt_unlock;
+	}
+	if ((dev->timeout_image && changed) ||
+	    (!dev->timeout_image && need_timeout_buffer(dev, token))) {
+		result = allocate_timeout_buffer(dev);
+		if (result < 0)
+			goto exit_s_fmt_free;
+	}
+	if (changed) {
+		dev->pix_format = f->fmt.pix;
+		dev->pix_format_has_valid_sizeimage =
+			v4l2l_pix_format_has_valid_sizeimage(f);
 	}
-	return ret;
+	acquire_token(dev, opener, format, token);
+	if (opener->io_method == V4L2L_IO_TIMEOUT)
+		dev->timeout_image_io = 0;
+	goto exit_s_fmt_unlock;
+exit_s_fmt_free:
+	free_buffers(dev);
+exit_s_fmt_unlock:
+	mutex_unlock(&dev->image_mutex);
+	return result;
 }
 
-/* ------------------ OUTPUT ----------------------- */
+/* ------------------ CAPTURE ----------------------- */
+/* ioctl for VIDIOC_ENUM_FMT, _G_FMT, _S_FMT, and _TRY_FMT when buffer type
+ * is V4L2_BUF_TYPE_VIDEO_CAPTURE */
 
-/* returns device formats;
- * LATER: allow all formats
- * called on VIDIOC_ENUM_FMT, with v4l2_buf_type set to V4L2_BUF_TYPE_VIDEO_OUTPUT
- */
-static int vidioc_enum_fmt_out(struct file *file, void *fh,
+static int vidioc_enum_fmt_cap(struct file *file, void *fh,
 			       struct v4l2_fmtdesc *f)
 {
-	struct v4l2_loopback_device *dev;
-	const struct v4l2l_format *fmt;
-
-	dev = v4l2loopback_getdevice(file);
-
-	if (V4L2LOOPBACK_IS_FIXED_FMT(dev)) {
-		/* format has been fixed, so only one single format is supported */
-		const __u32 format = dev->pix_format.pixelformat;
-
-		if (f->index)
-			return -EINVAL;
+	return vidioc_enum_fmt_vid(file, fh, f);
+}
 
-		if ((fmt = format_by_fourcc(format))) {
-			snprintf(f->description, sizeof(f->description), "%s",
-				 fmt->name);
-		} else {
-			snprintf(f->description, sizeof(f->description),
-				 "[%c%c%c%c]", (format >> 0) & 0xFF,
-				 (format >> 8) & 0xFF, (format >> 16) & 0xFF,
-				 (format >> 24) & 0xFF);
-		}
+static int vidioc_g_fmt_cap(struct file *file, void *fh, struct v4l2_format *f)
+{
+	struct v4l2_loopback_device *dev = v4l2loopback_getdevice(file);
+	struct v4l2_loopback_opener *opener = fh_to_opener(fh);
+	if (check_buffer_capability(dev, opener, f->type) < 0)
+		return -EINVAL;
+	f->fmt.pix = dev->pix_format;
+	return 0;
+}
 
-		f->pixelformat = dev->pix_format.pixelformat;
-	} else {
-		/* fill in a dummy format */
-		/* coverity[unsigned_compare] */
-		if (f->index < 0 || f->index >= FORMATS)
-			return -EINVAL;
+static int vidioc_try_fmt_cap(struct file *file, void *fh,
+			      struct v4l2_format *f)
+{
+	return vidioc_try_fmt_vid(file, fh, f);
+}
 
-		fmt = &formats[f->index];
+static int vidioc_s_fmt_cap(struct file *file, void *fh, struct v4l2_format *f)
+{
+	return vidioc_s_fmt_vid(file, fh, f);
+}
 
-		f->pixelformat = fmt->fourcc;
-		snprintf(f->description, sizeof(f->description), "%s",
-			 fmt->name);
-	}
-	f->flags = 0;
+/* ------------------ OUTPUT ----------------------- */
+/* ioctl for VIDIOC_ENUM_FMT, _G_FMT, _S_FMT, and _TRY_FMT when buffer type
+ * is V4L2_BUF_TYPE_VIDEO_OUTPUT */
 
-	return 0;
+static int vidioc_enum_fmt_out(struct file *file, void *fh,
+			       struct v4l2_fmtdesc *f)
+{
+	return vidioc_enum_fmt_vid(file, fh, f);
 }
 
-/* returns current video format format fmt */
-/* NOTE: this is called from the producer
- * so if format has not been negotiated yet,
- * it should return ALL of available formats,
- * called on VIDIOC_G_FMT, with v4l2_buf_type set to V4L2_BUF_TYPE_VIDEO_OUTPUT
- */
-static int vidioc_g_fmt_out(struct file *file, void *priv,
-			    struct v4l2_format *fmt)
+static int vidioc_g_fmt_out(struct file *file, void *fh, struct v4l2_format *f)
 {
-	struct v4l2_loopback_device *dev;
-	MARK();
-
-	dev = v4l2loopback_getdevice(file);
-
+	struct v4l2_loopback_device *dev = v4l2loopback_getdevice(file);
+	struct v4l2_loopback_opener *opener = fh_to_opener(fh);
+	if (check_buffer_capability(dev, opener, f->type) < 0)
+		return -EINVAL;
 	/*
 	 * LATER: this should return the currently valid format
 	 * gstreamer doesn't like it, if this returns -EINVAL, as it
@@ -1205,62 +1210,19 @@ static int vidioc_g_fmt_out(struct file *file, void *priv,
 	 * CHECK whether this assumption is wrong,
 	 * or whether we have to always provide a valid format
 	 */
-
-	fmt->fmt.pix = dev->pix_format;
+	f->fmt.pix = dev->pix_format;
 	return 0;
 }
 
-/* checks if it is OK to change to format fmt;
- * if format is negotiated do not change it
- * called on VIDIOC_TRY_FMT with v4l2_buf_type set to V4L2_BUF_TYPE_VIDEO_OUTPUT
- */
-static int vidioc_try_fmt_out(struct file *file, void *priv,
-			      struct v4l2_format *fmt)
+static int vidioc_try_fmt_out(struct file *file, void *fh,
+			      struct v4l2_format *f)
 {
-	int ret = 0;
-	if (!V4L2_TYPE_IS_OUTPUT(fmt->type))
-		return -EINVAL;
-	ret = inner_try_setfmt(file, fmt);
-	if (-EBUSY == ret)
-		return 0;
-	return ret;
+	return vidioc_try_fmt_vid(file, fh, f);
 }
 
-/* sets new output format, if possible;
- * allocate data here because we do not know if it will be streaming or
- * read/write IO
- * called on VIDIOC_S_FMT with v4l2_buf_type set to V4L2_BUF_TYPE_VIDEO_OUTPUT
- */
-static int vidioc_s_fmt_out(struct file *file, void *priv,
-			    struct v4l2_format *fmt)
+static int vidioc_s_fmt_out(struct file *file, void *fh, struct v4l2_format *f)
 {
-	struct v4l2_loopback_device *dev;
-	int ret;
-	char buf[5];
-	buf[4] = 0;
-	if (!V4L2_TYPE_IS_OUTPUT(fmt->type))
-		return -EINVAL;
-	dev = v4l2loopback_getdevice(file);
-
-	ret = inner_try_setfmt(file, fmt);
-	if (!ret) {
-		dev->pix_format = fmt->fmt.pix;
-		dev->pix_format_has_valid_sizeimage =
-			v4l2l_pix_format_has_valid_sizeimage(fmt);
-		dprintk("s_fmt_out(%d) %d...%d\n", ret, dev->ready_for_capture,
-			dev->pix_format.sizeimage);
-		dprintk("outFOURCC=%s\n",
-			fourcc2str(dev->pix_format.pixelformat, buf));
-
-		if (!dev->ready_for_capture) {
-			dev->buffer_size =
-				PAGE_ALIGN(dev->pix_format.sizeimage);
-			// JMZ: TODO get rid of the next line
-			fmt->fmt.pix.sizeimage = dev->buffer_size;
-			ret = allocate_buffers(dev);
-		}
-	}
-	return ret;
+	return vidioc_s_fmt_vid(file, fh, f);
 }
 
 // #define V4L2L_OVERLAY
@@ -1291,15 +1253,15 @@ static int vidioc_s_fmt_overlay(struct file *file, void *priv,
  * effect on this driver
  * called on VIDIOC_G_PARM
  */
-static int vidioc_g_parm(struct file *file, void *priv,
+static int vidioc_g_parm(struct file *file, void *fh,
 			 struct v4l2_streamparm *parm)
 {
 	/* do not care about type of opener, hope these enums would always be
 	 * compatible */
-	struct v4l2_loopback_device *dev;
-	MARK();
-
-	dev = v4l2loopback_getdevice(file);
+	struct v4l2_loopback_device *dev = v4l2loopback_getdevice(file);
+	struct v4l2_loopback_opener *opener = fh_to_opener(fh);
+	if (check_buffer_capability(dev, opener, parm->type) < 0)
+		return -EINVAL;
 	parm->parm.capture = dev->capture_param;
 	return 0;
 }
@@ -1308,31 +1270,27 @@ static int vidioc_g_parm(struct file *file, void *priv,
  * effect on this driver
  * called on VIDIOC_S_PARM
  */
-static int vidioc_s_parm(struct file *file, void *priv,
+static int vidioc_s_parm(struct file *file, void *fh,
 			 struct v4l2_streamparm *parm)
 {
-	struct v4l2_loopback_device *dev;
-	int err = 0;
-	MARK();
+	struct v4l2_loopback_device *dev = v4l2loopback_getdevice(file);
+	struct v4l2_loopback_opener *opener = fh_to_opener(fh);
 
-	dev = v4l2loopback_getdevice(file);
-	dprintk("vidioc_s_parm called frate=%d/%d\n",
+	dprintk("S_PARM(frame-time=%u/%u)\n",
 		parm->parm.capture.timeperframe.numerator,
 		parm->parm.capture.timeperframe.denominator);
+	if (check_buffer_capability(dev, opener, parm->type) < 0)
+		return -EINVAL;
 
 	switch (parm->type) {
 	case V4L2_BUF_TYPE_VIDEO_CAPTURE:
-		if ((err = set_timeperframe(
-			     dev, &parm->parm.capture.timeperframe)) < 0)
-			return err;
+		set_timeperframe(dev, &parm->parm.capture.timeperframe);
 		break;
 	case V4L2_BUF_TYPE_VIDEO_OUTPUT:
-		if ((err = set_timeperframe(
-			     dev, &parm->parm.capture.timeperframe)) < 0)
-			return err;
+		set_timeperframe(dev, &parm->parm.output.timeperframe);
 		break;
 	default:
-		return -1;
+		return -EINVAL;
 	}
 
 	parm->parm.capture = dev->capture_param;
@@ -1385,13 +1343,20 @@ static int vidioc_querystd(struct file *file, void *fh, v4l2_std_id *norm)
 static int v4l2loopback_set_ctrl(struct v4l2_loopback_device *dev, u32 id,
 				 s64 val)
 {
+	int result = 0;
 	switch (id) {
 	case CID_KEEP_FORMAT:
 		if (val < 0 || val > 1)
 			return -EINVAL;
 		dev->keep_format = val;
-		try_free_buffers(
-			dev); /* will only free buffers if !keep_format */
+		result = mutex_lock_killable(&dev->image_mutex);
+		if (result < 0)
+			return result;
+		if (!dev->keep_format) {
+			if (has_no_owners(dev) && !any_buffers_mapped(dev))
+				free_buffers(dev);
+		}
+		mutex_unlock(&dev->image_mutex);
 		break;
 	case CID_SUSTAIN_FRAMERATE:
 		if (val < 0 || val > 1)
@@ -1404,11 +1369,27 @@ static int v4l2loopback_set_ctrl(struct v4l2_loopback_device *dev, u32 id,
 	case CID_TIMEOUT:
 		if (val < 0 || val > MAX_TIMEOUT)
 			return -EINVAL;
+		if (val > 0) {
+			result = mutex_lock_killable(&dev->image_mutex);
+			if (result < 0)
+				return result;
+			/* on-the-fly allocate if device is owned; else
+			 * allocate occurs on next S_FMT or REQBUFS */
+			if (!has_no_owners(dev))
+				result = allocate_timeout_buffer(dev);
+			mutex_unlock(&dev->image_mutex);
+			if (result < 0) {
+				/* disable timeout as buffer not alloc'd */
+				spin_lock_bh(&dev->lock);
+				dev->timeout_jiffies = 0;
+				spin_unlock_bh(&dev->lock);
+				return result;
+			}
+		}
 		spin_lock_bh(&dev->lock);
 		dev->timeout_jiffies = msecs_to_jiffies(val);
 		check_timers(dev);
 		spin_unlock_bh(&dev->lock);
-		allocate_timeout_image(dev);
 		break;
 	case CID_TIMEOUT_IMAGE_IO:
 		dev->timeout_image_io = 1;
@@ -1434,12 +1415,11 @@ static int vidioc_enum_output(struct file *file, void *fh,
 {
 	__u32 index = outp->index;
 	struct v4l2_loopback_device *dev = v4l2loopback_getdevice(file);
-	MARK();
+	struct v4l2_loopback_opener *opener = fh_to_opener(fh);
 
-	if (!dev->announce_all_caps && !dev->ready_for_output)
+	if (check_buffer_capability(dev, opener, V4L2_BUF_TYPE_VIDEO_OUTPUT))
 		return -ENOTTY;
-
-	if (0 != index)
+	if (index)
 		return -EINVAL;
 
 	/* clear all data (including the reserved fields) */
@@ -1463,29 +1443,27 @@ static int vidioc_enum_output(struct file *file, void *fh,
 /* which output is currently active,
  * called on VIDIOC_G_OUTPUT
  */
-static int vidioc_g_output(struct file *file, void *fh, unsigned int *i)
+static int vidioc_g_output(struct file *file, void *fh, unsigned int *index)
 {
 	struct v4l2_loopback_device *dev = v4l2loopback_getdevice(file);
-	if (!dev->announce_all_caps && !dev->ready_for_output)
+	struct v4l2_loopback_opener *opener = fh_to_opener(fh);
+	if (check_buffer_capability(dev, opener, V4L2_BUF_TYPE_VIDEO_OUTPUT))
 		return -ENOTTY;
-	if (i)
-		*i = 0;
+	if (index)
+		*index = 0;
 	return 0;
 }
 
 /* set output, can make sense if we have more than one video src,
  * called on VIDIOC_S_OUTPUT
  */
-static int vidioc_s_output(struct file *file, void *fh, unsigned int i)
+static int vidioc_s_output(struct file *file, void *fh, unsigned int index)
 {
 	struct v4l2_loopback_device *dev = v4l2loopback_getdevice(file);
-	if (!dev->announce_all_caps && !dev->ready_for_output)
+	struct v4l2_loopback_opener *opener = fh_to_opener(fh);
+	if (check_buffer_capability(dev, opener, V4L2_BUF_TYPE_VIDEO_OUTPUT))
 		return -ENOTTY;
-
-	if (i)
-		return -EINVAL;
-
-	return 0;
+	return index == 0 ? index : -EINVAL;
 }
 
 /* returns set of device inputs, in our case there is only one,
@@ -1495,11 +1473,13 @@ static int vidioc_s_output(struct file *file, void *fh, unsigned int i)
 static int vidioc_enum_input(struct file *file, void *fh,
 			     struct v4l2_input *inp)
 {
-	struct v4l2_loopback_device *dev;
+	struct v4l2_loopback_device *dev = v4l2loopback_getdevice(file);
+	struct v4l2_loopback_opener *opener = fh_to_opener(fh);
 	__u32 index = inp->index;
-	MARK();
 
-	if (0 != index)
+	if (check_buffer_capability(dev, opener, V4L2_BUF_TYPE_VIDEO_CAPTURE))
+		return -ENOTTY;
+	if (index)
 		return -EINVAL;
 
 	/* clear all data (including the reserved fields) */
@@ -1519,10 +1499,9 @@ static int vidioc_enum_input(struct file *file, void *fh,
 #endif
 #endif /* V4L2LOOPBACK_WITH_STD */
 
-	dev = v4l2loopback_getdevice(file);
-	if (!dev->ready_for_capture) {
+	if (has_output_token(dev->stream_tokens) && !dev->keep_format)
+		/* if no outputs attached; pretend device is powered off */
 		inp->status |= V4L2_IN_ST_NO_SIGNAL;
-	}
 
 	return 0;
 }
@@ -1530,109 +1509,236 @@ static int vidioc_enum_input(struct file *file, void *fh,
 /* which input is currently active,
  * called on VIDIOC_G_INPUT
  */
-static int vidioc_g_input(struct file *file, void *fh, unsigned int *i)
+static int vidioc_g_input(struct file *file, void *fh, unsigned int *index)
 {
 	struct v4l2_loopback_device *dev = v4l2loopback_getdevice(file);
-	if (!dev->announce_all_caps && !dev->ready_for_capture)
-		return -ENOTTY;
-	if (i)
-		*i = 0;
+	struct v4l2_loopback_opener *opener = fh_to_opener(fh);
+	if (check_buffer_capability(dev, opener, V4L2_BUF_TYPE_VIDEO_CAPTURE))
+		return -ENOTTY; /* NOTE: -EAGAIN might be more informative */
+	if (index)
+		*index = 0;
 	return 0;
 }
 
 /* set input, can make sense if we have more than one video src,
  * called on VIDIOC_S_INPUT
  */
-static int vidioc_s_input(struct file *file, void *fh, unsigned int i)
+static int vidioc_s_input(struct file *file, void *fh, unsigned int index)
 {
 	struct v4l2_loopback_device *dev = v4l2loopback_getdevice(file);
-	if (!dev->announce_all_caps && !dev->ready_for_capture)
-		return -ENOTTY;
-	if (i == 0)
-		return 0;
-	return -EINVAL;
+	struct v4l2_loopback_opener *opener = fh_to_opener(fh);
+	if (index != 0)
+		return -EINVAL;
+	if (check_buffer_capability(dev, opener, V4L2_BUF_TYPE_VIDEO_CAPTURE))
+		return -ENOTTY; /* NOTE: -EAGAIN might be more informative */
+	return 0;
 }
 
 /* --------------- V4L2 ioctl buffer related calls ----------------- */
 
-/* negotiate buffer type
- * only mmap streaming supported
- * called on VIDIOC_REQBUFS
- */
-static int vidioc_reqbufs(struct file *file, void *fh,
-			  struct v4l2_requestbuffers *b)
+#define is_allocated(opener, type, index)                                \
+	(opener->format_token & (opener->io_method == V4L2L_IO_TIMEOUT ? \
+					 V4L2L_TOKEN_TIMEOUT :           \
+					 token_from_type(type)) &&       \
+	 (index) < (opener)->buffer_count)
+#define BUFFER_DEBUG_FMT_STR                                      \
+	"buffer#%u @ %p type=%u bytesused=%u length=%u flags=%x " \
+	"field=%u timestamp= %lld.%06lldsequence=%u\n"
+#define BUFFER_DEBUG_FMT_ARGS(buf)                                         \
+	(buf)->index, (buf), (buf)->type, (buf)->bytesused, (buf)->length, \
+		(buf)->flags, (buf)->field,                                \
+		(long long)(buf)->timestamp.tv_sec,                        \
+		(long long)(buf)->timestamp.tv_usec, (buf)->sequence
+/* Buffer flag helpers */
+#define unset_flags(flags)                      \
+	do {                                    \
+		flags &= ~V4L2_BUF_FLAG_QUEUED; \
+		flags &= ~V4L2_BUF_FLAG_DONE;   \
+	} while (0)
+#define set_queued(flags)                      \
+	do {                                   \
+		flags |= V4L2_BUF_FLAG_QUEUED; \
+		flags &= ~V4L2_BUF_FLAG_DONE;  \
+	} while (0)
+#define set_done(flags)                         \
+	do {                                    \
+		flags &= ~V4L2_BUF_FLAG_QUEUED; \
+		flags |= V4L2_BUF_FLAG_DONE;    \
+	} while (0)
+
+static bool any_buffers_mapped(struct v4l2_loopback_device *dev)
 {
-	struct v4l2_loopback_device *dev;
-	struct v4l2_loopback_opener *opener;
-	int i;
-	MARK();
+	u32 index;
+	for (index = 0; index < dev->buffer_count; ++index)
+		if (dev->buffers[index].buffer.flags & V4L2_BUF_FLAG_MAPPED)
+			return true;
+	return false;
+}
 
-	dev = v4l2loopback_getdevice(file);
-	opener = fh_to_opener(fh);
+static void prepare_buffer_queue(struct v4l2_loopback_device *dev, int count)
+{
+	struct v4l2l_buffer *bufd, *n;
+	u32 pos;
 
-	dprintk("reqbufs: %d\t%d=%d\n", b->memory, b->count,
-		dev->buffers_number);
+	spin_lock_bh(&dev->list_lock);
 
-	if (opener->timeout_image_io) {
-		dev->timeout_image_io = 0;
-		if (b->memory != V4L2_MEMORY_MMAP)
-			return -EINVAL;
-		b->count = 2;
-		return 0;
+	/* ensure sufficient number of buffers in queue */
+	for (pos = 0; pos < count; ++pos) {
+		bufd = &dev->buffers[pos];
+		if (list_empty(&bufd->list_head))
+			list_add_tail(&bufd->list_head, &dev->outbufs_list);
 	}
+	if (list_empty(&dev->outbufs_list))
+		goto exit_prepare_queue_unlock;
 
-	if (V4L2_TYPE_IS_OUTPUT(b->type) && (!dev->ready_for_output)) {
-		return -EBUSY;
+	/* remove any excess buffers */
+	list_for_each_entry_safe(bufd, n, &dev->outbufs_list, list_head) {
+		if (bufd->buffer.index >= count)
+			list_del_init(&bufd->list_head);
 	}
 
-	init_buffers(dev);
-	switch (b->memory) {
-	case V4L2_MEMORY_MMAP:
-		/* do nothing here, buffers are always allocated */
-		if (b->count < 1 || dev->buffers_number < 1)
-			return 0;
-
-		if (b->count > dev->buffers_number)
-			b->count = dev->buffers_number;
-
-		/* make sure that outbufs_list contains buffers from 0 to used_buffers-1
-		 * actually, it will have been already populated via v4l2_loopback_init()
-		 * at this point */
-		if (list_empty(&dev->outbufs_list)) {
-			for (i = 0; i < dev->used_buffers; ++i)
-				list_add_tail(&dev->buffers[i].list_head,
-					      &dev->outbufs_list);
-		}
+	/* buffers are no longer queued; and `write_position` will correspond
+	 * to the first item of `outbufs_list`. */
+	pos = v4l2l_mod64(dev->write_position, count);
+	list_for_each_entry(bufd, &dev->outbufs_list, list_head) {
+		unset_flags(bufd->buffer.flags);
+		dev->bufpos2index[pos % count] = bufd->buffer.index;
+		++pos;
+	}
+exit_prepare_queue_unlock:
+	spin_unlock_bh(&dev->list_lock);
+}
 
-		/* also, if dev->used_buffers is going to be decreased, we should remove
-		 * out-of-range buffers from outbufs_list, and fix bufpos2index mapping */
-		if (b->count < dev->used_buffers) {
-			struct v4l2l_buffer *pos, *n;
+/* forward declaration */
+static int vidioc_streamoff(struct file *file, void *fh,
+			    enum v4l2_buf_type type);
+/* negotiate buffer type
+ * only mmap streaming supported
+ * called on VIDIOC_REQBUFS
+ */
+static int vidioc_reqbufs(struct file *file, void *fh,
+			  struct v4l2_requestbuffers *reqbuf)
+{
+	struct v4l2_loopback_device *dev = v4l2loopback_getdevice(file);
+	struct v4l2_loopback_opener *opener = fh_to_opener(fh);
+	u32 token = opener->io_method == V4L2L_IO_TIMEOUT ?
+			    V4L2L_TOKEN_TIMEOUT :
+			    token_from_type(reqbuf->type);
+	u32 req_count = reqbuf->count;
+	int result = 0;
+
+	dprintk("REQBUFS(memory=%u, req_count=%u) and device-bufs=%u/%u "
+		"[used/max]\n",
+		reqbuf->memory, req_count, dev->used_buffer_count,
+		dev->buffer_count);
+
+	switch (reqbuf->memory) {
+	case V4L2_MEMORY_MMAP:
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 20, 0)
+		reqbuf->capabilities = 0; /* only guarantee MMAP support */
+#endif
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(5, 16, 0)
+		reqbuf->flags = 0; /* no memory consistency support */
+#endif
+		break;
+	default:
+		return -EINVAL;
+	}
 
-			list_for_each_entry_safe(pos, n, &dev->outbufs_list,
-						 list_head) {
-				if (pos->buffer.index >= b->count)
-					list_del(&pos->list_head);
-			}
+	if (opener->format_token & ~token)
+		/* different (buffer) type already assigned to descriptor by
+		 * S_FMT or REQBUFS */
+		return -EINVAL;
 
-			/* after we update dev->used_buffers, buffers in outbufs_list will
-			 * correspond to dev->write_position + [0;b->count-1] range */
-			i = v4l2l_mod64(dev->write_position, b->count);
-			list_for_each_entry(pos, &dev->outbufs_list,
-					    list_head) {
-				dev->bufpos2index[i % b->count] =
-					pos->buffer.index;
-				++i;
-			}
+	MARK();
+	result = mutex_lock_killable(&dev->image_mutex);
+	if (result < 0)
+		return result; /* -EINTR */
+
+	/* CASE queue/dequeue timeout-buffer only: */
+	if (opener->format_token & V4L2L_TOKEN_TIMEOUT) {
+		opener->buffer_count = req_count;
+		if (req_count == 0)
+			release_token(dev, opener, format);
+		goto exit_reqbufs_unlock;
+	}
+
+	MARK();
+	/* CASE count is zero: streamoff, free buffers, release their token */
+	if (req_count == 0) {
+		if (dev->format_tokens & token) {
+			acquire_token(dev, opener, format, token);
+			opener->io_method = V4L2L_IO_MMAP;
 		}
+		result = vidioc_streamoff(file, fh, reqbuf->type);
+		opener->buffer_count = 0;
+		/* undocumented requirement - REQBUFS with count zero should
+		 * ALSO release lock on logical stream */
+		if (opener->format_token)
+			release_token(dev, opener, format);
+		if (has_no_owners(dev))
+			dev->used_buffer_count = 0;
+		goto exit_reqbufs_unlock;
+	}
+
+	/* CASE count non-zero: allocate buffers and acquire token for them */
+	MARK();
+	switch (reqbuf->type) {
+	case V4L2_BUF_TYPE_VIDEO_CAPTURE:
+	case V4L2_BUF_TYPE_VIDEO_OUTPUT:
+		if (!(dev->format_tokens & token ||
+		      opener->format_token & token))
+			/* only exclusive ownership for each stream */
+			result = -EBUSY;
+		break;
+	default:
+		result = -EINVAL;
+	}
+	if (result < 0)
+		goto exit_reqbufs_unlock;
 
-		opener->buffers_number = b->count;
-		if (opener->buffers_number < dev->used_buffers)
-			dev->used_buffers = opener->buffers_number;
-		return 0;
+	if (has_other_owners(opener, dev) && dev->used_buffer_count > 0) {
+		/* allow 'allocation' of existing number of buffers */
+		req_count = dev->used_buffer_count;
+	} else if (any_buffers_mapped(dev)) {
+		/* do not allow re-allocation if buffers are mapped */
+		result = -EBUSY;
+		goto exit_reqbufs_unlock;
+	}
+
+	MARK();
+	opener->buffer_count = 0;
+
+	if (req_count > dev->buffer_count)
+		req_count = dev->buffer_count;
+
+	if (has_no_owners(dev)) {
+		result = allocate_buffers(dev, &dev->pix_format);
+		if (result < 0)
+			goto exit_reqbufs_unlock;
+	}
+	if (!dev->timeout_image && need_timeout_buffer(dev, token)) {
+		result = allocate_timeout_buffer(dev);
+		if (result < 0)
+			goto exit_reqbufs_unlock;
+	}
+	acquire_token(dev, opener, format, token);
+
+	MARK();
+	switch (opener->io_method) {
+	case V4L2L_IO_TIMEOUT:
+		dev->timeout_image_io = 0;
+		opener->buffer_count = req_count;
+		break;
 	default:
-		return -EINVAL;
+		opener->io_method = V4L2L_IO_MMAP;
+		prepare_buffer_queue(dev, req_count);
+		dev->used_buffer_count = opener->buffer_count = req_count;
 	}
+exit_reqbufs_unlock:
+	mutex_unlock(&dev->image_mutex);
+	reqbuf->count = opener->buffer_count;
+	return result;
 }
 
 /* returns buffer asked for;
@@ -1640,42 +1746,42 @@ static int vidioc_reqbufs(struct file *file, void *fh,
  * but map them in our inner buffers
  * called on VIDIOC_QUERYBUF
  */
-static int vidioc_querybuf(struct file *file, void *fh, struct v4l2_buffer *b)
+static int vidioc_querybuf(struct file *file, void *fh, struct v4l2_buffer *buf)
 {
-	enum v4l2_buf_type type;
-	int index;
-	struct v4l2_loopback_device *dev;
-	struct v4l2_loopback_opener *opener;
-
-	MARK();
-
-	type = b->type;
-	index = b->index;
-	dev = v4l2loopback_getdevice(file);
-	opener = fh_to_opener(fh);
+	struct v4l2_loopback_device *dev = v4l2loopback_getdevice(file);
+	struct v4l2_loopback_opener *opener = fh_to_opener(fh);
+	u32 type = buf->type;
+	u32 index = buf->index;
 
-	if ((b->type != V4L2_BUF_TYPE_VIDEO_CAPTURE) &&
-	    (b->type != V4L2_BUF_TYPE_VIDEO_OUTPUT)) {
+	if ((type != V4L2_BUF_TYPE_VIDEO_CAPTURE) &&
+	    (type != V4L2_BUF_TYPE_VIDEO_OUTPUT))
 		return -EINVAL;
-	}
-	if (b->index > max_buffers)
+	if (!is_allocated(opener, type, index))
 		return -EINVAL;
 
-	if (opener->timeout_image_io)
-		*b = dev->timeout_image_buffer.buffer;
-	else
-		*b = dev->buffers[b->index % dev->used_buffers].buffer;
-
-	b->type = type;
-	b->index = index;
-	dprintkrw("buffer type: %d (of %d with size=%ld)\n", b->memory,
-		  dev->buffers_number, dev->buffer_size);
-
-	/*  Hopefully fix 'DQBUF return bad index if queue bigger then 2 for capture'
-            https://github.com/umlaeute/v4l2loopback/issues/60 */
-	b->flags &= ~V4L2_BUF_FLAG_DONE;
-	b->flags |= V4L2_BUF_FLAG_QUEUED;
+	if (opener->format_token & V4L2L_TOKEN_TIMEOUT) {
+		*buf = dev->timeout_buffer.buffer;
+		buf->index = index;
+	} else
+		*buf = dev->buffers[index].buffer;
 
+	buf->type = type;
+
+	if (!(buf->flags & (V4L2_BUF_FLAG_DONE | V4L2_BUF_FLAG_QUEUED))) {
+		/* v4l2-compliance requires these to be zero */
+		buf->sequence = 0;
+		buf->timestamp.tv_sec = buf->timestamp.tv_usec = 0;
+	} else if (V4L2_TYPE_IS_CAPTURE(type)) {
+		/* guess flags based on sequence values */
+		if (buf->sequence >= opener->read_position) {
+			set_done(buf->flags);
+		} else if (buf->flags & V4L2_BUF_FLAG_DONE) {
+			set_queued(buf->flags);
+		}
+	}
+	dprintkrw("QUERYBUF(%s, index=%u) -> " BUFFER_DEBUG_FMT_STR,
+		  V4L2_TYPE_IS_CAPTURE(type) ? "CAPTURE" : "OUTPUT", index,
+		  BUFFER_DEBUG_FMT_ARGS(buf));
 	return 0;
 }
 
@@ -1690,7 +1796,8 @@ static void buffer_written(struct v4l2_loopback_device *dev,
 	spin_unlock_bh(&dev->list_lock);
 
 	spin_lock_bh(&dev->lock);
-	dev->bufpos2index[v4l2l_mod64(dev->write_position, dev->used_buffers)] =
+	dev->bufpos2index[v4l2l_mod64(dev->write_position,
+				      dev->used_buffer_count)] =
 		buf->buffer.index;
 	++dev->write_position;
 	dev->reread_count = 0;
@@ -1704,49 +1811,53 @@ static void buffer_written(struct v4l2_loopback_device *dev,
  */
 static int vidioc_qbuf(struct file *file, void *fh, struct v4l2_buffer *buf)
 {
-	struct v4l2_loopback_device *dev;
-	struct v4l2_loopback_opener *opener;
-	struct v4l2l_buffer *b;
-	int index;
+	struct v4l2_loopback_device *dev = v4l2loopback_getdevice(file);
+	struct v4l2_loopback_opener *opener = fh_to_opener(fh);
+	struct v4l2l_buffer *bufd;
+	u32 index = buf->index;
+	u32 type = buf->type;
 
-	dev = v4l2loopback_getdevice(file);
-	opener = fh_to_opener(fh);
+	if (!is_allocated(opener, type, index))
+		return -EINVAL;
+	bufd = &dev->buffers[index];
 
-	if (buf->index > max_buffers)
+	switch (buf->memory) {
+	case V4L2_MEMORY_MMAP:
+		if (!(bufd->buffer.flags & V4L2_BUF_FLAG_MAPPED))
+			dprintkrw("QBUF() unmapped buffer [index=%u]\n", index);
+		break;
+	default:
 		return -EINVAL;
-	if (opener->timeout_image_io)
-		return 0;
+	}
 
-	index = buf->index % dev->used_buffers;
-	b = &dev->buffers[index];
+	if (opener->format_token & V4L2L_TOKEN_TIMEOUT) {
+		set_queued(buf->flags);
+		return 0;
+	}
 
-	switch (buf->type) {
+	switch (type) {
 	case V4L2_BUF_TYPE_VIDEO_CAPTURE:
-		dprintkrw(
-			"qbuf(CAPTURE)#%d: buffer#%d @ %p type=%d bytesused=%d length=%d flags=%x field=%d timestamp=%lld.%06ld sequence=%d\n",
-			index, buf->index, buf, buf->type, buf->bytesused,
-			buf->length, buf->flags, buf->field,
-			(long long)buf->timestamp.tv_sec,
-			(long int)buf->timestamp.tv_usec, buf->sequence);
-		set_queued(b);
-		return 0;
+		dprintkrw("QBUF(CAPTURE, index=%u) -> " BUFFER_DEBUG_FMT_STR,
+			  index, BUFFER_DEBUG_FMT_ARGS(buf));
+		set_queued(buf->flags);
+		break;
 	case V4L2_BUF_TYPE_VIDEO_OUTPUT:
-		dprintkrw(
-			"qbuf(OUTPUT)#%d: buffer#%d @ %p type=%d bytesused=%d length=%d flags=%x field=%d timestamp=%lld.%06ld sequence=%d\n",
-			index, buf->index, buf, buf->type, buf->bytesused,
-			buf->length, buf->flags, buf->field,
-			(long long)buf->timestamp.tv_sec,
-			(long int)buf->timestamp.tv_usec, buf->sequence);
-		if ((!(b->buffer.flags & V4L2_BUF_FLAG_TIMESTAMP_COPY)) &&
-		    (buf->timestamp.tv_sec == 0 && buf->timestamp.tv_usec == 0))
-			v4l2l_get_timestamp(&b->buffer);
-		else {
-			b->buffer.timestamp = buf->timestamp;
-			b->buffer.flags |= V4L2_BUF_FLAG_TIMESTAMP_COPY;
+		dprintkrw("QBUF(OUTPUT, index=%u) -> " BUFFER_DEBUG_FMT_STR,
+			  index, BUFFER_DEBUG_FMT_ARGS(buf));
+		if (!(bufd->buffer.flags & V4L2_BUF_FLAG_TIMESTAMP_COPY) &&
+		    (buf->timestamp.tv_sec == 0 &&
+		     buf->timestamp.tv_usec == 0)) {
+			v4l2l_get_timestamp(&bufd->buffer);
+		} else {
+			bufd->buffer.timestamp = buf->timestamp;
+			bufd->buffer.flags |= V4L2_BUF_FLAG_TIMESTAMP_COPY;
+			bufd->buffer.flags &=
+				~V4L2_BUF_FLAG_TIMESTAMP_MONOTONIC;
 		}
 		if (dev->pix_format_has_valid_sizeimage) {
 			if (buf->bytesused >= dev->pix_format.sizeimage) {
-				b->buffer.bytesused = dev->pix_format.sizeimage;
+				bufd->buffer.bytesused =
+					dev->pix_format.sizeimage;
 			} else {
 #if LINUX_VERSION_CODE >= KERNEL_VERSION(3, 5, 0)
 				dev_warn_ratelimited(
@@ -1754,28 +1865,26 @@ static int vidioc_qbuf(struct file *file, void *fh, struct v4l2_buffer *buf)
 #else
 				dprintkrw(
 #endif
-					"warning queued output buffer bytesused too small %d < %d\n",
+					"warning queued output buffer bytesused too small %u < %u\n",
 					buf->bytesused,
 					dev->pix_format.sizeimage);
-				b->buffer.bytesused = buf->bytesused;
+				bufd->buffer.bytesused = buf->bytesused;
 			}
 		} else {
-			b->buffer.bytesused = buf->bytesused;
+			bufd->buffer.bytesused = buf->bytesused;
 		}
-
-		set_done(b);
-		buffer_written(dev, b);
-
-		/*  Hopefully fix 'DQBUF return bad index if queue bigger then 2 for capture'
-                    https://github.com/umlaeute/v4l2loopback/issues/60 */
-		buf->flags &= ~V4L2_BUF_FLAG_DONE;
-		buf->flags |= V4L2_BUF_FLAG_QUEUED;
-
+		bufd->buffer.sequence = dev->write_position;
+		set_queued(bufd->buffer.flags);
+		*buf = bufd->buffer;
+		buffer_written(dev, bufd);
+		set_done(bufd->buffer.flags);
 		wake_up_all(&dev->read_event);
-		return 0;
+		break;
 	default:
 		return -EINVAL;
 	}
+	buf->type = type;
+	return 0;
 }
 
 static int can_read(struct v4l2_loopback_device *dev,
@@ -1795,8 +1904,8 @@ static int get_capture_buffer(struct file *file)
 {
 	struct v4l2_loopback_device *dev = v4l2loopback_getdevice(file);
 	struct v4l2_loopback_opener *opener = fh_to_opener(file->private_data);
-	int pos, ret;
-	int timeout_happened;
+	int pos, timeout_happened;
+	u32 index;
 
 	if ((file->f_flags & O_NONBLOCK) &&
 	    (dev->write_position <= opener->read_position &&
@@ -1810,33 +1919,37 @@ static int get_capture_buffer(struct file *file)
 		if (dev->reread_count > opener->reread_count + 2)
 			opener->reread_count = dev->reread_count - 1;
 		++opener->reread_count;
-		pos = v4l2l_mod64(opener->read_position + dev->used_buffers - 1,
-				  dev->used_buffers);
+		pos = v4l2l_mod64(opener->read_position +
+					  dev->used_buffer_count - 1,
+				  dev->used_buffer_count);
 	} else {
 		opener->reread_count = 0;
 		if (dev->write_position >
-		    opener->read_position + dev->used_buffers)
+		    opener->read_position + dev->used_buffer_count)
 			opener->read_position = dev->write_position - 1;
-		pos = v4l2l_mod64(opener->read_position, dev->used_buffers);
+		pos = v4l2l_mod64(opener->read_position,
+				  dev->used_buffer_count);
 		++opener->read_position;
 	}
-	timeout_happened = dev->timeout_happened;
+	timeout_happened = dev->timeout_happened && (dev->timeout_jiffies > 0);
 	dev->timeout_happened = 0;
 	spin_unlock_bh(&dev->lock);
 
-	ret = dev->bufpos2index[pos];
+	index = dev->bufpos2index[pos];
 	if (timeout_happened) {
-		if (ret < 0) {
-			dprintk("trying to return not mapped buf[%d]\n", ret);
+		if (index >= dev->used_buffer_count) {
+			dprintkrw("get_capture_buffer() read position is at "
+				  "an unallocated buffer [index=%u]\n",
+				  index);
 			return -EFAULT;
 		}
 		/* although allocated on-demand, timeout_image is freed only
 		 * in free_buffers(), so we don't need to worry about it being
 		 * deallocated suddenly */
-		memcpy(dev->image + dev->buffers[ret].buffer.m.offset,
+		memcpy(dev->image + dev->buffers[index].buffer.m.offset,
 		       dev->timeout_image, dev->buffer_size);
 	}
-	return ret;
+	return (int)index;
 }
 
 /* put buffer to dequeue
@@ -1844,61 +1957,55 @@ static int get_capture_buffer(struct file *file)
  */
 static int vidioc_dqbuf(struct file *file, void *fh, struct v4l2_buffer *buf)
 {
-	struct v4l2_loopback_device *dev;
-	struct v4l2_loopback_opener *opener;
+	struct v4l2_loopback_device *dev = v4l2loopback_getdevice(file);
+	struct v4l2_loopback_opener *opener = fh_to_opener(fh);
+	u32 type = buf->type;
 	int index;
-	struct v4l2l_buffer *b;
+	struct v4l2l_buffer *bufd;
 
-	dev = v4l2loopback_getdevice(file);
-	opener = fh_to_opener(fh);
-	if (opener->timeout_image_io) {
-		*buf = dev->timeout_image_buffer.buffer;
+	if (buf->memory != V4L2_MEMORY_MMAP)
+		return -EINVAL;
+	if (opener->format_token & V4L2L_TOKEN_TIMEOUT) {
+		*buf = dev->timeout_buffer.buffer;
+		buf->type = type;
+		unset_flags(buf->flags);
 		return 0;
 	}
+	if ((opener->buffer_count == 0) ||
+	    !(opener->format_token & token_from_type(type)))
+		return -EINVAL;
 
-	switch (buf->type) {
+	switch (type) {
 	case V4L2_BUF_TYPE_VIDEO_CAPTURE:
 		index = get_capture_buffer(file);
 		if (index < 0)
 			return index;
-		dprintkrw("capture DQBUF pos: %lld index: %d\n",
-			  (long long)(opener->read_position - 1), index);
-		if (!(dev->buffers[index].buffer.flags &
-		      V4L2_BUF_FLAG_MAPPED)) {
-			dprintk("trying to return not mapped buf[%d]\n", index);
-			return -EINVAL;
-		}
-		unset_flags(&dev->buffers[index]);
 		*buf = dev->buffers[index].buffer;
-		dprintkrw(
-			"dqbuf(CAPTURE)#%d: buffer#%d @ %p type=%d bytesused=%d length=%d flags=%x field=%d timestamp=%lld.%06ld sequence=%d\n",
-			index, buf->index, buf, buf->type, buf->bytesused,
-			buf->length, buf->flags, buf->field,
-			(long long)buf->timestamp.tv_sec,
-			(long int)buf->timestamp.tv_usec, buf->sequence);
-		return 0;
+		unset_flags(buf->flags);
+		break;
 	case V4L2_BUF_TYPE_VIDEO_OUTPUT:
 		spin_lock_bh(&dev->list_lock);
 
-		b = list_entry(dev->outbufs_list.prev, struct v4l2l_buffer,
-			       list_head);
-		list_move_tail(&b->list_head, &dev->outbufs_list);
+		bufd = list_first_entry_or_null(&dev->outbufs_list,
+						struct v4l2l_buffer, list_head);
+		if (bufd)
+			list_move_tail(&bufd->list_head, &dev->outbufs_list);
 
 		spin_unlock_bh(&dev->list_lock);
-		dprintkrw("output DQBUF index: %d\n", b->buffer.index);
-		unset_flags(b);
-		*buf = b->buffer;
-		buf->type = V4L2_BUF_TYPE_VIDEO_OUTPUT;
-		dprintkrw(
-			"dqbuf(OUTPUT)#%d: buffer#%d @ %p type=%d bytesused=%d length=%d flags=%x field=%d timestamp=%lld.%06ld sequence=%d\n",
-			index, buf->index, buf, buf->type, buf->bytesused,
-			buf->length, buf->flags, buf->field,
-			(long long)buf->timestamp.tv_sec,
-			(long int)buf->timestamp.tv_usec, buf->sequence);
-		return 0;
+		if (!bufd)
+			return -EFAULT;
+		unset_flags(bufd->buffer.flags);
+		*buf = bufd->buffer;
+		break;
 	default:
 		return -EINVAL;
 	}
+
+	buf->type = type;
+	dprintkrw("DQBUF(%s, index=%u) -> " BUFFER_DEBUG_FMT_STR,
+		  V4L2_TYPE_IS_CAPTURE(type) ? "CAPTURE" : "OUTPUT", index,
+		  BUFFER_DEBUG_FMT_ARGS(buf));
+	return 0;
 }
 
 /* ------------- STREAMING ------------------- */
@@ -1908,37 +2015,33 @@ static int vidioc_dqbuf(struct file *file, void *fh, struct v4l2_buffer *buf)
  */
 static int vidioc_streamon(struct file *file, void *fh, enum v4l2_buf_type type)
 {
-	struct v4l2_loopback_device *dev;
-	struct v4l2_loopback_opener *opener;
-	MARK();
+	struct v4l2_loopback_device *dev = v4l2loopback_getdevice(file);
+	struct v4l2_loopback_opener *opener = fh_to_opener(fh);
+	u32 token = token_from_type(type);
 
-	dev = v4l2loopback_getdevice(file);
-	opener = fh_to_opener(fh);
+	/* short-circuit when using timeout buffer set */
+	if (opener->format_token & V4L2L_TOKEN_TIMEOUT)
+		return 0;
+	/* opener must have claimed (same) buffer set via REQBUFS */
+	if (!opener->buffer_count || !(opener->format_token & token))
+		return -EINVAL;
 
 	switch (type) {
-	case V4L2_BUF_TYPE_VIDEO_OUTPUT:
-		if (!dev->ready_for_capture) {
-			int ret = allocate_buffers(dev);
-			if (ret < 0)
-				return ret;
-		}
-		opener->type = WRITER;
-		dev->ready_for_output = 0;
-		dev->ready_for_capture++;
-		return 0;
 	case V4L2_BUF_TYPE_VIDEO_CAPTURE:
-		if (!dev->ready_for_capture)
+		if (has_output_token(dev->stream_tokens) && !dev->keep_format)
 			return -EIO;
-		if (dev->active_readers > 0)
-			return -EBUSY;
-		opener->type = READER;
-		dev->active_readers++;
-		client_usage_queue_event(dev->vdev);
+		if (dev->stream_tokens & token) {
+			acquire_token(dev, opener, stream, token);
+			client_usage_queue_event(dev->vdev);
+		}
+		return 0;
+	case V4L2_BUF_TYPE_VIDEO_OUTPUT:
+		if (dev->stream_tokens & token)
+			acquire_token(dev, opener, stream, token);
 		return 0;
 	default:
 		return -EINVAL;
 	}
-	return -EINVAL;
 }
 
 /* stop streaming
@@ -1947,30 +2050,39 @@ static int vidioc_streamon(struct file *file, void *fh, enum v4l2_buf_type type)
 static int vidioc_streamoff(struct file *file, void *fh,
 			    enum v4l2_buf_type type)
 {
-	struct v4l2_loopback_device *dev;
-	struct v4l2_loopback_opener *opener;
+	struct v4l2_loopback_device *dev = v4l2loopback_getdevice(file);
+	struct v4l2_loopback_opener *opener = fh_to_opener(fh);
+	u32 token = token_from_type(type);
 
-	MARK();
-	dprintk("%d\n", type);
+	/* short-circuit when using timeout buffer set */
+	if (opener->format_token & V4L2L_TOKEN_TIMEOUT)
+		return 0;
+	/* short-circuit when buffer set has no owner */
+	if (dev->format_tokens & token)
+		return 0;
+	/* opener needs a claim to buffer set */
+	if (!opener->format_token)
+		return -EBUSY;
+	if (opener->format_token & ~token)
+		return -EINVAL;
 
-	dev = v4l2loopback_getdevice(file);
-	opener = fh_to_opener(fh);
 	switch (type) {
 	case V4L2_BUF_TYPE_VIDEO_OUTPUT:
-		if (dev->ready_for_capture > 0)
-			dev->ready_for_capture--;
+		if (opener->stream_token & token)
+			release_token(dev, opener, stream);
+		/* reset output queue */
+		if (dev->used_buffer_count > 0)
+			prepare_buffer_queue(dev, dev->used_buffer_count);
 		return 0;
 	case V4L2_BUF_TYPE_VIDEO_CAPTURE:
-		if (opener->type == READER) {
-			opener->type = 0;
-			dev->active_readers--;
+		if (opener->stream_token & token) {
+			release_token(dev, opener, stream);
 			client_usage_queue_event(dev->vdev);
 		}
 		return 0;
 	default:
 		return -EINVAL;
 	}
-	return -EINVAL;
 }
 
 #ifdef CONFIG_VIDEO_V4L1_COMPAT
@@ -1980,7 +2092,7 @@ static int vidiocgmbuf(struct file *file, void *fh, struct video_mbuf *p)
 	MARK();
 
 	dev = v4l2loopback_getdevice(file);
-	p->frames = dev->buffers_number;
+	p->frames = dev->buffer_count;
 	p->offsets[0] = 0;
 	p->offsets[1] = 0;
 	p->size = dev->buffer_size;
@@ -1998,7 +2110,8 @@ static void client_usage_queue_event(struct video_device *vdev)
 
 	memset(&ev, 0, sizeof(ev));
 	ev.type = V4L2_EVENT_PRI_CLIENT_USAGE;
-	((struct v4l2_event_client_usage *)&ev.u)->count = dev->active_readers;
+	((struct v4l2_event_client_usage *)&ev.u)->count =
+		!has_capture_token(dev->stream_tokens);
 
 	v4l2_event_queue(vdev, &ev);
 }
@@ -2078,66 +2191,77 @@ static struct vm_operations_struct vm_ops = {
 static int v4l2_loopback_mmap(struct file *file, struct vm_area_struct *vma)
 {
 	u8 *addr;
-	unsigned long start;
-	unsigned long size;
-	struct v4l2_loopback_device *dev;
-	struct v4l2_loopback_opener *opener;
+	unsigned long start, size;
+	struct v4l2_loopback_device *dev = v4l2loopback_getdevice(file);
+	struct v4l2_loopback_opener *opener = fh_to_opener(file->private_data);
 	struct v4l2l_buffer *buffer = NULL;
+	int result = 0;
 	MARK();
 
 	start = (unsigned long)vma->vm_start;
 	size = (unsigned long)(vma->vm_end - vma->vm_start);
 
-	dev = v4l2loopback_getdevice(file);
-	opener = fh_to_opener(file->private_data);
+	/* ensure buffer size, number, and allocated image are not altered by
+	 * other file descriptors */
+	result = mutex_lock_killable(&dev->image_mutex);
+	if (result < 0)
+		return result;
 
 	if (size > dev->buffer_size) {
-		dprintk("userspace tries to mmap too much, fail\n");
-		return -EINVAL;
+		dprintk("mmap() attempt to map more than allocated to "
+			"buffer\n");
+		result = -EINVAL;
+		goto exit_mmap_unlock;
 	}
-	if (opener->timeout_image_io) {
-		/* we are going to map the timeout_image_buffer */
+	if (opener->format_token & V4L2L_TOKEN_TIMEOUT) {
+		/* we are going to map the timeout_buffer */
 		if ((vma->vm_pgoff << PAGE_SHIFT) !=
-		    dev->buffer_size * MAX_BUFFERS) {
-			dprintk("invalid mmap offset for timeout_image_io mode\n");
-			return -EINVAL;
+		    (unsigned long)dev->buffer_size * MAX_BUFFERS) {
+			dprintk("mmap() invalid offset for timeout image\n");
+			result = -EINVAL;
 		}
-	} else if ((vma->vm_pgoff << PAGE_SHIFT) >
-		   dev->buffer_size * (dev->buffers_number - 1)) {
-		dprintk("userspace tries to mmap too far, fail\n");
-		return -EINVAL;
+	} else if (!dev->buffer_count ||
+		   (vma->vm_pgoff << PAGE_SHIFT) >
+			   (unsigned long)dev->buffer_size *
+				   (dev->buffer_count - 1u)) {
+		dprintk("mmap() attempt to map outside of buffers\n");
+		result = -EINVAL;
+	}
+	if (!result && !dev->image) {
+		dprintk("mmap() attempt to map when buffers are unallocated\n");
+		result = -EINVAL;
 	}
 
-	/* FIXXXXXME: allocation should not happen here! */
-	if (NULL == dev->image)
-		if (allocate_buffers(dev) < 0)
-			return -EINVAL;
+	if (result < 0)
+		goto exit_mmap_unlock;
 
-	if (opener->timeout_image_io) {
-		buffer = &dev->timeout_image_buffer;
+	if (opener->format_token & V4L2L_TOKEN_TIMEOUT) {
+		buffer = &dev->timeout_buffer;
 		addr = dev->timeout_image;
 	} else {
-		int i;
-		for (i = 0; i < dev->buffers_number; ++i) {
+		u32 i;
+		for (i = 0; i < dev->buffer_count; ++i) {
 			buffer = &dev->buffers[i];
 			if ((buffer->buffer.m.offset >> PAGE_SHIFT) ==
 			    vma->vm_pgoff)
 				break;
 		}
 
-		if (i >= dev->buffers_number)
-			return -EINVAL;
+		if (i >= dev->buffer_count) {
+			result = -EINVAL;
+			goto exit_mmap_unlock;
+		}
 
 		addr = dev->image + (vma->vm_pgoff << PAGE_SHIFT);
 	}
 
 	while (size > 0) {
-		struct page *page;
-
-		page = vmalloc_to_page(addr);
+		struct page *page = vmalloc_to_page(addr);
 
-		if (vm_insert_page(vma, start, page) < 0)
-			return -EAGAIN;
+		if (vm_insert_page(vma, start, page) < 0) {
+			result = -EAGAIN;
+			goto exit_mmap_unlock;
+		}
 
 		start += PAGE_SIZE;
 		addr += PAGE_SIZE;
@@ -2148,26 +2272,25 @@ static int v4l2_loopback_mmap(struct file *file, struct vm_area_struct *vma)
 	vma->vm_private_data = buffer;
 
 	vm_open(vma);
-
-	MARK();
-	return 0;
+exit_mmap_unlock:
+	mutex_unlock(&dev->image_mutex);
+	return result;
 }
 
 static unsigned int v4l2_loopback_poll(struct file *file,
 				       struct poll_table_struct *pts)
 {
-	struct v4l2_loopback_opener *opener;
-	struct v4l2_loopback_device *dev;
+	struct v4l2_loopback_device *dev = v4l2loopback_getdevice(file);
+	struct v4l2_loopback_opener *opener = fh_to_opener(file->private_data);
 	__poll_t req_events = poll_requested_events(pts);
 	int ret_mask = 0;
-	MARK();
 
-	opener = fh_to_opener(file->private_data);
-	dev = v4l2loopback_getdevice(file);
+	/* call poll_wait in first call, regardless, to ensure that the
+	 * wait-queue is not null */
+	poll_wait(file, &dev->read_event, pts);
+	poll_wait(file, &opener->fh.wait, pts);
 
 	if (req_events & POLLPRI) {
-		if (!v4l2_event_pending(&opener->fh))
-			poll_wait(file, &opener->fh.wait, pts);
 		if (v4l2_event_pending(&opener->fh)) {
 			ret_mask |= POLLPRI;
 			if (!(req_events & DEFAULT_POLLMASK))
@@ -2175,26 +2298,25 @@ static unsigned int v4l2_loopback_poll(struct file *file,
 		}
 	}
 
-	switch (opener->type) {
-	case WRITER:
-		ret_mask |= POLLOUT | POLLWRNORM;
+	switch (opener->format_token) {
+	case V4L2L_TOKEN_OUTPUT:
+		if (opener->stream_token != 0 ||
+		    opener->io_method == V4L2L_IO_NONE)
+			ret_mask |= POLLOUT | POLLWRNORM;
 		break;
-	case READER:
-		if (!can_read(dev, opener)) {
-			if (ret_mask)
-				return ret_mask;
-			poll_wait(file, &dev->read_event, pts);
-		}
-		if (can_read(dev, opener))
-			ret_mask |= POLLIN | POLLRDNORM;
-		if (v4l2_event_pending(&opener->fh))
-			ret_mask |= POLLPRI;
+	case V4L2L_TOKEN_CAPTURE:
+		if ((opener->io_method == V4L2L_IO_NONE ||
+		     opener->stream_token != 0) &&
+		    can_read(dev, opener))
+			ret_mask |= POLLIN | POLLWRNORM;
+		break;
+	case V4L2L_TOKEN_TIMEOUT:
+		ret_mask |= POLLOUT | POLLWRNORM;
 		break;
 	default:
 		break;
 	}
 
-	MARK();
 	return ret_mask;
 }
 
@@ -2204,7 +2326,7 @@ static int v4l2_loopback_open(struct file *file)
 {
 	struct v4l2_loopback_device *dev;
 	struct v4l2_loopback_opener *opener;
-	MARK();
+
 	dev = v4l2loopback_getdevice(file);
 	if (dev->open_count.counter >= dev->max_openers)
 		return -EBUSY;
@@ -2214,254 +2336,282 @@ static int v4l2_loopback_open(struct file *file)
 		return -ENOMEM;
 
 	atomic_inc(&dev->open_count);
-
-	opener->timeout_image_io = dev->timeout_image_io;
-	if (opener->timeout_image_io) {
-		int r = allocate_timeout_image(dev);
-
-		if (r < 0) {
-			dprintk("timeout image allocation failed\n");
-
-			atomic_dec(&dev->open_count);
-
-			kfree(opener);
-			return r;
-		}
-	}
+	if (dev->timeout_image_io && dev->format_tokens & V4L2L_TOKEN_TIMEOUT)
+		/* will clear timeout_image_io once buffer set acquired */
+		opener->io_method = V4L2L_IO_TIMEOUT;
 
 	v4l2_fh_init(&opener->fh, video_devdata(file));
 	file->private_data = &opener->fh;
 
 	v4l2_fh_add(&opener->fh);
-	dprintk("opened dev:%p with image:%p\n", dev, dev ? dev->image : NULL);
-	MARK();
+	dprintk("open() -> dev@%p with image@%p\n", dev,
+		dev ? dev->image : NULL);
 	return 0;
 }
 
 static int v4l2_loopback_close(struct file *file)
 {
-	struct v4l2_loopback_opener *opener;
-	struct v4l2_loopback_device *dev;
-	int is_writer = 0, is_reader = 0;
-	MARK();
-
-	opener = fh_to_opener(file->private_data);
-	dev = v4l2loopback_getdevice(file);
-
-	if (WRITER == opener->type)
-		is_writer = 1;
-	if (READER == opener->type)
-		is_reader = 1;
+	struct v4l2_loopback_device *dev = v4l2loopback_getdevice(file);
+	struct v4l2_loopback_opener *opener = fh_to_opener(file->private_data);
+	int result = 0;
+	dprintk("close() -> dev@%p with image@%p\n", dev,
+		dev ? dev->image : NULL);
 
-	atomic_dec(&dev->open_count);
-	if (dev->open_count.counter == 0) {
+	if (opener->format_token) {
+		struct v4l2_requestbuffers reqbuf = {
+			.count = 0, .memory = V4L2_MEMORY_MMAP, .type = 0
+		};
+		switch (opener->format_token) {
+		case V4L2L_TOKEN_CAPTURE:
+			reqbuf.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
+			break;
+		case V4L2L_TOKEN_OUTPUT:
+		case V4L2L_TOKEN_TIMEOUT:
+			reqbuf.type = V4L2_BUF_TYPE_VIDEO_OUTPUT;
+			break;
+		}
+		if (reqbuf.type)
+			result = vidioc_reqbufs(file, file->private_data,
+						&reqbuf);
+		if (result < 0)
+			dprintk("failed to free buffers REQBUFS(count=0) "
+				" returned %d\n",
+				result);
+		mutex_lock(&dev->image_mutex);
+		release_token(dev, opener, format);
+		mutex_unlock(&dev->image_mutex);
+	}
+
+	if (atomic_dec_and_test(&dev->open_count)) {
 		del_timer_sync(&dev->sustain_timer);
 		del_timer_sync(&dev->timeout_timer);
+		if (!dev->keep_format) {
+			mutex_lock(&dev->image_mutex);
+			free_buffers(dev);
+			mutex_unlock(&dev->image_mutex);
+		}
 	}
-	try_free_buffers(dev);
 
 	v4l2_fh_del(&opener->fh);
 	v4l2_fh_exit(&opener->fh);
 
 	kfree(opener);
-	if (is_writer)
-		dev->ready_for_output = 1;
-	if (is_reader) {
-		dev->active_readers--;
-		client_usage_queue_event(dev->vdev);
-	}
-	MARK();
+	return 0;
+}
+
+static int start_fileio(struct file *file, void *fh, enum v4l2_buf_type type)
+{
+	struct v4l2_loopback_device *dev = v4l2loopback_getdevice(file);
+	struct v4l2_loopback_opener *opener = fh_to_opener(fh);
+	struct v4l2_requestbuffers reqbuf = { .count = dev->buffer_count,
+					      .memory = V4L2_MEMORY_MMAP,
+					      .type = type };
+	int token = token_from_type(type);
+	int result;
+
+	if (opener->format_token & V4L2L_TOKEN_TIMEOUT ||
+	    opener->format_token & ~token)
+		return -EBUSY; /* NOTE: -EBADF might be more informative */
+
+	/* short-circuit if already have stream token */
+	if (opener->stream_token && opener->io_method == V4L2L_IO_FILE)
+		return 0;
+
+	/* otherwise attempt to acquire stream token and assign IO method */
+	if (!(dev->stream_tokens & token) || opener->io_method != V4L2L_IO_NONE)
+		return -EBUSY;
+
+	result = vidioc_reqbufs(file, fh, &reqbuf);
+	if (result < 0)
+		return result;
+	result = vidioc_streamon(file, fh, type);
+	if (result < 0)
+		return result;
+
+	opener->io_method = V4L2L_IO_FILE;
 	return 0;
 }
 
 static ssize_t v4l2_loopback_read(struct file *file, char __user *buf,
 				  size_t count, loff_t *ppos)
 {
-	int read_index;
-	struct v4l2_loopback_device *dev;
+	struct v4l2_loopback_device *dev = v4l2loopback_getdevice(file);
 	struct v4l2_buffer *b;
-	MARK();
+	int index, result;
 
-	dev = v4l2loopback_getdevice(file);
+	dprintkrw("read() %zu bytes\n", count);
+	result = start_fileio(file, file->private_data,
+			      V4L2_BUF_TYPE_VIDEO_CAPTURE);
+	if (result < 0)
+		return result;
 
-	read_index = get_capture_buffer(file);
-	if (read_index < 0)
-		return read_index;
-	if (count > dev->buffer_size)
-		count = dev->buffer_size;
-	b = &dev->buffers[read_index].buffer;
+	index = get_capture_buffer(file);
+	if (index < 0)
+		return index;
+	b = &dev->buffers[index].buffer;
 	if (count > b->bytesused)
 		count = b->bytesused;
 	if (copy_to_user((void *)buf, (void *)(dev->image + b->m.offset),
 			 count)) {
-		printk(KERN_ERR
-		       "v4l2-loopback: failed copy_to_user() in read buf\n");
+		printk(KERN_ERR "v4l2-loopback read() failed copy_to_user()\n");
 		return -EFAULT;
 	}
-	dprintkrw("leave v4l2_loopback_read()\n");
 	return count;
 }
 
 static ssize_t v4l2_loopback_write(struct file *file, const char __user *buf,
 				   size_t count, loff_t *ppos)
 {
-	struct v4l2_loopback_opener *opener;
-	struct v4l2_loopback_device *dev;
-	int write_index;
+	struct v4l2_loopback_device *dev = v4l2loopback_getdevice(file);
 	struct v4l2_buffer *b;
-	int err = 0;
-
-	MARK();
-
-	dev = v4l2loopback_getdevice(file);
-	opener = fh_to_opener(file->private_data);
-
-	if (UNNEGOTIATED == opener->type) {
-		spin_lock(&dev->lock);
-
-		if (dev->ready_for_output) {
-			err = vidioc_streamon(file, file->private_data,
-					      V4L2_BUF_TYPE_VIDEO_OUTPUT);
-		}
-
-		spin_unlock(&dev->lock);
-
-		if (err < 0)
-			return err;
-	}
+	int index, result;
 
-	if (WRITER != opener->type)
-		return -EINVAL;
+	dprintkrw("write() %zu bytes\n", count);
+	result = start_fileio(file, file->private_data,
+			      V4L2_BUF_TYPE_VIDEO_OUTPUT);
+	if (result < 0)
+		return result;
 
-	if (!dev->ready_for_capture) {
-		int ret = allocate_buffers(dev);
-		if (ret < 0)
-			return ret;
-		dev->ready_for_capture = 1;
-	}
-	dprintkrw("v4l2_loopback_write() trying to write %zu bytes\n", count);
 	if (count > dev->buffer_size)
 		count = dev->buffer_size;
-
-	write_index = v4l2l_mod64(dev->write_position, dev->used_buffers);
-	b = &dev->buffers[write_index].buffer;
+	index = v4l2l_mod64(dev->write_position, dev->used_buffer_count);
+	b = &dev->buffers[index].buffer;
 
 	if (copy_from_user((void *)(dev->image + b->m.offset), (void *)buf,
 			   count)) {
 		printk(KERN_ERR
-		       "v4l2-loopback: failed copy_from_user() in write buf, could not write %zu\n",
-		       count);
+		       "v4l2-loopback write() failed copy_from_user()\n");
 		return -EFAULT;
 	}
-	v4l2l_get_timestamp(b);
 	b->bytesused = count;
+
+	v4l2l_get_timestamp(b);
 	b->sequence = dev->write_position;
-	buffer_written(dev, &dev->buffers[write_index]);
+	set_queued(b->flags);
+	buffer_written(dev, &dev->buffers[index]);
+	set_done(b->flags);
 	wake_up_all(&dev->read_event);
-	dprintkrw("leave v4l2_loopback_write()\n");
+
 	return count;
 }
 
 /* init functions */
-/* frees buffers, if already allocated */
+/* frees buffers, if allocated */
 static void free_buffers(struct v4l2_loopback_device *dev)
 {
-	MARK();
-	dprintk("freeing image@%p for dev:%p\n", dev ? dev->image : NULL, dev);
-	if (!dev)
+	dprintk("free_buffers() with image@%p\n", dev->image);
+	if (!dev->image)
 		return;
-	if (dev->image) {
-		vfree(dev->image);
-		dev->image = NULL;
-	}
-	if (dev->timeout_image) {
-		vfree(dev->timeout_image);
-		dev->timeout_image = NULL;
-	}
-	dev->imagesize = 0;
+	if (!has_no_owners(dev) || any_buffers_mapped(dev))
+		/* maybe an opener snuck in before image_mutex was acquired */
+		printk(KERN_WARNING
+		       "v4l2-loopback free_buffers() buffers of video device "
+		       "#%u freed while still mapped to userspace\n",
+		       dev->vdev->num);
+	vfree(dev->image);
+	dev->image = NULL;
+	dev->image_size = 0;
+	dev->buffer_size = 0;
 }
-/* frees buffers, if they are no longer needed */
-static void try_free_buffers(struct v4l2_loopback_device *dev)
+
+static void free_timeout_buffer(struct v4l2_loopback_device *dev)
 {
-	MARK();
-	if (0 == dev->open_count.counter && !dev->keep_format) {
-		free_buffers(dev);
-		dev->ready_for_capture = 0;
-		dev->buffer_size = 0;
-		dev->write_position = 0;
-	}
+	dprintk("free_timeout_buffer() with timeout_image@%p\n",
+		dev->timeout_image);
+	if (!dev->timeout_image)
+		return;
+
+	if ((dev->timeout_jiffies > 0 && !has_no_owners(dev)) ||
+	    dev->timeout_buffer.buffer.flags & V4L2_BUF_FLAG_MAPPED)
+		printk(KERN_WARNING
+		       "v4l2-loopback free_timeout_buffer() timeout image "
+		       "of device #%u freed while still mapped to userspace\n",
+		       dev->vdev->num);
+
+	vfree(dev->timeout_image);
+	dev->timeout_image = NULL;
+	dev->timeout_buffer_size = 0;
 }
-/* allocates buffers, if buffer_size is set */
-static int allocate_buffers(struct v4l2_loopback_device *dev)
+/* allocates buffers if no (other) openers are already using them */
+static int allocate_buffers(struct v4l2_loopback_device *dev,
+			    struct v4l2_pix_format *pix_format)
 {
-	int err;
-
-	MARK();
+	u32 buffer_size = PAGE_ALIGN(pix_format->sizeimage);
+	unsigned long image_size =
+		(unsigned long)buffer_size * (unsigned long)dev->buffer_count;
 	/* vfree on close file operation in case no open handles left */
 
-	if (dev->buffer_size < 1 || dev->buffers_number < 1)
+	if (buffer_size == 0 || dev->buffer_count == 0 ||
+	    buffer_size < pix_format->sizeimage)
 		return -EINVAL;
 
-	if ((__LONG_MAX__ / dev->buffer_size) < dev->buffers_number)
+	if ((__LONG_MAX__ / buffer_size) < dev->buffer_count)
 		return -ENOSPC;
 
+	dprintk("allocate_buffers() size %lubytes = %ubytes x %ubuffers\n",
+		image_size, buffer_size, dev->buffer_count);
 	if (dev->image) {
-		dprintk("allocating buffers again: %ld %ld\n",
-			dev->buffer_size * dev->buffers_number, dev->imagesize);
+		/* check that no buffers are expected in user-space */
+		if (!has_no_owners(dev) || any_buffers_mapped(dev))
+			return -EBUSY;
+		dprintk("allocate_buffers() existing size=%lubytes\n",
+			dev->image_size);
 		/* FIXME: prevent double allocation more intelligently! */
-		if (dev->buffer_size * dev->buffers_number == dev->imagesize)
+		if (image_size == dev->image_size) {
+			dprintk("allocate_buffers() keep existing\n");
 			return 0;
-
-		/* check whether the total number of readers/writers is <=1 */
-		if ((dev->ready_for_capture + dev->active_readers) <= 1)
-			free_buffers(dev);
-		else
-			return -EINVAL;
+		}
+		free_buffers(dev);
 	}
 
-	dev->imagesize = (unsigned long)dev->buffer_size *
-			 (unsigned long)dev->buffers_number;
-
-	dprintk("allocating %ld = %ldx%d\n", dev->imagesize, dev->buffer_size,
-		dev->buffers_number);
-	err = -ENOMEM;
-
-	if (dev->timeout_jiffies > 0) {
-		err = allocate_timeout_image(dev);
-		if (err < 0)
-			goto error;
+	/* FIXME: set buffers to 0 */
+	dev->image = vmalloc(image_size);
+	if (dev->image == NULL) {
+		dev->buffer_size = dev->image_size = 0;
+		return -ENOMEM;
 	}
+	init_buffers(dev, pix_format->sizeimage, buffer_size);
+	dev->buffer_size = buffer_size;
+	dev->image_size = image_size;
+	dprintk("allocate_buffers() -> vmalloc'd %lubytes\n", dev->image_size);
+	return 0;
+}
+static int allocate_timeout_buffer(struct v4l2_loopback_device *dev)
+{
+	/* device's `buffer_size` and `buffers` must be initialised in
+	 * allocate_buffers() */
 
-	dev->image = vmalloc(dev->imagesize);
-	if (dev->image == NULL)
-		goto error;
+	dprintk("allocate_timeout_buffer() size %ubytes\n", dev->buffer_size);
+	if (dev->buffer_size == 0)
+		return -EINVAL;
 
-	dprintk("vmallocated %ld bytes\n", dev->imagesize);
-	MARK();
+	if (dev->timeout_image) {
+		if (dev->timeout_buffer.buffer.flags & V4L2_BUF_FLAG_MAPPED)
+			return -EBUSY;
+		if (dev->buffer_size == dev->timeout_buffer_size)
+			return 0;
+		free_timeout_buffer(dev);
+	}
 
-	init_buffers(dev);
+	dev->timeout_image = vzalloc(dev->buffer_size);
+	if (!dev->timeout_image) {
+		dev->timeout_buffer_size = 0;
+		return -ENOMEM;
+	}
+	dev->timeout_buffer_size = dev->buffer_size;
 	return 0;
-
-error:
-	free_buffers(dev);
-	return err;
 }
-
-/* init inner buffers, they are capture mode and flags are set as
- * for capture mod buffers */
-static void init_buffers(struct v4l2_loopback_device *dev)
+/* init inner buffers, they are capture mode and flags are set as for capture
+ * mode buffers */
+static void init_buffers(struct v4l2_loopback_device *dev, u32 bytes_used,
+			 u32 buffer_size)
 {
-	int i;
-	int buffer_size;
-	int bytesused;
-	MARK();
+	u32 i;
 
-	buffer_size = dev->buffer_size;
-	bytesused = dev->pix_format.sizeimage;
-	for (i = 0; i < dev->buffers_number; ++i) {
+	for (i = 0; i < dev->buffer_count; ++i) {
 		struct v4l2_buffer *b = &dev->buffers[i].buffer;
 		b->index = i;
-		b->bytesused = bytesused;
+		b->bytesused = bytes_used;
 		b->length = buffer_size;
 		b->field = V4L2_FIELD_NONE;
 		b->flags = 0;
@@ -2474,34 +2624,13 @@ static void init_buffers(struct v4l2_loopback_device *dev)
 
 		v4l2l_get_timestamp(b);
 	}
-	dev->timeout_image_buffer = dev->buffers[0];
-	dev->timeout_image_buffer.buffer.m.offset = MAX_BUFFERS * buffer_size;
-	MARK();
-}
-
-static int allocate_timeout_image(struct v4l2_loopback_device *dev)
-{
-	MARK();
-	if (dev->buffer_size <= 0) {
-		dev->timeout_image_io = 0;
-		return -EINVAL;
-	}
-
-	if (dev->timeout_image == NULL) {
-		dev->timeout_image = vzalloc(dev->buffer_size);
-		if (dev->timeout_image == NULL) {
-			dev->timeout_image_io = 0;
-			return -ENOMEM;
-		}
-	}
-	return 0;
+	dev->timeout_buffer = dev->buffers[0];
+	dev->timeout_buffer.buffer.m.offset = MAX_BUFFERS * buffer_size;
 }
 
 /* fills and register video device */
 static void init_vdev(struct video_device *vdev, int nr)
 {
-	MARK();
-
 #ifdef V4L2LOOPBACK_WITH_STD
 	vdev->tvnorms = V4L2_STD_ALL;
 #endif /* V4L2LOOPBACK_WITH_STD */
@@ -2522,25 +2651,22 @@ static void init_vdev(struct video_device *vdev, int nr)
 				  V4L2_DEV_DEBUG_IOCTL_ARG;
 
 	vdev->vfl_dir = VFL_DIR_M2M;
-
-	MARK();
 }
 
 /* init default capture parameters, only fps may be changed in future */
 static void init_capture_param(struct v4l2_captureparm *capture_param)
 {
-	MARK();
-	capture_param->capability = 0;
+	capture_param->capability = V4L2_CAP_TIMEPERFRAME; /* since 2.16 */
 	capture_param->capturemode = 0;
 	capture_param->extendedmode = 0;
 	capture_param->readbuffers = max_buffers;
 	capture_param->timeperframe.numerator = 1;
-	capture_param->timeperframe.denominator = 30;
+	capture_param->timeperframe.denominator = V4L2LOOPBACK_FPS_DEFAULT;
 }
 
 static void check_timers(struct v4l2_loopback_device *dev)
 {
-	if (!dev->ready_for_capture)
+	if (has_output_token(dev->stream_tokens))
 		return;
 
 	if (dev->timeout_jiffies > 0 && !timer_pending(&dev->timeout_timer))
@@ -2562,8 +2688,8 @@ static void sustain_timer_clb(unsigned long nr)
 	spin_lock(&dev->lock);
 	if (dev->sustain_framerate) {
 		dev->reread_count++;
-		dprintkrw("reread: %lld %d\n", (long long)dev->write_position,
-			  dev->reread_count);
+		dprintkrw("sustain_timer_clb() write_pos=%lld reread=%u\n",
+			  (long long)dev->write_position, dev->reread_count);
 		if (dev->reread_count == 1)
 			mod_timer(&dev->sustain_timer,
 				  jiffies + max(1UL, dev->frame_jiffies / 2));
@@ -2605,8 +2731,7 @@ static int v4l2_loopback_add(struct v4l2_loopback_config *conf, int *ret_nr)
 	struct v4l2_loopback_device *dev;
 	struct v4l2_ctrl_handler *hdl;
 	struct v4l2loopback_private *vdev_priv = NULL;
-
-	int err = -ENOMEM;
+	int err;
 
 	u32 _width = V4L2LOOPBACK_SIZE_DEFAULT_WIDTH;
 	u32 _height = V4L2LOOPBACK_SIZE_DEFAULT_HEIGHT;
@@ -2621,15 +2746,14 @@ static int v4l2_loopback_add(struct v4l2_loopback_config *conf, int *ret_nr)
 	u32 _max_height =
 		DEFAULT_FROM_CONF(max_height, < _min_height, max_height);
 	bool _announce_all_caps = (conf && conf->announce_all_caps >= 0) ?
-					  (conf->announce_all_caps) :
-					  V4L2LOOPBACK_DEFAULT_EXCLUSIVECAPS;
+					  (bool)(conf->announce_all_caps) :
+					  !(V4L2LOOPBACK_DEFAULT_EXCLUSIVECAPS);
 	int _max_buffers = DEFAULT_FROM_CONF(max_buffers, <= 0, max_buffers);
 	int _max_openers = DEFAULT_FROM_CONF(max_openers, <= 0, max_openers);
+	struct v4l2_format _fmt;
 
 	int nr = -1;
 
-	_announce_all_caps = (!!_announce_all_caps);
-
 	if (conf) {
 		const int output_nr = conf->output_nr;
 #ifdef SPLIT_DEVICES
@@ -2647,9 +2771,11 @@ static int v4l2_loopback_add(struct v4l2_loopback_config *conf, int *ret_nr)
 			nr = capture_nr;
 		} else {
 			printk(KERN_ERR
-			       "split OUTPUT and CAPTURE devices not yet supported.");
+			       "v4l2-loopback add() split OUTPUT and CAPTURE "
+			       "devices not yet supported.\n");
 			printk(KERN_INFO
-			       "both devices must have the same number (%d != %d).",
+			       "v4l2-loopback add() both devices must have the "
+			       "same number (%d != %d).\n",
 			       output_nr, capture_nr);
 			return -EINVAL;
 		}
@@ -2658,7 +2784,8 @@ static int v4l2_loopback_add(struct v4l2_loopback_config *conf, int *ret_nr)
 	if (idr_find(&v4l2loopback_index_idr, nr))
 		return -EEXIST;
 
-	dprintk("creating v4l2loopback-device #%d\n", nr);
+	/* initialisation of a new device */
+	dprintk("add() creating device #%d\n", nr);
 	dev = kzalloc(sizeof(*dev), GFP_KERNEL);
 	if (!dev)
 		return -ENOMEM;
@@ -2674,8 +2801,10 @@ static int v4l2_loopback_add(struct v4l2_loopback_config *conf, int *ret_nr)
 	}
 	if (err < 0)
 		goto out_free_dev;
+
+	/* register new device */
+	MARK();
 	nr = err;
-	err = -ENOMEM;
 
 	if (conf && conf->card_label[0]) {
 		snprintf(dev->card_label, sizeof(dev->card_label), "%s",
@@ -2690,70 +2819,93 @@ static int v4l2_loopback_add(struct v4l2_loopback_config *conf, int *ret_nr)
 	err = v4l2_device_register(NULL, &dev->v4l2_dev);
 	if (err)
 		goto out_free_idr;
-	MARK();
 
+	/* initialise the _video_ device */
+	MARK();
+	err = -ENOMEM;
 	dev->vdev = video_device_alloc();
-	if (dev->vdev == NULL) {
-		err = -ENOMEM;
+	if (dev->vdev == NULL)
 		goto out_unregister;
-	}
 
 	vdev_priv = kzalloc(sizeof(struct v4l2loopback_private), GFP_KERNEL);
-	if (vdev_priv == NULL) {
-		err = -ENOMEM;
+	if (vdev_priv == NULL)
 		goto out_unregister;
-	}
 
 	video_set_drvdata(dev->vdev, vdev_priv);
-	if (video_get_drvdata(dev->vdev) == NULL) {
-		err = -ENOMEM;
+	if (video_get_drvdata(dev->vdev) == NULL)
 		goto out_unregister;
-	}
 
-	MARK();
 	snprintf(dev->vdev->name, sizeof(dev->vdev->name), "%s",
 		 dev->card_label);
-
 	vdev_priv->device_nr = nr;
-
 	init_vdev(dev->vdev, nr);
 	dev->vdev->v4l2_dev = &dev->v4l2_dev;
-	init_capture_param(&dev->capture_param);
-	err = set_timeperframe(dev, &dev->capture_param.timeperframe);
-	if (err)
-		goto out_unregister;
-	dev->keep_format = 0;
-	dev->sustain_framerate = 0;
 
+	/* initialise v4l2-loopback specific parameters */
+	MARK();
 	dev->announce_all_caps = _announce_all_caps;
 	dev->min_width = _min_width;
 	dev->min_height = _min_height;
 	dev->max_width = _max_width;
 	dev->max_height = _max_height;
 	dev->max_openers = _max_openers;
-	dev->buffers_number = dev->used_buffers = _max_buffers;
 
-	dev->write_position = 0;
+	/* set (initial) pixel and stream format */
+	_width = clamp_val(_width, _min_width, _max_width);
+	_height = clamp_val(_height, _min_height, _max_height);
+	_fmt = (struct v4l2_format){
+		.type = V4L2_BUF_TYPE_VIDEO_CAPTURE,
+		.fmt.pix = { .width = _width,
+			     .height = _height,
+			     .pixelformat = formats[0].fourcc,
+			     .colorspace = V4L2_COLORSPACE_DEFAULT,
+			     .field = V4L2_FIELD_NONE }
+	};
 
-	MARK();
-	spin_lock_init(&dev->lock);
-	spin_lock_init(&dev->list_lock);
+	err = v4l2l_fill_format(&_fmt, _min_width, _max_width, _min_height,
+				_max_height);
+	if (err)
+		/* highly unexpected failure to assign default format */
+		goto out_unregister;
+	dev->pix_format = _fmt.fmt.pix;
+	init_capture_param(&dev->capture_param);
+	set_timeperframe(dev, &dev->capture_param.timeperframe);
+
+	/* ctrls parameters */
+	dev->keep_format = 0;
+	dev->sustain_framerate = 0;
+	dev->timeout_jiffies = 0;
+	dev->timeout_image_io = 0;
+
+	/* initialise OUTPUT and CAPTURE buffer values */
+	dev->image = NULL;
+	dev->image_size = 0;
+	dev->buffer_count = _max_buffers;
+	dev->buffer_size = 0;
+	dev->used_buffer_count = 0;
 	INIT_LIST_HEAD(&dev->outbufs_list);
-	if (list_empty(&dev->outbufs_list)) {
-		int i;
+	do {
+		u32 index;
+		for (index = 0; index < dev->buffer_count; ++index)
+			INIT_LIST_HEAD(&dev->buffers[index].list_head);
 
-		for (i = 0; i < dev->used_buffers; ++i)
-			list_add_tail(&dev->buffers[i].list_head,
-				      &dev->outbufs_list);
-	}
+	} while (0);
 	memset(dev->bufpos2index, 0, sizeof(dev->bufpos2index));
+	dev->write_position = 0;
+
+	/* initialise synchronisation data */
 	atomic_set(&dev->open_count, 0);
-	dev->ready_for_capture = 0;
-	dev->ready_for_output = 1;
+	mutex_init(&dev->image_mutex);
+	spin_lock_init(&dev->lock);
+	spin_lock_init(&dev->list_lock);
+	init_waitqueue_head(&dev->read_event);
+	dev->format_tokens = V4L2L_TOKEN_MASK;
+	dev->stream_tokens = V4L2L_TOKEN_MASK;
 
-	dev->buffer_size = 0;
-	dev->image = NULL;
-	dev->imagesize = 0;
+	/* initialise sustain frame rate and timeout parameters, and timers */
+	dev->reread_count = 0;
+	dev->timeout_image = NULL;
+	dev->timeout_happened = 0;
 #ifdef HAVE_TIMER_SETUP
 	timer_setup(&dev->sustain_timer, sustain_timer_clb, 0);
 	timer_setup(&dev->timeout_timer, timeout_timer_clb, 0);
@@ -2761,11 +2913,9 @@ static int v4l2_loopback_add(struct v4l2_loopback_config *conf, int *ret_nr)
 	setup_timer(&dev->sustain_timer, sustain_timer_clb, nr);
 	setup_timer(&dev->timeout_timer, timeout_timer_clb, nr);
 #endif
-	dev->reread_count = 0;
-	dev->timeout_jiffies = 0;
-	dev->timeout_image = NULL;
-	dev->timeout_happened = 0;
 
+	/* initialise the control handler and add controls */
+	MARK();
 	hdl = &dev->ctrl_handler;
 	err = v4l2_ctrl_handler_init(hdl, 4);
 	if (err)
@@ -2784,44 +2934,17 @@ static int v4l2_loopback_add(struct v4l2_loopback_config *conf, int *ret_nr)
 	if (err)
 		goto out_free_handler;
 
-	/* FIXME set buffers to 0 */
-
-	/* Set initial format */
-	if (_width < _min_width)
-		_width = _min_width;
-	if (_width > _max_width)
-		_width = _max_width;
-	if (_height < _min_height)
-		_height = _min_height;
-	if (_height > _max_height)
-		_height = _max_height;
-
-	dev->pix_format.width = _width;
-	dev->pix_format.height = _height;
-	dev->pix_format.pixelformat = formats[0].fourcc;
-	dev->pix_format.colorspace =
-		V4L2_COLORSPACE_DEFAULT; /* do we need to set this ? */
-	dev->pix_format.field = V4L2_FIELD_NONE;
-
-	dev->buffer_size = PAGE_ALIGN(dev->pix_format.sizeimage);
-	dprintk("buffer_size = %ld (=%d)\n", dev->buffer_size,
-		dev->pix_format.sizeimage);
-
-	if (dev->buffer_size && ((err = allocate_buffers(dev)) < 0))
-		goto out_free_handler;
-
-	init_waitqueue_head(&dev->read_event);
-
-	/* register the device -> it creates /dev/video* */
+	/* register the device (creates /dev/video*) */
+	MARK();
 	if (video_register_device(dev->vdev, VFL_TYPE_VIDEO, nr) < 0) {
 		printk(KERN_ERR
-		       "v4l2loopback: failed video_register_device()\n");
+		       "v4l2-loopback add() failed video_register_device()\n");
 		err = -EFAULT;
 		goto out_free_device;
 	}
 	v4l2loopback_create_sysfs(dev->vdev);
+	/* NOTE: ambivalent if sysfs entries fail */
 
-	MARK();
 	if (ret_nr)
 		*ret_nr = dev->vdev->num;
 	return 0;
@@ -2844,12 +2967,17 @@ static int v4l2_loopback_add(struct v4l2_loopback_config *conf, int *ret_nr)
 
 static void v4l2_loopback_remove(struct v4l2_loopback_device *dev)
 {
+	int device_nr = v4l2loopback_get_vdev_nr(dev->vdev);
+	mutex_lock(&dev->image_mutex);
 	free_buffers(dev);
+	free_timeout_buffer(dev);
+	mutex_unlock(&dev->image_mutex);
 	v4l2loopback_remove_sysfs(dev->vdev);
+	v4l2_ctrl_handler_free(&dev->ctrl_handler);
 	kfree(video_get_drvdata(dev->vdev));
 	video_unregister_device(dev->vdev);
 	v4l2_device_unregister(&dev->v4l2_dev);
-	v4l2_ctrl_handler_free(&dev->ctrl_handler);
+	idr_remove(&v4l2loopback_index_idr, device_nr);
 	kfree(dev);
 }
 
@@ -2887,18 +3015,16 @@ static long v4l2loopback_control_ioctl(struct file *file, unsigned int cmd,
 	case V4L2LOOPBACK_CTL_REMOVE:
 		ret = v4l2loopback_lookup((int)parm, &dev);
 		if (ret >= 0 && dev) {
-			int nr = ret;
 			ret = -EBUSY;
 			if (dev->open_count.counter > 0)
 				break;
-			idr_remove(&v4l2loopback_index_idr, nr);
 			v4l2_loopback_remove(dev);
 			ret = 0;
 		};
 		break;
 		/* get information for a loopback device.
-                 * this is mostly about limits (which cannot be queried directly with  VIDIOC_G_FMT and friends
-                 */
+		 * this is mostly about limits (which cannot be queried directly with  VIDIOC_G_FMT and friends
+		 */
 	case V4L2LOOPBACK_CTL_QUERY:
 		if (!parm)
 			break;
@@ -2916,24 +3042,23 @@ static long v4l2loopback_control_ioctl(struct file *file, unsigned int cmd,
 			break;
 		MARK();
 		/* if we got the device from output_nr and there is a valid capture_nr,
-                 * make sure that both refer to the same device (or bail out)
-                 */
+		 * make sure that both refer to the same device (or bail out)
+		 */
 		if ((device_nr != capture_nr) && (capture_nr >= 0) &&
 		    ((ret = v4l2loopback_lookup(capture_nr, 0)) < 0))
 			break;
 		MARK();
 		/* if otoh, we got the device from capture_nr and there is a valid output_nr,
-                 * make sure that both refer to the same device (or bail out)
-                 */
+		 * make sure that both refer to the same device (or bail out)
+		 */
 		if ((device_nr != output_nr) && (output_nr >= 0) &&
 		    ((ret = v4l2loopback_lookup(output_nr, 0)) < 0))
 			break;
-		MARK();
 
 		/* v4l2_loopback_config identified a single device, so fetch the data */
 		snprintf(conf.card_label, sizeof(conf.card_label), "%s",
 			 dev->card_label);
-		MARK();
+
 		conf.output_nr = dev->vdev->num;
 #ifdef SPLIT_DEVICES
 		conf.capture_nr = dev->vdev->num;
@@ -2943,7 +3068,7 @@ static long v4l2loopback_control_ioctl(struct file *file, unsigned int cmd,
 		conf.max_width = dev->max_width;
 		conf.max_height = dev->max_height;
 		conf.announce_all_caps = dev->announce_all_caps;
-		conf.max_buffers = dev->buffers_number;
+		conf.max_buffers = dev->buffer_count;
 		conf.max_openers = dev->max_openers;
 		conf.debug = debug;
 		MARK();
@@ -2951,13 +3076,10 @@ static long v4l2loopback_control_ioctl(struct file *file, unsigned int cmd,
 			ret = -EFAULT;
 			break;
 		}
-		MARK();
 		ret = 0;
-		;
 		break;
 	}
 
-	MARK();
 	mutex_unlock(&v4l2loopback_ctl_mutex);
 	MARK();
 	return ret;
@@ -3090,32 +3212,35 @@ static int __init v4l2loopback_init_module(void)
 	if (devices > MAX_DEVICES) {
 		devices = MAX_DEVICES;
 		printk(KERN_INFO
-		       "v4l2loopback: number of initial devices is limited to: %d\n",
+		       "v4l2-loopback init() number of initial devices is "
+		       "limited to: %d\n",
 		       MAX_DEVICES);
 	}
 
 	if (max_buffers > MAX_BUFFERS) {
 		max_buffers = MAX_BUFFERS;
 		printk(KERN_INFO
-		       "v4l2loopback: number of buffers is limited to: %d\n",
+		       "v4l2-loopback init() number of buffers is limited "
+		       "to: %d\n",
 		       MAX_BUFFERS);
 	}
 
 	if (max_openers < 0) {
 		printk(KERN_INFO
-		       "v4l2loopback: allowing %d openers rather than %d\n",
+		       "v4l2-loopback init() allowing %d openers rather "
+		       "than %d\n",
 		       2, max_openers);
 		max_openers = 2;
 	}
 
 	if (max_width < min_width) {
 		max_width = V4L2LOOPBACK_SIZE_DEFAULT_MAX_WIDTH;
-		printk(KERN_INFO "v4l2loopback: using max_width %d\n",
+		printk(KERN_INFO "v4l2-loopback init() using max_width %d\n",
 		       max_width);
 	}
 	if (max_height < min_height) {
 		max_height = V4L2LOOPBACK_SIZE_DEFAULT_MAX_HEIGHT;
-		printk(KERN_INFO "v4l2loopback: using max_height %d\n",
+		printk(KERN_INFO "v4l2-loopback init() using max_height %d\n",
 		       max_height);
 	}
 
@@ -3149,7 +3274,7 @@ static int __init v4l2loopback_init_module(void)
 
 	dprintk("module installed\n");
 
-	printk(KERN_INFO "v4l2loopback driver version %d.%d.%d%s loaded\n",
+	printk(KERN_INFO "v4l2-loopback driver version %d.%d.%d%s loaded\n",
 	       // clang-format off
 	       (V4L2LOOPBACK_VERSION_CODE >> 16) & 0xff,
 	       (V4L2LOOPBACK_VERSION_CODE >>  8) & 0xff,
-- 
2.48.1

