From 17db988b624e1e2031d6055473cfd1959cf10121 Mon Sep 17 00:00:00 2001
From: Piotr Gorski <lucjan.lucjanov@gmail.com>
Date: Sun, 4 Dec 2022 14:06:26 +0100
Subject: [PATCH 92/92] rcu-6.1: sync with CachyOS

Signed-off-by: Piotr Gorski <lucjan.lucjanov@gmail.com>
---
 .../litmus-tests/locking/DCL-broken.litmus    |  55 ---
 .../litmus-tests/locking/DCL-fixed.litmus     |  56 ---
 .../litmus-tests/locking/RM-broken.litmus     |  42 ---
 .../litmus-tests/locking/RM-fixed.litmus      |  42 ---
 Documentation/memory-barriers.txt             |   2 +-
 .../translations/ko_KR/memory-barriers.txt    | 149 ++++----
 drivers/scsi/scsi_error.c                     |   2 +-
 include/linux/rculist_nulls.h                 |   2 +-
 include/linux/rcupdate.h                      |  14 +-
 include/linux/rcutiny.h                       |  15 +-
 include/linux/rcutree.h                       |   4 +-
 kernel/kcsan/core.c                           |  50 ---
 kernel/rcu/rcuscale.c                         |   2 +-
 kernel/rcu/rcutorture.c                       |  16 +-
 kernel/rcu/sync.c                             |   2 +-
 kernel/rcu/tiny.c                             |  11 +-
 kernel/rcu/tree.c                             |  83 ++---
 kernel/rcu/tree_exp.h                         |   2 +-
 kernel/time/clocksource.c                     |  13 +-
 kernel/time/tick-sched.c                      |  10 +-
 kernel/workqueue.c                            |   2 +-
 lib/Kconfig.kcsan                             |   6 +-
 lib/percpu-refcount.c                         |   2 +-
 net/core/dst.c                                |   2 +-
 net/ipv4/devinet.c                            |  19 +-
 net/rxrpc/conn_object.c                       |   2 +-
 .../Documentation/explanation.txt             |   7 +-
 tools/memory-model/Documentation/locking.txt  | 320 ------------------
 tools/memory-model/linux-kernel.bell          |  16 +-
 tools/memory-model/litmus-tests/.gitignore    |   2 +-
 tools/memory-model/scripts/README             |  16 +-
 tools/memory-model/scripts/checkalllitmus.sh  |  29 +-
 tools/memory-model/scripts/checkghlitmus.sh   |  11 +-
 tools/memory-model/scripts/checklitmus.sh     |  25 +-
 tools/memory-model/scripts/checklitmushist.sh |   2 +-
 .../memory-model/scripts/checktheselitmus.sh  |  43 ---
 tools/memory-model/scripts/cmplitmushist.sh   |  49 +--
 tools/memory-model/scripts/hwfnseg.sh         |  20 --
 tools/memory-model/scripts/initlitmushist.sh  |   2 +-
 tools/memory-model/scripts/judgelitmus.sh     | 120 ++-----
 tools/memory-model/scripts/newlitmushist.sh   |   4 +-
 tools/memory-model/scripts/parseargs.sh       |  21 +-
 tools/memory-model/scripts/runlitmus.sh       |  80 -----
 tools/memory-model/scripts/runlitmushist.sh   |  29 +-
 tools/memory-model/scripts/simpletest.sh      |  35 --
 tools/objtool/check.c                         |  10 -
 tools/testing/selftests/nolibc/Makefile       |   3 -
 tools/testing/selftests/nolibc/nolibc-test.c  |   7 -
 48 files changed, 259 insertions(+), 1197 deletions(-)
 delete mode 100644 Documentation/litmus-tests/locking/DCL-broken.litmus
 delete mode 100644 Documentation/litmus-tests/locking/DCL-fixed.litmus
 delete mode 100644 Documentation/litmus-tests/locking/RM-broken.litmus
 delete mode 100644 Documentation/litmus-tests/locking/RM-fixed.litmus
 delete mode 100644 tools/memory-model/Documentation/locking.txt
 delete mode 100755 tools/memory-model/scripts/checktheselitmus.sh
 delete mode 100755 tools/memory-model/scripts/hwfnseg.sh
 delete mode 100755 tools/memory-model/scripts/runlitmus.sh
 delete mode 100755 tools/memory-model/scripts/simpletest.sh

diff --git a/Documentation/litmus-tests/locking/DCL-broken.litmus b/Documentation/litmus-tests/locking/DCL-broken.litmus
deleted file mode 100644
index cfaa25ff8..000000000
--- a/Documentation/litmus-tests/locking/DCL-broken.litmus
+++ /dev/null
@@ -1,55 +0,0 @@
-C DCL-broken
-
-(*
- * Result: Sometimes
- *
- * This litmus test demonstrates more than just locking is required to
- * correctly implement double-checked locking.
- *)
-
-{
-	int flag;
-	int data;
-	int lck;
-}
-
-P0(int *flag, int *data, int *lck)
-{
-	int r0;
-	int r1;
-	int r2;
-
-	r0 = READ_ONCE(*flag);
-	if (r0 == 0) {
-		spin_lock(lck);
-		r1 = READ_ONCE(*flag);
-		if (r1 == 0) {
-			WRITE_ONCE(*data, 1);
-			WRITE_ONCE(*flag, 1);
-		}
-		spin_unlock(lck);
-	}
-	r2 = READ_ONCE(*data);
-}
-
-P1(int *flag, int *data, int *lck)
-{
-	int r0;
-	int r1;
-	int r2;
-
-	r0 = READ_ONCE(*flag);
-	if (r0 == 0) {
-		spin_lock(lck);
-		r1 = READ_ONCE(*flag);
-		if (r1 == 0) {
-			WRITE_ONCE(*data, 1);
-			WRITE_ONCE(*flag, 1);
-		}
-		spin_unlock(lck);
-	}
-	r2 = READ_ONCE(*data);
-}
-
-locations [flag;data;lck;0:r0;0:r1;1:r0;1:r1]
-exists (0:r2=0 \/ 1:r2=0)
diff --git a/Documentation/litmus-tests/locking/DCL-fixed.litmus b/Documentation/litmus-tests/locking/DCL-fixed.litmus
deleted file mode 100644
index 579d6c246..000000000
--- a/Documentation/litmus-tests/locking/DCL-fixed.litmus
+++ /dev/null
@@ -1,56 +0,0 @@
-C DCL-fixed
-
-(*
- * Result: Never
- *
- * This litmus test demonstrates that double-checked locking can be
- * reliable given proper use of smp_load_acquire() and smp_store_release()
- * in addition to the locking.
- *)
-
-{
-	int flag;
-	int data;
-	int lck;
-}
-
-P0(int *flag, int *data, int *lck)
-{
-	int r0;
-	int r1;
-	int r2;
-
-	r0 = smp_load_acquire(flag);
-	if (r0 == 0) {
-		spin_lock(lck);
-		r1 = READ_ONCE(*flag);
-		if (r1 == 0) {
-			WRITE_ONCE(*data, 1);
-			smp_store_release(flag, 1);
-		}
-		spin_unlock(lck);
-	}
-	r2 = READ_ONCE(*data);
-}
-
-P1(int *flag, int *data, int *lck)
-{
-	int r0;
-	int r1;
-	int r2;
-
-	r0 = smp_load_acquire(flag);
-	if (r0 == 0) {
-		spin_lock(lck);
-		r1 = READ_ONCE(*flag);
-		if (r1 == 0) {
-			WRITE_ONCE(*data, 1);
-			smp_store_release(flag, 1);
-		}
-		spin_unlock(lck);
-	}
-	r2 = READ_ONCE(*data);
-}
-
-locations [flag;data;lck;0:r0;0:r1;1:r0;1:r1]
-exists (0:r2=0 \/ 1:r2=0)
diff --git a/Documentation/litmus-tests/locking/RM-broken.litmus b/Documentation/litmus-tests/locking/RM-broken.litmus
deleted file mode 100644
index c586ae4b5..000000000
--- a/Documentation/litmus-tests/locking/RM-broken.litmus
+++ /dev/null
@@ -1,42 +0,0 @@
-C RM-broken
-
-(*
- * Result: DEADLOCK
- *
- * This litmus test demonstrates that the old "roach motel" approach
- * to locking, where code can be freely moved into critical sections,
- * cannot be used in the Linux kernel.
- *)
-
-{
-	int lck;
-	int x;
-	int y;
-}
-
-P0(int *x, int *y, int *lck)
-{
-	int r2;
-
-	spin_lock(lck);
-	r2 = atomic_inc_return(y);
-	WRITE_ONCE(*x, 1);
-	spin_unlock(lck);
-}
-
-P1(int *x, int *y, int *lck)
-{
-	int r0;
-	int r1;
-	int r2;
-
-	spin_lock(lck);
-	r0 = READ_ONCE(*x);
-	r1 = READ_ONCE(*x);
-	r2 = atomic_inc_return(y);
-	spin_unlock(lck);
-}
-
-locations [x;lck;0:r2;1:r0;1:r1;1:r2]
-filter (y=2 /\ 1:r0=0 /\ 1:r1=1)
-exists (1:r2=1)
diff --git a/Documentation/litmus-tests/locking/RM-fixed.litmus b/Documentation/litmus-tests/locking/RM-fixed.litmus
deleted file mode 100644
index 672856736..000000000
--- a/Documentation/litmus-tests/locking/RM-fixed.litmus
+++ /dev/null
@@ -1,42 +0,0 @@
-C RM-fixed
-
-(*
- * Result: Never
- *
- * This litmus test demonstrates that the old "roach motel" approach
- * to locking, where code can be freely moved into critical sections,
- * cannot be used in the Linux kernel.
- *)
-
-{
-	int lck;
-	int x;
-	int y;
-}
-
-P0(int *x, int *y, int *lck)
-{
-	int r2;
-
-	spin_lock(lck);
-	r2 = atomic_inc_return(y);
-	WRITE_ONCE(*x, 1);
-	spin_unlock(lck);
-}
-
-P1(int *x, int *y, int *lck)
-{
-	int r0;
-	int r1;
-	int r2;
-
-	r0 = READ_ONCE(*x);
-	r1 = READ_ONCE(*x);
-	spin_lock(lck);
-	r2 = atomic_inc_return(y);
-	spin_unlock(lck);
-}
-
-locations [x;lck;0:r2;1:r0;1:r1;1:r2]
-filter (y=2 /\ 1:r0=0 /\ 1:r1=1)
-exists (1:r2=1)
diff --git a/Documentation/memory-barriers.txt b/Documentation/memory-barriers.txt
index cc621decd..06f80e378 100644
--- a/Documentation/memory-barriers.txt
+++ b/Documentation/memory-barriers.txt
@@ -1966,7 +1966,7 @@ There are some more advanced barrier functions:
  (*) io_stop_wc();
 
      For memory accesses with write-combining attributes (e.g. those returned
-     by ioremap_wc()), the CPU may wait for prior accesses to be merged with
+     by ioremap_wc(), the CPU may wait for prior accesses to be merged with
      subsequent ones. io_stop_wc() can be used to prevent the merging of
      write-combining memory accesses before this macro with those after it when
      such wait has performance implications.
diff --git a/Documentation/translations/ko_KR/memory-barriers.txt b/Documentation/translations/ko_KR/memory-barriers.txt
index 7165927a7..75aa5531c 100644
--- a/Documentation/translations/ko_KR/memory-barriers.txt
+++ b/Documentation/translations/ko_KR/memory-barriers.txt
@@ -80,7 +80,7 @@ Documentation/memory-barriers.txt
 
      - 메모리 배리어의 종류.
      - 메모리 배리어에 대해 가정해선 안될 것.
-     - 주소 데이터 의존성 배리어 (역사적).
+     - 데이터 의존성 배리어 (역사적).
      - 컨트롤 의존성.
      - SMP 배리어 짝맞추기.
      - 메모리 배리어 시퀀스의 예.
@@ -217,7 +217,7 @@ Documentation/memory-barriers.txt
 	P = &B		D = *Q;
 
 D 로 읽혀지는 값은 CPU 2 에서 P 로부터 읽혀진 주소값에 의존적이기 때문에 여기엔
-분명한 주소 의존성이 있습니다.  하지만 이 이벤트들의 실행 결과로는 아래의
+분명한 데이터 의존성이 있습니다.  하지만 이 이벤트들의 실행 결과로는 아래의
 결과들이 모두 나타날 수 있습니다:
 
 	(Q == &A) and (D == 1)
@@ -416,19 +416,19 @@ CPU 에게 기대할 수 있는 최소한의 보장사항 몇가지가 있습니
      하나씩 요청해 집어넣습니다.  쓰기 배리어 앞의 모든 스토어 오퍼레이션들은
      쓰기 배리어 뒤의 모든 스토어 오퍼레이션들보다 _앞서_ 수행될 겁니다.
 
-     [!] 쓰기 배리어들은 읽기 또는 주소 의존성 배리어와 함께 짝을 맞춰
+     [!] 쓰기 배리어들은 읽기 또는 데이터 의존성 배리어와 함께 짝을 맞춰
      사용되어야만 함을 알아두세요; "SMP 배리어 짝맞추기" 서브섹션을 참고하세요.
 
 
- (2) 주소 의존성 배리어 (역사적).
+ (2) 데이터 의존성 배리어.
 
-     주소 의존성 배리어는 읽기 배리어의 보다 완화된 형태입니다.  두개의 로드
+     데이터 의존성 배리어는 읽기 배리어의 보다 완화된 형태입니다.  두개의 로드
      오퍼레이션이 있고 두번째 것이 첫번째 것의 결과에 의존하고 있을 때(예:
      두번째 로드가 참조할 주소를 첫번째 로드가 읽는 경우), 두번째 로드가 읽어올
      데이터는 첫번째 로드에 의해 그 주소가 얻어진 뒤에 업데이트 됨을 보장하기
-     위해서 주소 의존성 배리어가 필요할 수 있습니다.
+     위해서 데이터 의존성 배리어가 필요할 수 있습니다.
 
-     주소 의존성 배리어는 상호 의존적인 로드 오퍼레이션들 사이의 부분적 순서
+     데이터 의존성 배리어는 상호 의존적인 로드 오퍼레이션들 사이의 부분적 순서
      세우기입니다; 스토어 오퍼레이션들이나 독립적인 로드들, 또는 중복되는
      로드들에 대해서는 어떤 영향도 끼치지 않습니다.
 
@@ -436,41 +436,37 @@ CPU 에게 기대할 수 있는 최소한의 보장사항 몇가지가 있습니
      오퍼레이션들을 던져 넣고 있으며, 거기에 관심이 있는 다른 CPU 는 그
      오퍼레이션들을 메모리 시스템이 실행한 결과를 인지할 수 있습니다.  이처럼
      다른 CPU 의 스토어 오퍼레이션의 결과에 관심을 두고 있는 CPU 가 수행 요청한
-     주소 의존성 배리어는, 배리어 앞의 어떤 로드 오퍼레이션이 다른 CPU 에서
+     데이터 의존성 배리어는, 배리어 앞의 어떤 로드 오퍼레이션이 다른 CPU 에서
      던져 넣은 스토어 오퍼레이션과 같은 영역을 향했다면, 그런 스토어
-     오퍼레이션들이 만들어내는 결과가 주소 의존성 배리어 뒤의 로드
+     오퍼레이션들이 만들어내는 결과가 데이터 의존성 배리어 뒤의 로드
      오퍼레이션들에게는 보일 것을 보장합니다.
 
      이 순서 세우기 제약에 대한 그림을 보기 위해선 "메모리 배리어 시퀀스의 예"
      서브섹션을 참고하시기 바랍니다.
 
-     [!] 첫번째 로드는 반드시 _주소_ 의존성을 가져야지 컨트롤 의존성을 가져야
+     [!] 첫번째 로드는 반드시 _데이터_ 의존성을 가져야지 컨트롤 의존성을 가져야
      하는게 아님을 알아두십시오.  만약 두번째 로드를 위한 주소가 첫번째 로드에
      의존적이지만 그 의존성은 조건적이지 그 주소 자체를 가져오는게 아니라면,
      그것은 _컨트롤_ 의존성이고, 이 경우에는 읽기 배리어나 그보다 강력한
      무언가가 필요합니다.  더 자세한 내용을 위해서는 "컨트롤 의존성" 서브섹션을
      참고하시기 바랍니다.
 
-     [!] 주소 의존성 배리어는 보통 쓰기 배리어들과 함께 짝을 맞춰 사용되어야
+     [!] 데이터 의존성 배리어는 보통 쓰기 배리어들과 함께 짝을 맞춰 사용되어야
      합니다; "SMP 배리어 짝맞추기" 서브섹션을 참고하세요.
 
-     [!] 커널 v5.9 릴리즈에서 명시적 주소 의존성 배리어를 위한 커널 API 들이
-     삭제되었습니다.  오늘날에는 공유된 변수들의 로드를 표시하는 READ_ONCE() 나
-     rcu_dereference() 와 같은 API 들은 묵시적으로 주소 의존성 배리어를 제공합니다.
-
 
  (3) 읽기 (또는 로드) 메모리 배리어.
 
-     읽기 배리어는 주소 의존성 배리어 기능의 보장사항에 더해서 배리어보다 앞서
-     명시된 모든 LOAD 오퍼레이션들이 배리어 뒤에 명시되는 모든 LOAD
+     읽기 배리어는 데이터 의존성 배리어 기능의 보장사항에 더해서 배리어보다
+     앞서 명시된 모든 LOAD 오퍼레이션들이 배리어 뒤에 명시되는 모든 LOAD
      오퍼레이션들보다 먼저 행해진 것으로 시스템의 다른 컴포넌트들에 보여질 것을
      보장합니다.
 
      읽기 배리어는 로드 오퍼레이션에 행해지는 부분적 순서 세우기입니다; 스토어
      오퍼레이션에 대해서는 어떤 영향도 끼치지 않습니다.
 
-     읽기 메모리 배리어는 주소 의존성 배리어를 내장하므로 주소 의존성 배리어를
-     대신할 수 있습니다.
+     읽기 메모리 배리어는 데이터 의존성 배리어를 내장하므로 데이터 의존성
+     배리어를 대신할 수 있습니다.
 
      [!] 읽기 배리어는 일반적으로 쓰기 배리어들과 함께 짝을 맞춰 사용되어야
      합니다; "SMP 배리어 짝맞추기" 서브섹션을 참고하세요.
@@ -575,20 +571,16 @@ ACQUIRE 는 해당 오퍼레이션의 로드 부분에만 적용되고 RELEASE 
 	    Documentation/core-api/dma-api.rst
 
 
-주소 의존성 배리어 (역사적)
----------------------------
+데이터 의존성 배리어 (역사적)
+-----------------------------
 
 리눅스 커널 v4.15 기준으로, smp_mb() 가 DEC Alpha 용 READ_ONCE() 코드에
 추가되었는데, 이는 이 섹션에 주의를 기울여야 하는 사람들은 DEC Alpha 아키텍쳐
 전용 코드를 만드는 사람들과 READ_ONCE() 자체를 만드는 사람들 뿐임을 의미합니다.
-그런 분들을 위해, 그리고 역사에 관심 있는 분들을 위해, 여기 주소 의존성
+그런 분들을 위해, 그리고 역사에 관심 있는 분들을 위해, 여기 데이터 의존성
 배리어에 대한 이야기를 적습니다.
 
-[!] 주소 의존성은 로드에서 로드로와 로드에서 스토어로의 관계들 모두에서
-나타나지만, 주소 의존성 배리어는 로드에서 스토어로의 상황에서는 필요하지
-않습니다.
-
-주소 의존성 배리어의 사용에 있어 지켜야 하는 사항들은 약간 미묘하고, 데이터
+데이터 의존성 배리어의 사용에 있어 지켜야 하는 사항들은 약간 미묘하고, 데이터
 의존성 배리어가 사용되어야 하는 상황도 항상 명백하지는 않습니다.  설명을 위해
 다음의 이벤트 시퀀스를 생각해 봅시다:
 
@@ -598,13 +590,10 @@ ACQUIRE 는 해당 오퍼레이션의 로드 부분에만 적용되고 RELEASE 
 	B = 4;
 	<쓰기 배리어>
 	WRITE_ONCE(P, &B)
-			      Q = READ_ONCE_OLD(P);
+			      Q = READ_ONCE(P);
 			      D = *Q;
 
-[!] READ_ONCE_OLD() 는 4.15 커널 전의 버전에서의, 주소 의존성 배리어를 내포하지
-않는 READ_ONCE() 에 해당합니다.
-
-여기엔 분명한 주소 의존성이 존재하므로, 이 시퀀스가 끝났을 때 Q 는 &A 또는 &B
+여기엔 분명한 데이터 의존성이 존재하므로, 이 시퀀스가 끝났을 때 Q 는 &A 또는 &B
 일 것이고, 따라서:
 
 	(Q == &A) 는 (D == 1) 를,
@@ -619,8 +608,8 @@ ACQUIRE 는 해당 오퍼레이션의 로드 부분에만 적용되고 RELEASE 
 그렇지 않습니다, 그리고 이 현상은 (DEC Alpha 와 같은) 여러 CPU 에서 실제로
 발견될 수 있습니다.
 
-이 문제 상황을 제대로 해결하기 위해, READ_ONCE() 는 커널 v4.15 릴리즈 부터
-묵시적 주소 의존성 배리어를 제공합니다:
+이 문제 상황을 제대로 해결하기 위해, 데이터 의존성 배리어나 그보다 강화된
+무언가가 주소를 읽어올 때와 데이터를 읽어올 때 사이에 추가되어야만 합니다:
 
 	CPU 1		      CPU 2
 	===============	      ===============
@@ -629,7 +618,7 @@ ACQUIRE 는 해당 오퍼레이션의 로드 부분에만 적용되고 RELEASE 
 	<쓰기 배리어>
 	WRITE_ONCE(P, &B);
 			      Q = READ_ONCE(P);
-			      <묵시적 주소 의존성 배리어>
+			      <데이터 의존성 배리어>
 			      D = *Q;
 
 이 변경은 앞의 처음 두가지 결과 중 하나만이 발생할 수 있고, 세번째의 결과는
@@ -645,7 +634,7 @@ P 는 짝수 번호 캐시 라인에 저장되어 있고, 변수 B 는 홀수 
 중이라면 포인터 P (&B) 의 새로운 값과 변수 B 의 기존 값 (2) 를 볼 수 있습니다.
 
 
-의존적 쓰기들의 순서를 맞추는데에는 주소 의존성 배리어가 필요치 않은데, 이는
+의존적 쓰기들의 순서를 맞추는데에는 데이터 의존성 배리어가 필요치 않은데, 이는
 리눅스 커널이 지원하는 CPU 들은 (1) 쓰기가 정말로 일어날지, (2) 쓰기가 어디에
 이루어질지, 그리고 (3) 쓰여질 값을 확실히 알기 전까지는 쓰기를 수행하지 않기
 때문입니다.  하지만 "컨트롤 의존성" 섹션과
@@ -658,12 +647,12 @@ Documentation/RCU/rcu_dereference.rst 파일을 주의 깊게 읽어 주시기 
 	B = 4;
 	<쓰기 배리어>
 	WRITE_ONCE(P, &B);
-			      Q = READ_ONCE_OLD(P);
+			      Q = READ_ONCE(P);
 			      WRITE_ONCE(*Q, 5);
 
-따라서, Q 로의 읽기와 *Q 로의 쓰기 사이에는 주소 의존성 배리어가 필요치
-않습니다.  달리 말하면, 오늘날의 READ_ONCE() 의 묵시적 주소 의존성 배리어가
-없더라도 다음 결과는 생기지 않습니다:
+따라서, Q 로의 읽기와 *Q 로의 쓰기 사이에는 데이터 종속성 배리어가 필요치
+않습니다.  달리 말하면, 데이터 종속성 배리어가 없더라도 다음 결과는 생기지
+않습니다:
 
 	(Q == &B) && (B == 4)
 
@@ -674,16 +663,16 @@ Documentation/RCU/rcu_dereference.rst 파일을 주의 깊게 읽어 주시기 
 해줍니다.
 
 
-주소 의존성에 의해 제공되는 이 순서규칙은 이를 포함하고 있는 CPU 에
+데이터 의존성에 의해 제공되는 이 순서규칙은 이를 포함하고 있는 CPU 에
 지역적임을 알아두시기 바랍니다.  더 많은 정보를 위해선 "Multicopy 원자성"
 섹션을 참고하세요.
 
 
-주소 의존성 배리어는 매우 중요한데, 예를 들어 RCU 시스템에서 그렇습니다.
+데이터 의존성 배리어는 매우 중요한데, 예를 들어 RCU 시스템에서 그렇습니다.
 include/linux/rcupdate.h 의 rcu_assign_pointer() 와 rcu_dereference() 를
-참고하세요.  이것들은 RCU 로 관리되는 포인터의 타겟을 현재 타겟에서 수정된
-새로운 타겟으로 바꾸는 작업에서 새로 수정된 타겟이 초기화가 완료되지 않은 채로
-보여지는 일이 일어나지 않게 해줍니다.
+참고하세요.  여기서 데이터 의존성 배리어는 RCU 로 관리되는 포인터의 타겟을 현재
+타겟에서 수정된 새로운 타겟으로 바꾸는 작업에서 새로 수정된 타겟이 초기화가
+완료되지 않은 채로 보여지는 일이 일어나지 않게 해줍니다.
 
 더 많은 예를 위해선 "캐시 일관성" 서브섹션을 참고하세요.
 
@@ -695,17 +684,16 @@ include/linux/rcupdate.h 의 rcu_assign_pointer() 와 rcu_dereference() 를
 약간 다루기 어려울 수 있습니다.  이 섹션의 목적은 여러분이 컴파일러의 무시로
 인해 여러분의 코드가 망가지는 걸 막을 수 있도록 돕는겁니다.
 
-로드-로드 컨트롤 의존성은 (묵시적인) 주소 의존성 배리어만으로는 정확히 동작할
-수가 없어서 읽기 메모리 배리어를 필요로 합니다.  아래의 코드를 봅시다:
+로드-로드 컨트롤 의존성은 데이터 의존성 배리어만으로는 정확히 동작할 수가
+없어서 읽기 메모리 배리어를 필요로 합니다.  아래의 코드를 봅시다:
 
 	q = READ_ONCE(a);
-	<묵시적 주소 의존성 배리어>
 	if (q) {
-		/* BUG: No address dependency!!! */
+		<데이터 의존성 배리어>  /* BUG: No data dependency!!! */
 		p = READ_ONCE(b);
 	}
 
-이 코드는 원하는 대로의 효과를 내지 못할 수 있는데, 이 코드에는 주소 의존성이
+이 코드는 원하는 대로의 효과를 내지 못할 수 있는데, 이 코드에는 데이터 의존성이
 아니라 컨트롤 의존성이 존재하기 때문으로, 이런 상황에서 CPU 는 실행 속도를 더
 빠르게 하기 위해 분기 조건의 결과를 예측하고 코드를 재배치 할 수 있어서 다른
 CPU 는 b 로부터의 로드 오퍼레이션이 a 로부터의 로드 오퍼레이션보다 먼저 발생한
@@ -942,9 +930,9 @@ CPU 간 상호작용을 다룰 때에 일부 타입의 메모리 배리어는 
 범용 배리어들은 범용 배리어끼리도 짝을 맞추지만 multicopy 원자성이 없는
 대부분의 다른 타입의 배리어들과도 짝을 맞춥니다.  ACQUIRE 배리어는 RELEASE
 배리어와 짝을 맞춥니다만, 둘 다 범용 배리어를 포함해 다른 배리어들과도 짝을
-맞출 수 있습니다.  쓰기 배리어는 주소 의존성 배리어나 컨트롤 의존성, ACQUIRE
+맞출 수 있습니다.  쓰기 배리어는 데이터 의존성 배리어나 컨트롤 의존성, ACQUIRE
 배리어, RELEASE 배리어, 읽기 배리어, 또는 범용 배리어와 짝을 맞춥니다.
-비슷하게 읽기 배리어나 컨트롤 의존성, 또는 주소 의존성 배리어는 쓰기 배리어나
+비슷하게 읽기 배리어나 컨트롤 의존성, 또는 데이터 의존성 배리어는 쓰기 배리어나
 ACQUIRE 배리어, RELEASE 배리어, 또는 범용 배리어와 짝을 맞추는데, 다음과
 같습니다:
 
@@ -963,7 +951,7 @@ ACQUIRE 배리어, RELEASE 배리어, 또는 범용 배리어와 짝을 맞추
 	a = 1;
 	<쓰기 배리어>
 	WRITE_ONCE(b, &a);    x = READ_ONCE(b);
-			      <묵시적 주소 의존성 배리어>
+			      <데이터 의존성 배리어>
 			      y = *x;
 
 또는:
@@ -982,8 +970,8 @@ ACQUIRE 배리어, RELEASE 배리어, 또는 범용 배리어와 짝을 맞추
 기본적으로, 여기서의 읽기 배리어는 "더 완화된" 타입일 순 있어도 항상 존재해야
 합니다.
 
-[!] 쓰기 배리어 앞의 스토어 오퍼레이션은 일반적으로 읽기 배리어나 주소 의존성
-배리어 뒤의 로드 오퍼레이션과 매치될 것이고, 반대도 마찬가지입니다:
+[!] 쓰기 배리어 앞의 스토어 오퍼레이션은 일반적으로 읽기 배리어나 데이터
+의존성 배리어 뒤의 로드 오퍼레이션과 매치될 것이고, 반대도 마찬가지입니다:
 
 	CPU 1                               CPU 2
 	===================                 ===================
@@ -1035,7 +1023,7 @@ ACQUIRE 배리어, RELEASE 배리어, 또는 범용 배리어와 짝을 맞추
 	                   V
 
 
-둘째, 주소 의존성 배리어는 데이터 의존적 로드 오퍼레이션들의 부분적 순서
+둘째, 데이터 의존성 배리어는 데이터 의존적 로드 오퍼레이션들의 부분적 순서
 세우기로 동작합니다.  다음 일련의 이벤트들을 보세요:
 
 	CPU 1			CPU 2
@@ -1081,7 +1069,7 @@ ACQUIRE 배리어, RELEASE 배리어, 또는 범용 배리어와 짝을 맞추
 앞의 예에서, CPU 2 는 (B 의 값이 될) *C 의 값 읽기가 C 의 LOAD 뒤에 이어짐에도
 B 가 7 이라는 결과를 얻습니다.
 
-하지만, 만약 주소 의존성 배리어가 C 의 로드와 *C (즉, B) 의 로드 사이에
+하지만, 만약 데이터 의존성 배리어가 C 의 로드와 *C (즉, B) 의 로드 사이에
 있었다면:
 
 	CPU 1			CPU 2
@@ -1092,7 +1080,7 @@ B 가 7 이라는 결과를 얻습니다.
 	<쓰기 배리어>
 	STORE C = &B		LOAD X
 	STORE D = 4		LOAD C (gets &B)
-				<주소 의존성 배리어>
+				<데이터 의존성 배리어>
 				LOAD *C (reads B)
 
 다음과 같이 됩니다:
@@ -1115,7 +1103,7 @@ B 가 7 이라는 결과를 얻습니다.
 	                               |        +-------+       |       |
 	                               |        | X->9  |------>|       |
 	                               |        +-------+       |       |
-	  C 로의 스토어 앞의     --->   \   aaaaaaaaaaaaaaaaa   |       |
+	  C 로의 스토어 앞의     --->   \   ddddddddddddddddd   |       |
 	  모든 이벤트 결과가             \      +-------+       |       |
 	  뒤의 로드에게                   ----->| B->2  |------>|       |
 	  보이게 강제한다                       +-------+       |       |
@@ -1303,7 +1291,7 @@ A 의 로드 두개가 모두 B 의 로드 뒤에 있지만, 서로 다른 값
 	즉각 완료한다                           :       :       +-------+
 
 
-읽기 배리어나 주소 의존성 배리어를 두번째 로드 직전에 놓는다면:
+읽기 배리어나 데이터 의존성 배리어를 두번째 로드 직전에 놓는다면:
 
 	CPU 1			CPU 2
 	=======================	=======================
@@ -1797,20 +1785,21 @@ READ_ONCE(jiffies) 라고 할 필요가 없습니다.  READ_ONCE() 와 WRITE_ONC
 CPU 메모리 배리어
 -----------------
 
-리눅스 커널은 다음의 일곱개 기본 CPU 메모리 배리어를 가지고 있습니다:
+리눅스 커널은 다음의 여덟개 기본 CPU 메모리 배리어를 가지고 있습니다:
 
 	TYPE		MANDATORY		SMP CONDITIONAL
-	===============	=======================	===============
+	===============	=======================	===========================
 	범용		mb()			smp_mb()
 	쓰기		wmb()			smp_wmb()
 	읽기		rmb()			smp_rmb()
-	주소 의존성				READ_ONCE()
+	데이터 의존성				READ_ONCE()
 
 
-주소 의존성 배리어를 제외한 모든 메모리 배리어는 컴파일러 배리어를 포함합니다.
-주소 의존성은 컴파일러에의 추가적인 순서 보장을 포함하지 않습니다.
+데이터 의존성 배리어를 제외한 모든 메모리 배리어는 컴파일러 배리어를
+포함합니다.  데이터 의존성은 컴파일러에의 추가적인 순서 보장을 포함하지
+않습니다.
 
-방백: 주소 의존성이 있는 경우, 컴파일러는 해당 로드를 올바른 순서로 일으킬
+방백: 데이터 의존성이 있는 경우, 컴파일러는 해당 로드를 올바른 순서로 일으킬
 것으로 (예: `a[b]` 는 a[b] 를 로드 하기 전에 b 의 값을 먼저 로드한다)
 기대되지만, C 언어 사양에는 컴파일러가 b 의 값을 추측 (예: 1 과 같음) 해서
 b  로드 전에 a 로드를 하는 코드 (예: tmp = a[1]; if (b != 1) tmp = a[b]; ) 를
@@ -1874,7 +1863,6 @@ Mandatory 배리어들은 SMP 시스템에서도 UP 시스템에서도 SMP 효
 
  (*) dma_wmb();
  (*) dma_rmb();
- (*) dma_mb();
 
      이것들은 CPU 와 DMA 가능한 디바이스에서 모두 액세스 가능한 공유 메모리의
      읽기, 쓰기 작업들의 순서를 보장하기 위해 consistent memory 에서 사용하기
@@ -1905,13 +1893,12 @@ Mandatory 배리어들은 SMP 시스템에서도 UP 시스템에서도 SMP 효
 
      dma_rmb() 는 디스크립터로부터 데이터를 읽어오기 전에 디바이스가 소유권을
      내려놓았을 것을 보장하고, dma_wmb() 는 디바이스가 자신이 소유권을 다시
-     가졌음을 보기 전에 디스크립터에 데이터가 쓰였을 것을 보장합니다.  dma_mb()
-     는 dma_rmb() 와 dma_wmb() 를 모두 내포합니다.  참고로, writel() 을
-     사용하면 캐시 일관성이 있는 메모리 (cache coherent memory) 쓰기가 MMIO
-     영역에의 쓰기 전에 완료되었을 것을 보장하므로 writel() 앞에 wmb() 를
-     실행할 필요가 없음을 알아두시기 바랍니다.  writel() 보다 비용이 저렴한
-     writel_relaxed() 는 이런 보장을 제공하지 않으므로 여기선 사용되지 않아야
-     합니다.
+     가졌음을 보기 전에 디스크립터에 데이터가 쓰였을 것을 보장합니다.  참고로,
+     writel() 을 사용하면 캐시 일관성이 있는 메모리 (cache coherent memory)
+     쓰기가 MMIO 영역에의 쓰기 전에 완료되었을 것을 보장하므로 writel() 앞에
+     wmb() 를 실행할 필요가 없음을 알아두시기 바랍니다.  writel() 보다 비용이
+     저렴한 writel_relaxed() 는 이런 보장을 제공하지 않으므로 여기선 사용되지
+     않아야 합니다.
 
      writel_relaxed() 와 같은 완화된 I/O 접근자들에 대한 자세한 내용을 위해서는
      "커널 I/O 배리어의 효과" 섹션을, consistent memory 에 대한 자세한 내용을
@@ -1931,14 +1918,6 @@ Mandatory 배리어들은 SMP 시스템에서도 UP 시스템에서도 SMP 효
      Persistent memory 에서의 로드를 위해선 현재의 읽기 메모리 배리어로도 읽기
      순서를 보장하는데 충분합니다.
 
-  (*) io_stop_wc();
-
-     쓰기와 결합된 특성을 갖는 메모리 액세스의 경우 (예: ioremap_wc() 에 의해
-     리턴되는 것들), CPU 는 앞의 액세스들이 뒤따르는 것들과 병합되게끔 기다릴
-     수 있습니다.  io_stop_wc() 는 그런 기다림이 성능에 영향을 끼칠 수 있을 때,
-     이 매크로 앞의 쓰기-결합된 메모리 액세스들이 매크로 뒤의 것들과 병합되는
-     것을 방지하기 위해 사용될 수 있습니다.
-
 =========================
 암묵적 커널 메모리 배리어
 =========================
@@ -2848,9 +2827,9 @@ ld.acq 와 stl.rel 인스트럭션을 각각 만들어 내도록 합니다.
 DEC Alpha CPU 는 가장 완화된 메모리 순서의 CPU 중 하나입니다.  뿐만 아니라,
 Alpha CPU 의 일부 버전은 분할된 데이터 캐시를 가지고 있어서, 의미적으로
 관계되어 있는 두개의 캐시 라인이 서로 다른 시간에 업데이트 되는게 가능합니다.
-이게 주소 의존성 배리어가 정말 필요해지는 부분인데, 주소 의존성 배리어는 메모리
-일관성 시스템과 함께 두개의 캐시를 동기화 시켜서, 포인터 변경과 새로운 데이터의
-발견을 올바른 순서로 일어나게 하기 때문입니다.
+이게 데이터 의존성 배리어가 정말 필요해지는 부분인데, 데이터 의존성 배리어는
+메모리 일관성 시스템과 함께 두개의 캐시를 동기화 시켜서, 포인터 변경과 새로운
+데이터의 발견을 올바른 순서로 일어나게 하기 때문입니다.
 
 리눅스 커널의 메모리 배리어 모델은 Alpha 에 기초해서 정의되었습니다만, v4.15
 부터는 Alpha 용 READ_ONCE() 코드 내에 smp_mb() 가 추가되어서 메모리 모델로의
diff --git a/drivers/scsi/scsi_error.c b/drivers/scsi/scsi_error.c
index 634672e67..ac5ff0783 100644
--- a/drivers/scsi/scsi_error.c
+++ b/drivers/scsi/scsi_error.c
@@ -312,7 +312,7 @@ void scsi_eh_scmd_add(struct scsi_cmnd *scmd)
 	 * Ensure that all tasks observe the host state change before the
 	 * host_failed change.
 	 */
-	call_rcu_flush(&scmd->rcu, scsi_eh_inc_host_failed);
+	call_rcu_hurry(&scmd->rcu, scsi_eh_inc_host_failed);
 }
 
 /**
diff --git a/include/linux/rculist_nulls.h b/include/linux/rculist_nulls.h
index ba4c00dd8..d8afdb878 100644
--- a/include/linux/rculist_nulls.h
+++ b/include/linux/rculist_nulls.h
@@ -139,7 +139,7 @@ static inline void hlist_nulls_add_tail_rcu(struct hlist_nulls_node *n,
 	if (last) {
 		n->next = last->next;
 		n->pprev = &last->next;
-		rcu_assign_pointer(hlist_nulls_next_rcu(last), n);
+		rcu_assign_pointer(hlist_next_rcu(last), n);
 	} else {
 		hlist_nulls_add_head_rcu(n, h);
 	}
diff --git a/include/linux/rcupdate.h b/include/linux/rcupdate.h
index 2fde7c1a4..4da98ca62 100644
--- a/include/linux/rcupdate.h
+++ b/include/linux/rcupdate.h
@@ -109,9 +109,9 @@ static inline int rcu_preempt_depth(void)
 #endif /* #else #ifdef CONFIG_PREEMPT_RCU */
 
 #ifdef CONFIG_RCU_LAZY
-void call_rcu_flush(struct rcu_head *head, rcu_callback_t func);
+void call_rcu_hurry(struct rcu_head *head, rcu_callback_t func);
 #else
-static inline void call_rcu_flush(struct rcu_head *head, rcu_callback_t func)
+static inline void call_rcu_hurry(struct rcu_head *head, rcu_callback_t func)
 {
 	call_rcu(head, func);
 }
@@ -349,6 +349,11 @@ static inline int rcu_read_lock_any_held(void)
 	return !preemptible();
 }
 
+static inline int debug_lockdep_rcu_enabled(void)
+{
+	return 0;
+}
+
 #endif /* #else #ifdef CONFIG_DEBUG_LOCK_ALLOC */
 
 #ifdef CONFIG_PROVE_RCU
@@ -994,7 +999,8 @@ do {									\
 									\
 	if (___p) {									\
 		BUILD_BUG_ON(!__is_kvfree_rcu_offset(offsetof(typeof(*(ptr)), rhf)));	\
-		kvfree_call_rcu(&((___p)->rhf), (void *) (___p));			\
+		kvfree_call_rcu(&((___p)->rhf), (rcu_callback_t)(unsigned long)		\
+			(offsetof(typeof(*(ptr)), rhf)));				\
 	}										\
 } while (0)
 
@@ -1003,7 +1009,7 @@ do {								\
 	typeof(ptr) ___p = (ptr);				\
 								\
 	if (___p)						\
-		kvfree_call_rcu(NULL, (void *) (___p));		\
+		kvfree_call_rcu(NULL, (rcu_callback_t) (___p));	\
 } while (0)
 
 /*
diff --git a/include/linux/rcutiny.h b/include/linux/rcutiny.h
index 75282bd92..5c271bf3a 100644
--- a/include/linux/rcutiny.h
+++ b/include/linux/rcutiny.h
@@ -98,25 +98,25 @@ static inline void synchronize_rcu_expedited(void)
  */
 extern void kvfree(const void *addr);
 
-static inline void __kvfree_call_rcu(struct rcu_head *head, void *ptr)
+static inline void __kvfree_call_rcu(struct rcu_head *head, rcu_callback_t func)
 {
 	if (head) {
-		call_rcu(head, (rcu_callback_t) ((void *) head - ptr));
+		call_rcu(head, func);
 		return;
 	}
 
 	// kvfree_rcu(one_arg) call.
 	might_sleep();
 	synchronize_rcu();
-	kvfree(ptr);
+	kvfree((void *) func);
 }
 
 #ifdef CONFIG_KASAN_GENERIC
-void kvfree_call_rcu(struct rcu_head *head, void *ptr);
+void kvfree_call_rcu(struct rcu_head *head, rcu_callback_t func);
 #else
-static inline void kvfree_call_rcu(struct rcu_head *head, void *ptr)
+static inline void kvfree_call_rcu(struct rcu_head *head, rcu_callback_t func)
 {
-	__kvfree_call_rcu(head, ptr);
+	__kvfree_call_rcu(head, func);
 }
 #endif
 
@@ -133,9 +133,8 @@ static inline void rcu_softirq_qs(void)
 		rcu_tasks_qs(current, (preempt)); \
 	} while (0)
 
-static inline int rcu_needs_cpu(u64 basemono, u64 *nextevt)
+static inline int rcu_needs_cpu(void)
 {
-	*nextevt = KTIME_MAX;
 	return 0;
 }
 
diff --git a/include/linux/rcutree.h b/include/linux/rcutree.h
index 091d984ff..4003bf6cf 100644
--- a/include/linux/rcutree.h
+++ b/include/linux/rcutree.h
@@ -19,7 +19,7 @@
 
 void rcu_softirq_qs(void);
 void rcu_note_context_switch(bool preempt);
-int rcu_needs_cpu(u64 basemono, u64 *nextevt);
+int rcu_needs_cpu(void);
 void rcu_cpu_stall_reset(void);
 
 /*
@@ -33,7 +33,7 @@ static inline void rcu_virt_note_context_switch(void)
 }
 
 void synchronize_rcu_expedited(void);
-void kvfree_call_rcu(struct rcu_head *head, void *ptr);
+void kvfree_call_rcu(struct rcu_head *head, rcu_callback_t func);
 
 void rcu_barrier(void);
 bool rcu_eqs_special_set(int cpu);
diff --git a/kernel/kcsan/core.c b/kernel/kcsan/core.c
index 54d077e1a..fe12dfe25 100644
--- a/kernel/kcsan/core.c
+++ b/kernel/kcsan/core.c
@@ -14,12 +14,10 @@
 #include <linux/init.h>
 #include <linux/kernel.h>
 #include <linux/list.h>
-#include <linux/minmax.h>
 #include <linux/moduleparam.h>
 #include <linux/percpu.h>
 #include <linux/preempt.h>
 #include <linux/sched.h>
-#include <linux/string.h>
 #include <linux/uaccess.h>
 
 #include "encoding.h"
@@ -1310,51 +1308,3 @@ noinline void __tsan_atomic_signal_fence(int memorder)
 	}
 }
 EXPORT_SYMBOL(__tsan_atomic_signal_fence);
-
-#ifdef __HAVE_ARCH_MEMSET
-void *__tsan_memset(void *s, int c, size_t count);
-noinline void *__tsan_memset(void *s, int c, size_t count)
-{
-	/*
-	 * Instead of not setting up watchpoints where accessed size is greater
-	 * than MAX_ENCODABLE_SIZE, truncate checked size to MAX_ENCODABLE_SIZE.
-	 */
-	size_t check_len = min_t(size_t, count, MAX_ENCODABLE_SIZE);
-
-	check_access(s, check_len, KCSAN_ACCESS_WRITE, _RET_IP_);
-	return memset(s, c, count);
-}
-#else
-void *__tsan_memset(void *s, int c, size_t count) __alias(memset);
-#endif
-EXPORT_SYMBOL(__tsan_memset);
-
-#ifdef __HAVE_ARCH_MEMMOVE
-void *__tsan_memmove(void *dst, const void *src, size_t len);
-noinline void *__tsan_memmove(void *dst, const void *src, size_t len)
-{
-	size_t check_len = min_t(size_t, len, MAX_ENCODABLE_SIZE);
-
-	check_access(dst, check_len, KCSAN_ACCESS_WRITE, _RET_IP_);
-	check_access(src, check_len, 0, _RET_IP_);
-	return memmove(dst, src, len);
-}
-#else
-void *__tsan_memmove(void *dst, const void *src, size_t len) __alias(memmove);
-#endif
-EXPORT_SYMBOL(__tsan_memmove);
-
-#ifdef __HAVE_ARCH_MEMCPY
-void *__tsan_memcpy(void *dst, const void *src, size_t len);
-noinline void *__tsan_memcpy(void *dst, const void *src, size_t len)
-{
-	size_t check_len = min_t(size_t, len, MAX_ENCODABLE_SIZE);
-
-	check_access(dst, check_len, KCSAN_ACCESS_WRITE, _RET_IP_);
-	check_access(src, check_len, 0, _RET_IP_);
-	return memcpy(dst, src, len);
-}
-#else
-void *__tsan_memcpy(void *dst, const void *src, size_t len) __alias(memcpy);
-#endif
-EXPORT_SYMBOL(__tsan_memcpy);
diff --git a/kernel/rcu/rcuscale.c b/kernel/rcu/rcuscale.c
index 3b149e745..91fb5905a 100644
--- a/kernel/rcu/rcuscale.c
+++ b/kernel/rcu/rcuscale.c
@@ -176,7 +176,7 @@ static struct rcu_scale_ops rcu_ops = {
 	.get_gp_seq	= rcu_get_gp_seq,
 	.gp_diff	= rcu_seq_diff,
 	.exp_completed	= rcu_exp_batches_completed,
-	.async		= call_rcu_flush,
+	.async		= call_rcu_hurry,
 	.gp_barrier	= rcu_barrier,
 	.sync		= synchronize_rcu,
 	.exp_sync	= synchronize_rcu_expedited,
diff --git a/kernel/rcu/rcutorture.c b/kernel/rcu/rcutorture.c
index fd56202ae..634df26a2 100644
--- a/kernel/rcu/rcutorture.c
+++ b/kernel/rcu/rcutorture.c
@@ -514,7 +514,7 @@ static unsigned long rcu_no_completed(void)
 
 static void rcu_torture_deferred_free(struct rcu_torture *p)
 {
-	call_rcu_flush(&p->rtort_rcu, rcu_torture_cb);
+	call_rcu_hurry(&p->rtort_rcu, rcu_torture_cb);
 }
 
 static void rcu_sync_torture_init(void)
@@ -559,7 +559,7 @@ static struct rcu_torture_ops rcu_ops = {
 	.start_gp_poll_exp_full	= start_poll_synchronize_rcu_expedited_full,
 	.poll_gp_state_exp	= poll_state_synchronize_rcu,
 	.cond_sync_exp		= cond_synchronize_rcu_expedited,
-	.call			= call_rcu_flush,
+	.call			= call_rcu_hurry,
 	.cb_barrier		= rcu_barrier,
 	.fqs			= rcu_force_quiescent_state,
 	.stats			= NULL,
@@ -863,7 +863,7 @@ static void rcu_tasks_torture_deferred_free(struct rcu_torture *p)
 
 static void synchronize_rcu_mult_test(void)
 {
-	synchronize_rcu_mult(call_rcu_tasks, call_rcu_flush);
+	synchronize_rcu_mult(call_rcu_tasks, call_rcu_hurry);
 }
 
 static struct rcu_torture_ops tasks_ops = {
@@ -3432,13 +3432,13 @@ static void rcu_test_debug_objects(void)
 	/* Try to queue the rh2 pair of callbacks for the same grace period. */
 	preempt_disable(); /* Prevent preemption from interrupting test. */
 	rcu_read_lock(); /* Make it impossible to finish a grace period. */
-	call_rcu_flush(&rh1, rcu_torture_leak_cb); /* Start grace period. */
+	call_rcu_hurry(&rh1, rcu_torture_leak_cb); /* Start grace period. */
 	local_irq_disable(); /* Make it harder to start a new grace period. */
-	call_rcu_flush(&rh2, rcu_torture_leak_cb);
-	call_rcu_flush(&rh2, rcu_torture_err_cb); /* Duplicate callback. */
+	call_rcu_hurry(&rh2, rcu_torture_leak_cb);
+	call_rcu_hurry(&rh2, rcu_torture_err_cb); /* Duplicate callback. */
 	if (rhp) {
-		call_rcu_flush(rhp, rcu_torture_leak_cb);
-		call_rcu_flush(rhp, rcu_torture_err_cb); /* Another duplicate callback. */
+		call_rcu_hurry(rhp, rcu_torture_leak_cb);
+		call_rcu_hurry(rhp, rcu_torture_err_cb); /* Another duplicate callback. */
 	}
 	local_irq_enable();
 	rcu_read_unlock();
diff --git a/kernel/rcu/sync.c b/kernel/rcu/sync.c
index bdce3b5d7..e550f9777 100644
--- a/kernel/rcu/sync.c
+++ b/kernel/rcu/sync.c
@@ -44,7 +44,7 @@ static void rcu_sync_func(struct rcu_head *rhp);
 
 static void rcu_sync_call(struct rcu_sync *rsp)
 {
-	call_rcu_flush(&rsp->cb_head, rcu_sync_func);
+	call_rcu_hurry(&rsp->cb_head, rcu_sync_func);
 }
 
 /**
diff --git a/kernel/rcu/tiny.c b/kernel/rcu/tiny.c
index bb8f7d270..72913ce21 100644
--- a/kernel/rcu/tiny.c
+++ b/kernel/rcu/tiny.c
@@ -44,7 +44,7 @@ static struct rcu_ctrlblk rcu_ctrlblk = {
 
 void rcu_barrier(void)
 {
-	wait_rcu_gp(call_rcu_flush);
+	wait_rcu_gp(call_rcu_hurry);
 }
 EXPORT_SYMBOL(rcu_barrier);
 
@@ -246,12 +246,15 @@ bool poll_state_synchronize_rcu(unsigned long oldstate)
 EXPORT_SYMBOL_GPL(poll_state_synchronize_rcu);
 
 #ifdef CONFIG_KASAN_GENERIC
-void kvfree_call_rcu(struct rcu_head *head, void *ptr)
+void kvfree_call_rcu(struct rcu_head *head, rcu_callback_t func)
 {
-	if (head)
+	if (head) {
+		void *ptr = (void *) head - (unsigned long) func;
+
 		kasan_record_aux_stack_noalloc(ptr);
+	}
 
-	__kvfree_call_rcu(head, ptr);
+	__kvfree_call_rcu(head, func);
 }
 EXPORT_SYMBOL_GPL(kvfree_call_rcu);
 #endif
diff --git a/kernel/rcu/tree.c b/kernel/rcu/tree.c
index 591187b63..d04f2192f 100644
--- a/kernel/rcu/tree.c
+++ b/kernel/rcu/tree.c
@@ -670,40 +670,12 @@ void __rcu_irq_enter_check_tick(void)
  * scheduler-clock interrupt.
  *
  * Just check whether or not this CPU has non-offloaded RCU callbacks
- * queued that need immediate attention.
+ * queued.
  */
-int rcu_needs_cpu(u64 basemono, u64 *nextevt)
+int rcu_needs_cpu(void)
 {
-	unsigned long j;
-	unsigned long jlast;
-	unsigned long jwait;
-	struct rcu_data *rdp = this_cpu_ptr(&rcu_data);
-	struct rcu_segcblist *rsclp = &rdp->cblist;
-
-	// Disabled, empty, or offloaded means nothing to do.
-	if (!rcu_segcblist_is_enabled(rsclp) ||
-	    rcu_segcblist_empty(rsclp) || rcu_rdp_is_offloaded(rdp)) {
-		*nextevt = KTIME_MAX;
-		return 0;
-	}
-
-	// Callbacks ready to invoke or that have not already been
-	// assigned a grace period need immediate attention.
-	if (!rcu_segcblist_segempty(rsclp, RCU_DONE_TAIL) ||
-	    !rcu_segcblist_segempty(rsclp, RCU_NEXT_TAIL))
-		return 1;
-
-	// There are callbacks waiting for some later grace period.
-	// Wait for about a grace period or two since the last tick, at which
-	// point there is high probability that this CPU will need to do some
-	// work for RCU.
-	j = jiffies;
-	jlast = __this_cpu_read(rcu_data.last_sched_clock);
-	jwait = READ_ONCE(jiffies_till_first_fqs) + READ_ONCE(jiffies_till_next_fqs) + 1;
-	if (time_after(j, jlast + jwait))
-		return 1;
-	*nextevt = basemono + TICK_NSEC * (jlast + jwait - j);
-	return 0;
+	return !rcu_segcblist_empty(&this_cpu_ptr(&rcu_data)->cblist) &&
+		!rcu_rdp_is_offloaded(this_cpu_ptr(&rcu_data));
 }
 
 /*
@@ -2348,10 +2320,12 @@ void rcu_sched_clock_irq(int user)
 {
 	unsigned long j;
 
+	if (IS_ENABLED(CONFIG_PROVE_RCU)) {
+		j = jiffies;
+		WARN_ON_ONCE(time_before(j, __this_cpu_read(rcu_data.last_sched_clock)));
+		__this_cpu_write(rcu_data.last_sched_clock, j);
+	}
 	trace_rcu_utilization(TPS("Start scheduler-tick"));
-	j = jiffies;
-	WARN_ON_ONCE(time_before(j, __this_cpu_read(rcu_data.last_sched_clock)));
-	__this_cpu_write(rcu_data.last_sched_clock, j);
 	lockdep_assert_irqs_disabled();
 	raw_cpu_inc(rcu_data.ticks_this_gp);
 	/* The load-acquire pairs with the store-release setting to true. */
@@ -2817,7 +2791,7 @@ __call_rcu_common(struct rcu_head *head, rcu_callback_t func, bool lazy)
 
 #ifdef CONFIG_RCU_LAZY
 /**
- * call_rcu_flush() - Queue RCU callback for invocation after grace period, and
+ * call_rcu_hurry() - Queue RCU callback for invocation after grace period, and
  * flush all lazy callbacks (including the new one) to the main ->cblist while
  * doing so.
  *
@@ -2836,18 +2810,18 @@ __call_rcu_common(struct rcu_head *head, rcu_callback_t func, bool lazy)
  * reuses call_rcu()'s logic. Refer to call_rcu() for more details about memory
  * ordering and other functionality.
  */
-void call_rcu_flush(struct rcu_head *head, rcu_callback_t func)
+void call_rcu_hurry(struct rcu_head *head, rcu_callback_t func)
 {
 	return __call_rcu_common(head, func, false);
 }
-EXPORT_SYMBOL_GPL(call_rcu_flush);
+EXPORT_SYMBOL_GPL(call_rcu_hurry);
 #endif
 
 /**
  * call_rcu() - Queue an RCU callback for invocation after a grace period.
  * By default the callbacks are 'lazy' and are kept hidden from the main
  * ->cblist to prevent starting of grace periods too soon.
- * If you desire grace periods to start very soon, use call_rcu_flush().
+ * If you desire grace periods to start very soon, use call_rcu_hurry().
  *
  * @head: structure to be used for queueing the RCU updates.
  * @func: actual callback function to be invoked after the grace period
@@ -3127,8 +3101,8 @@ static void kfree_rcu_work(struct work_struct *work)
 	 * This list is named "Channel 3".
 	 */
 	for (; head; head = next) {
-		void *ptr = (void *) head->func;
-		unsigned long offset = (void *) head - ptr;
+		unsigned long offset = (unsigned long)head->func;
+		void *ptr = (void *)head - offset;
 
 		next = head->next;
 		debug_rcu_head_unqueue((struct rcu_head *)ptr);
@@ -3366,21 +3340,26 @@ add_ptr_to_bulk_krc_lock(struct kfree_rcu_cpu **krcp,
  * be free'd in workqueue context. This allows us to: batch requests together to
  * reduce the number of grace periods during heavy kfree_rcu()/kvfree_rcu() load.
  */
-void kvfree_call_rcu(struct rcu_head *head, void *ptr)
+void kvfree_call_rcu(struct rcu_head *head, rcu_callback_t func)
 {
 	unsigned long flags;
 	struct kfree_rcu_cpu *krcp;
 	bool success;
+	void *ptr;
 
-	/*
-	 * Please note there is a limitation for the head-less
-	 * variant, that is why there is a clear rule for such
-	 * objects: it can be used from might_sleep() context
-	 * only. For other places please embed an rcu_head to
-	 * your data.
-	 */
-	if (!head)
+	if (head) {
+		ptr = (void *) head - (unsigned long) func;
+	} else {
+		/*
+		 * Please note there is a limitation for the head-less
+		 * variant, that is why there is a clear rule for such
+		 * objects: it can be used from might_sleep() context
+		 * only. For other places please embed an rcu_head to
+		 * your data.
+		 */
 		might_sleep();
+		ptr = (unsigned long *) func;
+	}
 
 	// Queue the object but don't yet schedule the batch.
 	if (debug_rcu_head_queue(ptr)) {
@@ -3401,7 +3380,7 @@ void kvfree_call_rcu(struct rcu_head *head, void *ptr)
 			// Inline if kvfree_rcu(one_arg) call.
 			goto unlock_return;
 
-		head->func = ptr;
+		head->func = func;
 		head->next = krcp->head;
 		krcp->head = head;
 		success = true;
@@ -3561,7 +3540,7 @@ void synchronize_rcu(void)
 		if (rcu_gp_is_expedited())
 			synchronize_rcu_expedited();
 		else
-			wait_rcu_gp(call_rcu_flush);
+			wait_rcu_gp(call_rcu_hurry);
 		return;
 	}
 
diff --git a/kernel/rcu/tree_exp.h b/kernel/rcu/tree_exp.h
index 5cac05600..ed6c3cce2 100644
--- a/kernel/rcu/tree_exp.h
+++ b/kernel/rcu/tree_exp.h
@@ -937,7 +937,7 @@ void synchronize_rcu_expedited(void)
 
 	/* If expedited grace periods are prohibited, fall back to normal. */
 	if (rcu_gp_is_normal()) {
-		wait_rcu_gp(call_rcu_flush);
+		wait_rcu_gp(call_rcu_hurry);
 		return;
 	}
 
diff --git a/kernel/time/clocksource.c b/kernel/time/clocksource.c
index dcaf38c06..8058bec87 100644
--- a/kernel/time/clocksource.c
+++ b/kernel/time/clocksource.c
@@ -386,7 +386,7 @@ EXPORT_SYMBOL_GPL(clocksource_verify_percpu);
 
 static void clocksource_watchdog(struct timer_list *unused)
 {
-	u64 csnow, wdnow, cslast, wdlast, delta, wdi;
+	u64 csnow, wdnow, cslast, wdlast, delta;
 	int next_cpu, reset_pending;
 	int64_t wd_nsec, cs_nsec;
 	struct clocksource *cs;
@@ -440,17 +440,6 @@ static void clocksource_watchdog(struct timer_list *unused)
 		if (atomic_read(&watchdog_reset_pending))
 			continue;
 
-		/* Check for bogus measurements. */
-		wdi = jiffies_to_nsecs(WATCHDOG_INTERVAL);
-		if (wd_nsec < (wdi >> 2)) {
-			pr_warn("timekeeping watchdog on CPU%d: Watchdog clocksource '%s' advanced only %lld ns during %d-jiffy time interval, skipping watchdog check.\n", smp_processor_id(), watchdog->name, wd_nsec, WATCHDOG_INTERVAL);
-			continue;
-		}
-		if (wd_nsec > (wdi << 2)) {
-			pr_warn("timekeeping watchdog on CPU%d: Watchdog clocksource '%s' advanced an excessive %lld ns during %d-jiffy time interval, probable CPU overutilization, skipping watchdog check.\n", smp_processor_id(), watchdog->name, wd_nsec, WATCHDOG_INTERVAL);
-			continue;
-		}
-
 		/* Check the deviation from the watchdog clocksource. */
 		md = cs->uncertainty_margin + watchdog->uncertainty_margin;
 		if (abs(cs_nsec - wd_nsec) > md) {
diff --git a/kernel/time/tick-sched.c b/kernel/time/tick-sched.c
index 303ea15cd..b0e3c9205 100644
--- a/kernel/time/tick-sched.c
+++ b/kernel/time/tick-sched.c
@@ -784,7 +784,7 @@ static inline bool local_timer_softirq_pending(void)
 
 static ktime_t tick_nohz_next_event(struct tick_sched *ts, int cpu)
 {
-	u64 basemono, next_tick, next_tmr, next_rcu, delta, expires;
+	u64 basemono, next_tick, delta, expires;
 	unsigned long basejiff;
 	unsigned int seq;
 
@@ -807,7 +807,7 @@ static ktime_t tick_nohz_next_event(struct tick_sched *ts, int cpu)
 	 * minimal delta which brings us back to this place
 	 * immediately. Lather, rinse and repeat...
 	 */
-	if (rcu_needs_cpu(basemono, &next_rcu) || arch_needs_cpu() ||
+	if (rcu_needs_cpu() || arch_needs_cpu() ||
 	    irq_work_needs_cpu() || local_timer_softirq_pending()) {
 		next_tick = basemono + TICK_NSEC;
 	} else {
@@ -818,10 +818,8 @@ static ktime_t tick_nohz_next_event(struct tick_sched *ts, int cpu)
 		 * disabled this also looks at the next expiring
 		 * hrtimer.
 		 */
-		next_tmr = get_next_timer_interrupt(basejiff, basemono);
-		ts->next_timer = next_tmr;
-		/* Take the next rcu event into account */
-		next_tick = next_rcu < next_tmr ? next_rcu : next_tmr;
+		next_tick = get_next_timer_interrupt(basejiff, basemono);
+		ts->next_timer = next_tick;
 	}
 
 	/*
diff --git a/kernel/workqueue.c b/kernel/workqueue.c
index b4b0e828b..07895deca 100644
--- a/kernel/workqueue.c
+++ b/kernel/workqueue.c
@@ -1771,7 +1771,7 @@ bool queue_rcu_work(struct workqueue_struct *wq, struct rcu_work *rwork)
 
 	if (!test_and_set_bit(WORK_STRUCT_PENDING_BIT, work_data_bits(work))) {
 		rwork->wq = wq;
-		call_rcu_flush(&rwork->rcu, rcu_work_rcufn);
+		call_rcu_hurry(&rwork->rcu, rcu_work_rcufn);
 		return true;
 	}
 
diff --git a/lib/Kconfig.kcsan b/lib/Kconfig.kcsan
index 375575a5a..47a693c45 100644
--- a/lib/Kconfig.kcsan
+++ b/lib/Kconfig.kcsan
@@ -125,7 +125,7 @@ config KCSAN_SKIP_WATCH
 	default 4000
 	help
 	  The number of per-CPU memory operations to skip, before another
-	  watchpoint is set up, i.e. one in KCSAN_SKIP_WATCH per-CPU
+	  watchpoint is set up, i.e. one in KCSAN_WATCH_SKIP per-CPU
 	  memory operations are used to set up a watchpoint. A smaller value
 	  results in more aggressive race detection, whereas a larger value
 	  improves system performance at the cost of missing some races.
@@ -135,8 +135,8 @@ config KCSAN_SKIP_WATCH_RANDOMIZE
 	default y
 	help
 	  If instruction skip count should be randomized, where the maximum is
-	  KCSAN_SKIP_WATCH. If false, the chosen value is always
-	  KCSAN_SKIP_WATCH.
+	  KCSAN_WATCH_SKIP. If false, the chosen value is always
+	  KCSAN_WATCH_SKIP.
 
 config KCSAN_INTERRUPT_WATCHER
 	bool "Interruptible watchers" if !KCSAN_STRICT
diff --git a/lib/percpu-refcount.c b/lib/percpu-refcount.c
index 65c58a029..668f6aa6a 100644
--- a/lib/percpu-refcount.c
+++ b/lib/percpu-refcount.c
@@ -230,7 +230,7 @@ static void __percpu_ref_switch_to_atomic(struct percpu_ref *ref,
 		percpu_ref_noop_confirm_switch;
 
 	percpu_ref_get(ref);	/* put after confirmation */
-	call_rcu_flush(&ref->data->rcu,
+	call_rcu_hurry(&ref->data->rcu,
 		       percpu_ref_switch_to_atomic_rcu);
 }
 
diff --git a/net/core/dst.c b/net/core/dst.c
index bc9c9be4e..a4e738d32 100644
--- a/net/core/dst.c
+++ b/net/core/dst.c
@@ -174,7 +174,7 @@ void dst_release(struct dst_entry *dst)
 			net_warn_ratelimited("%s: dst:%p refcnt:%d\n",
 					     __func__, dst, newrefcnt);
 		if (!newrefcnt)
-			call_rcu(&dst->rcu_head, dst_destroy_rcu);
+			call_rcu_hurry(&dst->rcu_head, dst_destroy_rcu);
 	}
 }
 EXPORT_SYMBOL(dst_release);
diff --git a/net/ipv4/devinet.c b/net/ipv4/devinet.c
index e8b9a9202..b0acf6e19 100644
--- a/net/ipv4/devinet.c
+++ b/net/ipv4/devinet.c
@@ -234,13 +234,20 @@ static void inet_free_ifa(struct in_ifaddr *ifa)
 	call_rcu(&ifa->rcu_head, inet_rcu_free_ifa);
 }
 
+static void in_dev_free_rcu(struct rcu_head *head)
+{
+	struct in_device *idev = container_of(head, struct in_device, rcu_head);
+
+	kfree(rcu_dereference_protected(idev->mc_hash, 1));
+	kfree(idev);
+}
+
 void in_dev_finish_destroy(struct in_device *idev)
 {
 	struct net_device *dev = idev->dev;
 
 	WARN_ON(idev->ifa_list);
 	WARN_ON(idev->mc_list);
-	kfree(rcu_dereference_protected(idev->mc_hash, 1));
 #ifdef NET_REFCNT_DEBUG
 	pr_debug("%s: %p=%s\n", __func__, idev, dev ? dev->name : "NIL");
 #endif
@@ -248,7 +255,7 @@ void in_dev_finish_destroy(struct in_device *idev)
 	if (!idev->dead)
 		pr_err("Freeing alive in_device %p\n", idev);
 	else
-		kfree(idev);
+		call_rcu(&idev->rcu_head, in_dev_free_rcu);
 }
 EXPORT_SYMBOL(in_dev_finish_destroy);
 
@@ -298,12 +305,6 @@ static struct in_device *inetdev_init(struct net_device *dev)
 	goto out;
 }
 
-static void in_dev_rcu_put(struct rcu_head *head)
-{
-	struct in_device *idev = container_of(head, struct in_device, rcu_head);
-	in_dev_put(idev);
-}
-
 static void inetdev_destroy(struct in_device *in_dev)
 {
 	struct net_device *dev;
@@ -328,7 +329,7 @@ static void inetdev_destroy(struct in_device *in_dev)
 	neigh_parms_release(&arp_tbl, in_dev->arp_parms);
 	arp_ifdown(dev);
 
-	call_rcu(&in_dev->rcu_head, in_dev_rcu_put);
+	in_dev_put(in_dev);
 }
 
 int inet_addr_onlink(struct in_device *in_dev, __be32 a, __be32 b)
diff --git a/net/rxrpc/conn_object.c b/net/rxrpc/conn_object.c
index fdcfb509c..22089e37e 100644
--- a/net/rxrpc/conn_object.c
+++ b/net/rxrpc/conn_object.c
@@ -253,7 +253,7 @@ void rxrpc_kill_connection(struct rxrpc_connection *conn)
 	 * must carry a ref on the connection to prevent us getting here whilst
 	 * it is queued or running.
 	 */
-	call_rcu_flush(&conn->rcu, rxrpc_destroy_connection);
+	call_rcu(&conn->rcu, rxrpc_destroy_connection);
 }
 
 /*
diff --git a/tools/memory-model/Documentation/explanation.txt b/tools/memory-model/Documentation/explanation.txt
index 11a1d2d4f..ee819a402 100644
--- a/tools/memory-model/Documentation/explanation.txt
+++ b/tools/memory-model/Documentation/explanation.txt
@@ -464,10 +464,9 @@ to address dependencies, since the address of a location accessed
 through a pointer will depend on the value read earlier from that
 pointer.
 
-Finally, a read event X and a write event Y are linked by a control
-dependency if Y syntactically lies within an arm of an if statement and
-X affects the evaluation of the if condition via a data or address
-dependency (or similarly for a switch statement).  Simple example:
+Finally, a read event and another memory access event are linked by a
+control dependency if the value obtained by the read affects whether
+the second event is executed at all.  Simple example:
 
 	int x, y;
 
diff --git a/tools/memory-model/Documentation/locking.txt b/tools/memory-model/Documentation/locking.txt
deleted file mode 100644
index 4e05c6d53..000000000
--- a/tools/memory-model/Documentation/locking.txt
+++ /dev/null
@@ -1,320 +0,0 @@
-Locking
-=======
-
-Locking is well-known and the common use cases are straightforward: Any
-CPU holding a given lock sees any changes previously seen or made by any
-CPU before it previously released that same lock.  This last sentence
-is the only part of this document that most developers will need to read.
-
-However, developers who would like to also access lock-protected shared
-variables outside of their corresponding locks should continue reading.
-
-
-Locking and Prior Accesses
---------------------------
-
-The basic rule of locking is worth repeating:
-
-	Any CPU holding a given lock sees any changes previously seen
-	or made by any CPU before it previously released that same lock.
-
-Note that this statement is a bit stronger than "Any CPU holding a
-given lock sees all changes made by any CPU during the time that CPU was
-previously holding this same lock".  For example, consider the following
-pair of code fragments:
-
-	/* See MP+polocks.litmus. */
-	void CPU0(void)
-	{
-		WRITE_ONCE(x, 1);
-		spin_lock(&mylock);
-		WRITE_ONCE(y, 1);
-		spin_unlock(&mylock);
-	}
-
-	void CPU1(void)
-	{
-		spin_lock(&mylock);
-		r0 = READ_ONCE(y);
-		spin_unlock(&mylock);
-		r1 = READ_ONCE(x);
-	}
-
-The basic rule guarantees that if CPU0() acquires mylock before CPU1(),
-then both r0 and r1 must be set to the value 1.  This also has the
-consequence that if the final value of r0 is equal to 1, then the final
-value of r1 must also be equal to 1.  In contrast, the weaker rule would
-say nothing about the final value of r1.
-
-
-Locking and Subsequent Accesses
--------------------------------
-
-The converse to the basic rule also holds:  Any CPU holding a given
-lock will not see any changes that will be made by any CPU after it
-subsequently acquires this same lock.  This converse statement is
-illustrated by the following litmus test:
-
-	/* See MP+porevlocks.litmus. */
-	void CPU0(void)
-	{
-		r0 = READ_ONCE(y);
-		spin_lock(&mylock);
-		r1 = READ_ONCE(x);
-		spin_unlock(&mylock);
-	}
-
-	void CPU1(void)
-	{
-		spin_lock(&mylock);
-		WRITE_ONCE(x, 1);
-		spin_unlock(&mylock);
-		WRITE_ONCE(y, 1);
-	}
-
-This converse to the basic rule guarantees that if CPU0() acquires
-mylock before CPU1(), then both r0 and r1 must be set to the value 0.
-This also has the consequence that if the final value of r1 is equal
-to 0, then the final value of r0 must also be equal to 0.  In contrast,
-the weaker rule would say nothing about the final value of r0.
-
-These examples show only a single pair of CPUs, but the effects of the
-locking basic rule extend across multiple acquisitions of a given lock
-across multiple CPUs.
-
-
-Double-Checked Locking
-----------------------
-
-It is well known that more than just a lock is required to make
-double-checked locking work correctly,  This litmus test illustrates
-one incorrect approach:
-
-	/* See Documentation/litmus-tests/locking/DCL-broken.litmus. */
-	P0(int *flag, int *data, int *lck)
-	{
-		int r0;
-		int r1;
-		int r2;
-
-		r0 = READ_ONCE(*flag);
-		if (r0 == 0) {
-			spin_lock(lck);
-			r1 = READ_ONCE(*flag);
-			if (r1 == 0) {
-				WRITE_ONCE(*data, 1);
-				WRITE_ONCE(*flag, 1);
-			}
-			spin_unlock(lck);
-		}
-		r2 = READ_ONCE(*data);
-	}
-	/* P1() is the exactly the same as P0(). */
-
-There are two problems.  First, there is no ordering between the first
-READ_ONCE() of "flag" and the READ_ONCE() of "data".  Second, there is
-no ordering between the two WRITE_ONCE() calls.  It should therefore be
-no surprise that "r2" can be zero, and a quick herd7 run confirms this.
-
-One way to fix this is to use smp_load_acquire() and smp_store_release()
-as shown in this corrected version:
-
-	/* See Documentation/litmus-tests/locking/DCL-fixed.litmus. */
-	P0(int *flag, int *data, int *lck)
-	{
-		int r0;
-		int r1;
-		int r2;
-
-		r0 = smp_load_acquire(flag);
-		if (r0 == 0) {
-			spin_lock(lck);
-			r1 = READ_ONCE(*flag);
-			if (r1 == 0) {
-				WRITE_ONCE(*data, 1);
-				smp_store_release(flag, 1);
-			}
-			spin_unlock(lck);
-		}
-		r2 = READ_ONCE(*data);
-	}
-	/* P1() is the exactly the same as P0(). */
-
-The smp_load_acquire() guarantees that its load from "flags" will
-be ordered before the READ_ONCE() from data, thus solving the first
-problem.  The smp_store_release() guarantees that its store will be
-ordered after the WRITE_ONCE() to "data", solving the second problem.
-The smp_store_release() pairs with the smp_load_acquire(), thus ensuring
-that the ordering provided by each actually takes effect.  Again, a
-quick herd7 run confirms this.
-
-In short, if you access a lock-protected variable without holding the
-corresponding lock, you will need to provide additional ordering, in
-this case, via the smp_load_acquire() and the smp_store_release().
-
-
-Ordering Provided by a Lock to CPUs Not Holding That Lock
----------------------------------------------------------
-
-It is not necessarily the case that accesses ordered by locking will be
-seen as ordered by CPUs not holding that lock.  Consider this example:
-
-	/* See Z6.0+pooncelock+pooncelock+pombonce.litmus. */
-	void CPU0(void)
-	{
-		spin_lock(&mylock);
-		WRITE_ONCE(x, 1);
-		WRITE_ONCE(y, 1);
-		spin_unlock(&mylock);
-	}
-
-	void CPU1(void)
-	{
-		spin_lock(&mylock);
-		r0 = READ_ONCE(y);
-		WRITE_ONCE(z, 1);
-		spin_unlock(&mylock);
-	}
-
-	void CPU2(void)
-	{
-		WRITE_ONCE(z, 2);
-		smp_mb();
-		r1 = READ_ONCE(x);
-	}
-
-Counter-intuitive though it might be, it is quite possible to have
-the final value of r0 be 1, the final value of z be 2, and the final
-value of r1 be 0.  The reason for this surprising outcome is that CPU2()
-never acquired the lock, and thus did not fully benefit from the lock's
-ordering properties.
-
-Ordering can be extended to CPUs not holding the lock by careful use
-of smp_mb__after_spinlock():
-
-	/* See Z6.0+pooncelock+poonceLock+pombonce.litmus. */
-	void CPU0(void)
-	{
-		spin_lock(&mylock);
-		WRITE_ONCE(x, 1);
-		WRITE_ONCE(y, 1);
-		spin_unlock(&mylock);
-	}
-
-	void CPU1(void)
-	{
-		spin_lock(&mylock);
-		smp_mb__after_spinlock();
-		r0 = READ_ONCE(y);
-		WRITE_ONCE(z, 1);
-		spin_unlock(&mylock);
-	}
-
-	void CPU2(void)
-	{
-		WRITE_ONCE(z, 2);
-		smp_mb();
-		r1 = READ_ONCE(x);
-	}
-
-This addition of smp_mb__after_spinlock() strengthens the lock
-acquisition sufficiently to rule out the counter-intuitive outcome.
-In other words, the addition of the smp_mb__after_spinlock() prohibits
-the counter-intuitive result where the final value of r0 is 1, the final
-value of z is 2, and the final value of r1 is 0.
-
-
-No Roach-Motel Locking!
------------------------
-
-This example requires familiarity with the herd7 "filter" clause, so
-please read up on that topic in litmus-tests.txt.
-
-It is tempting to allow memory-reference instructions to be pulled
-into a critical section, but this cannot be allowed in the general case.
-For example, consider a spin loop preceding a lock-based critical section.
-Now, herd7 does not model spin loops, but we can emulate one with two
-loads, with a "filter" clause to constrain the first to return the
-initial value and the second to return the updated value, as shown below:
-
-	/* See Documentation/litmus-tests/locking/RM-fixed.litmus. */
-	P0(int *x, int *y, int *lck)
-	{
-		int r2;
-
-		spin_lock(lck);
-		r2 = atomic_inc_return(y);
-		WRITE_ONCE(*x, 1);
-		spin_unlock(lck);
-	}
-
-	P1(int *x, int *y, int *lck)
-	{
-		int r0;
-		int r1;
-		int r2;
-
-		r0 = READ_ONCE(*x);
-		r1 = READ_ONCE(*x);
-		spin_lock(lck);
-		r2 = atomic_inc_return(y);
-		spin_unlock(lck);
-	}
-
-	filter (y=2 /\ 1:r0=0 /\ 1:r1=1)
-	exists (1:r2=1)
-
-The variable "x" is the control variable for the emulated spin loop.
-P0() sets it to "1" while holding the lock, and P1() emulates the
-spin loop by reading it twice, first into "1:r0" (which should get the
-initial value "0") and then into "1:r1" (which should get the updated
-value "1").
-
-The purpose of the variable "y" is to reject deadlocked executions.
-Only those executions where the final value of "y" have avoided deadlock.
-
-The "filter" clause takes all this into account, constraining "y" to
-equal "2", "1:r0" to equal "0", and "1:r1" to equal 1.
-
-Then the "exists" clause checks to see if P1() acquired its lock first,
-which should not happen given the filter clause because P0() updates
-"x" while holding the lock.  And herd7 confirms this.
-
-But suppose that the compiler was permitted to reorder the spin loop
-into P1()'s critical section, like this:
-
-	/* See Documentation/litmus-tests/locking/RM-broken.litmus. */
-	P0(int *x, int *y, int *lck)
-	{
-		int r2;
-
-		spin_lock(lck);
-		r2 = atomic_inc_return(y);
-		WRITE_ONCE(*x, 1);
-		spin_unlock(lck);
-	}
-
-	P1(int *x, int *y, int *lck)
-	{
-		int r0;
-		int r1;
-		int r2;
-
-		spin_lock(lck);
-		r0 = READ_ONCE(*x);
-		r1 = READ_ONCE(*x);
-		r2 = atomic_inc_return(y);
-		spin_unlock(lck);
-	}
-
-	locations [x;lck;0:r2;1:r0;1:r1;1:r2]
-	filter (y=2 /\ 1:r0=0 /\ 1:r1=1)
-	exists (1:r2=1)
-
-If "1:r0" is equal to "0", "1:r1" can never equal "1" because P0()
-cannot update "x" while P1() holds the lock.  And herd7 confirms this,
-showing zero executions matching the "filter" criteria.
-
-And this is why Linux-kernel lock and unlock primitives must prevent
-code from entering critical sections.  It is not sufficient to only
-prevent code from leaving them.
diff --git a/tools/memory-model/linux-kernel.bell b/tools/memory-model/linux-kernel.bell
index 65c32ca9d..5be86b102 100644
--- a/tools/memory-model/linux-kernel.bell
+++ b/tools/memory-model/linux-kernel.bell
@@ -56,11 +56,17 @@ let rcu-rscs = let rec
 flag ~empty Rcu-lock \ domain(rcu-rscs) as unbalanced-rcu-locking
 flag ~empty Rcu-unlock \ range(rcu-rscs) as unbalanced-rcu-locking
 
-(* Compute matching pairs of Srcu-lock and Srcu-unlock, but prohibit nesting *)
-let srcu-unmatched = Srcu-lock | Srcu-unlock
-let srcu-unmatched-po = ([srcu-unmatched] ; po ; [srcu-unmatched]) & loc
-let srcu-unmatched-locks-to-unlock = ([Srcu-lock] ; po ; [Srcu-unlock]) & loc
-let srcu-rscs = srcu-unmatched-locks-to-unlock \ (srcu-unmatched-po ; srcu-unmatched-po)
+(* Compute matching pairs of nested Srcu-lock and Srcu-unlock *)
+let srcu-rscs = let rec
+	    unmatched-locks = Srcu-lock \ domain(matched)
+	and unmatched-unlocks = Srcu-unlock \ range(matched)
+	and unmatched = unmatched-locks | unmatched-unlocks
+	and unmatched-po = ([unmatched] ; po ; [unmatched]) & loc
+	and unmatched-locks-to-unlocks =
+		([unmatched-locks] ; po ; [unmatched-unlocks]) & loc
+	and matched = matched | (unmatched-locks-to-unlocks \
+		(unmatched-po ; unmatched-po))
+	in matched
 
 (* Validate nesting *)
 flag ~empty Srcu-lock \ domain(srcu-rscs) as unbalanced-srcu-locking
diff --git a/tools/memory-model/litmus-tests/.gitignore b/tools/memory-model/litmus-tests/.gitignore
index 19c379cf0..c492a1dda 100644
--- a/tools/memory-model/litmus-tests/.gitignore
+++ b/tools/memory-model/litmus-tests/.gitignore
@@ -1,2 +1,2 @@
 # SPDX-License-Identifier: GPL-2.0-only
-*.litmus.*
+*.litmus.out
diff --git a/tools/memory-model/scripts/README b/tools/memory-model/scripts/README
index cc2c4e5be..095c7eb36 100644
--- a/tools/memory-model/scripts/README
+++ b/tools/memory-model/scripts/README
@@ -27,14 +27,6 @@ checklitmushist.sh
 checklitmus.sh
 
 	Check a single litmus test against its "Result:" expected result.
-	Not intended to for manual use.
-
-checktheselitmus.sh
-
-	Check the specified list of litmus tests against their "Result:"
-	expected results.  This takes optional parseargs.sh arguments,
-	followed by "--" followed by pathnames starting from the current
-	directory.
 
 cmplitmushist.sh
 
@@ -51,10 +43,10 @@ initlitmushist.sh
 
 judgelitmus.sh
 
-	Given a .litmus file and its herd7 output, check the output file
-	against the .litmus file's "Result:" comment to judge whether
-	the test ran correctly.  Not normally run manually, provided
-	instead for use by other scripts.
+	Given a .litmus file and its .litmus.out herd7 output, check the
+	.litmus.out file against the .litmus file's "Result:" comment to
+	judge whether the test ran correctly.  Not normally run manually,
+	provided instead for use by other scripts.
 
 newlitmushist.sh
 
diff --git a/tools/memory-model/scripts/checkalllitmus.sh b/tools/memory-model/scripts/checkalllitmus.sh
index 2d3ee850a..3c0c7fbbd 100755
--- a/tools/memory-model/scripts/checkalllitmus.sh
+++ b/tools/memory-model/scripts/checkalllitmus.sh
@@ -1,4 +1,4 @@
-#!/bin/bash
+#!/bin/sh
 # SPDX-License-Identifier: GPL-2.0+
 #
 # Run herd7 tests on all .litmus files in the litmus-tests directory
@@ -8,11 +8,6 @@
 # "^^^".  It also outputs verification results to a file whose name is
 # that of the specified litmus test, but with ".out" appended.
 #
-# If the --hw argument is specified, this script translates the .litmus
-# C-language file to the specified type of assembly and verifies that.
-# But in this case, litmus tests using complex synchronization (such as
-# locking, RCU, and SRCU) are cheerfully ignored.
-#
 # Usage:
 #	checkalllitmus.sh
 #
@@ -22,7 +17,7 @@
 #
 # Copyright IBM Corporation, 2018
 #
-# Author: Paul E. McKenney <paulmck@linux.ibm.com>
+# Author: Paul E. McKenney <paulmck@linux.vnet.ibm.com>
 
 . scripts/parseargs.sh
 
@@ -35,23 +30,29 @@ else
 	exit 255
 fi
 
-# Create any new directories that have appeared in the litmus-tests
-# directory since the last run.
+# Create any new directories that have appeared in the github litmus
+# repo since the last run.
 if test "$LKMM_DESTDIR" != "."
 then
 	find $litmusdir -type d -print |
 	( cd "$LKMM_DESTDIR"; sed -e 's/^/mkdir -p /' | sh )
 fi
 
+# Find the checklitmus script.  If it is not where we expect it, then
+# assume that the caller has the PATH environment variable set
+# appropriately.
+if test -x scripts/checklitmus.sh
+then
+	clscript=scripts/checklitmus.sh
+else
+	clscript=checklitmus.sh
+fi
+
 # Run the script on all the litmus tests in the specified directory
 ret=0
 for i in $litmusdir/*.litmus
 do
-	if test -n "$LKMM_HW_MAP_FILE" && ! scripts/simpletest.sh $i
-	then
-		continue
-	fi
-	if ! scripts/checklitmus.sh $i
+	if ! $clscript $i
 	then
 		ret=1
 	fi
diff --git a/tools/memory-model/scripts/checkghlitmus.sh b/tools/memory-model/scripts/checkghlitmus.sh
index cedd0290b..6589fbb6f 100755
--- a/tools/memory-model/scripts/checkghlitmus.sh
+++ b/tools/memory-model/scripts/checkghlitmus.sh
@@ -10,7 +10,6 @@
 # parseargs.sh scripts for arguments.
 
 . scripts/parseargs.sh
-. scripts/hwfnseg.sh
 
 T=/tmp/checkghlitmus.sh.$$
 trap 'rm -rf $T' 0
@@ -33,19 +32,19 @@ then
 	( cd "$LKMM_DESTDIR"; sed -e 's/^/mkdir -p /' | sh )
 fi
 
-# Create a list of the specified litmus tests previously run.
-( cd $LKMM_DESTDIR; find litmus -name "*.litmus${hwfnseg}.out" -print ) |
-	sed -e "s/${hwfnseg}"'\.out$//' |
+# Create a list of the C-language litmus tests previously run.
+( cd $LKMM_DESTDIR; find litmus -name '*.litmus.out' -print ) |
+	sed -e 's/\.out$//' |
 	xargs -r egrep -l '^ \* Result: (Never|Sometimes|Always|DEADLOCK)' |
 	xargs -r grep -L "^P${LKMM_PROCS}"> $T/list-C-already
 
 # Create a list of C-language litmus tests with "Result:" commands and
 # no more than the specified number of processes.
-find litmus -name '*.litmus' -print | mselect7 -arch C > $T/list-C
+find litmus -name '*.litmus' -exec grep -l -m 1 "^C " {} \; > $T/list-C
 xargs < $T/list-C -r egrep -l '^ \* Result: (Never|Sometimes|Always|DEADLOCK)' > $T/list-C-result
 xargs < $T/list-C-result -r grep -L "^P${LKMM_PROCS}" > $T/list-C-result-short
 
-# Form list of tests without corresponding .out files
+# Form list of tests without corresponding .litmus.out files
 sort $T/list-C-already $T/list-C-result-short | uniq -u > $T/list-C-needed
 
 # Run any needed tests.
diff --git a/tools/memory-model/scripts/checklitmus.sh b/tools/memory-model/scripts/checklitmus.sh
index 4c1d0cf0d..11461ed40 100755
--- a/tools/memory-model/scripts/checklitmus.sh
+++ b/tools/memory-model/scripts/checklitmus.sh
@@ -1,8 +1,10 @@
 #!/bin/sh
 # SPDX-License-Identifier: GPL-2.0+
 #
-# Invokes runlitmus.sh and judgelitmus.sh on its arguments to run the
-# specified litmus test and pass judgment on the results.
+# Run a herd7 test and invokes judgelitmus.sh to check the result against
+# a "Result:" comment within the litmus test.  It also outputs verification
+# results to a file whose name is that of the specified litmus test, but
+# with ".out" appended.
 #
 # Usage:
 #	checklitmus.sh file.litmus
@@ -13,7 +15,20 @@
 #
 # Copyright IBM Corporation, 2018
 #
-# Author: Paul E. McKenney <paulmck@linux.ibm.com>
+# Author: Paul E. McKenney <paulmck@linux.vnet.ibm.com>
 
-scripts/runlitmus.sh $1
-scripts/judgelitmus.sh $1
+litmus=$1
+herdoptions=${LKMM_HERD_OPTIONS--conf linux-kernel.cfg}
+
+if test -f "$litmus" -a -r "$litmus"
+then
+	:
+else
+	echo ' --- ' error: \"$litmus\" is not a readable file
+	exit 255
+fi
+
+echo Herd options: $herdoptions > $LKMM_DESTDIR/$litmus.out
+/usr/bin/time $LKMM_TIMEOUT_CMD herd7 $herdoptions $litmus >> $LKMM_DESTDIR/$litmus.out 2>&1
+
+scripts/judgelitmus.sh $litmus
diff --git a/tools/memory-model/scripts/checklitmushist.sh b/tools/memory-model/scripts/checklitmushist.sh
index 406ecfc0a..1d210ffb7 100755
--- a/tools/memory-model/scripts/checklitmushist.sh
+++ b/tools/memory-model/scripts/checklitmushist.sh
@@ -12,7 +12,7 @@
 #
 # Copyright IBM Corporation, 2018
 #
-# Author: Paul E. McKenney <paulmck@linux.ibm.com>
+# Author: Paul E. McKenney <paulmck@linux.vnet.ibm.com>
 
 . scripts/parseargs.sh
 
diff --git a/tools/memory-model/scripts/checktheselitmus.sh b/tools/memory-model/scripts/checktheselitmus.sh
deleted file mode 100755
index 10eeb5ece..000000000
--- a/tools/memory-model/scripts/checktheselitmus.sh
+++ /dev/null
@@ -1,43 +0,0 @@
-#!/bin/sh
-# SPDX-License-Identifier: GPL-2.0+
-#
-# Invokes checklitmus.sh on its arguments to run the specified litmus
-# test and pass judgment on the results.
-#
-# Usage:
-#	checktheselitmus.sh -- [ file1.litmus [ file2.litmus ... ] ]
-#
-# Run this in the directory containing the memory model, specifying the
-# pathname of the litmus test to check.  The usual parseargs.sh arguments
-# can be specified prior to the "--".
-#
-# This script is intended for use with pathnames that start from the
-# tools/memory-model directory.  If some of the pathnames instead start at
-# the root directory, they all must do so and the "--destdir /" parseargs.sh
-# argument must be specified prior to the "--".  Alternatively, some other
-# "--destdir" argument can be supplied as long as the needed subdirectories
-# are populated.
-#
-# Copyright IBM Corporation, 2018
-#
-# Author: Paul E. McKenney <paulmck@linux.ibm.com>
-
-. scripts/parseargs.sh
-
-ret=0
-for i in "$@"
-do
-	if scripts/checklitmus.sh $i
-	then
-		:
-	else
-		ret=1
-	fi
-done
-if test "$ret" -ne 0
-then
-	echo " ^^^ VERIFICATION MISMATCHES" 1>&2
-else
-	echo All litmus tests verified as was expected. 1>&2
-fi
-exit $ret
diff --git a/tools/memory-model/scripts/cmplitmushist.sh b/tools/memory-model/scripts/cmplitmushist.sh
index ca1ac8b64..0f498aeec 100755
--- a/tools/memory-model/scripts/cmplitmushist.sh
+++ b/tools/memory-model/scripts/cmplitmushist.sh
@@ -12,49 +12,12 @@ trap 'rm -rf $T' 0
 mkdir $T
 
 # comparetest oldpath newpath
-badmacnam=0
-timedout=0
 perfect=0
 obsline=0
 noobsline=0
 obsresult=0
 badcompare=0
 comparetest () {
-	if grep -q ': Unknown macro ' $1 || grep -q ': Unknown macro ' $2
-	then
-		if grep -q ': Unknown macro ' $1
-		then
-			badname=`grep ': Unknown macro ' $1 |
-				sed -e 's/^.*: Unknown macro //' |
-				sed -e 's/ (User error).*$//'`
-			echo 'Current LKMM version does not know "'$badname'"' $1
-		fi
-		if grep -q ': Unknown macro ' $2
-		then
-			badname=`grep ': Unknown macro ' $2 |
-				sed -e 's/^.*: Unknown macro //' |
-				sed -e 's/ (User error).*$//'`
-			echo 'Current LKMM version does not know "'$badname'"' $2
-		fi
-		badmacnam=`expr "$badmacnam" + 1`
-		return 0
-	elif grep -q '^Command exited with non-zero status 124' $1 ||
-	     grep -q '^Command exited with non-zero status 124' $2
-	then
-		if grep -q '^Command exited with non-zero status 124' $1 &&
-		   grep -q '^Command exited with non-zero status 124' $2
-		then
-			echo Both runs timed out: $2
-		elif grep -q '^Command exited with non-zero status 124' $1
-		then
-			echo Old run timed out: $2
-		elif grep -q '^Command exited with non-zero status 124' $2
-		then
-			echo New run timed out: $2
-		fi
-		timedout=`expr "$timedout" + 1`
-		return 0
-	fi
 	grep -v 'maxresident)k\|minor)pagefaults\|^Time' $1 > $T/oldout
 	grep -v 'maxresident)k\|minor)pagefaults\|^Time' $2 > $T/newout
 	if cmp -s $T/oldout $T/newout && grep -q '^Observation' $1
@@ -75,7 +38,7 @@ comparetest () {
 			return 0
 		fi
 	else
-		echo Missing Observation line "(e.g., syntax error)": $2
+		echo Missing Observation line "(e.g., herd7 timeout)": $2
 		noobsline=`expr "$noobsline" + 1`
 		return 0
 	fi
@@ -109,20 +72,12 @@ then
 fi
 if test "$noobsline" -ne 0
 then
-	echo Missing Observation line "(e.g., syntax error)": $noobsline 1>&2
+	echo Missing Observation line "(e.g., herd7 timeout)": $noobsline 1>&2
 fi
 if test "$obsresult" -ne 0
 then
 	echo Matching Observation Always/Sometimes/Never result: $obsresult 1>&2
 fi
-if test "$timedout" -ne 0
-then
-	echo "!!!" Timed out: $timedout 1>&2
-fi
-if test "$badmacnam" -ne 0
-then
-	echo "!!!" Unknown primitive: $badmacnam 1>&2
-fi
 if test "$badcompare" -ne 0
 then
 	echo "!!!" Result changed: $badcompare 1>&2
diff --git a/tools/memory-model/scripts/hwfnseg.sh b/tools/memory-model/scripts/hwfnseg.sh
deleted file mode 100755
index 580c32811..000000000
--- a/tools/memory-model/scripts/hwfnseg.sh
+++ /dev/null
@@ -1,20 +0,0 @@
-#!/bin/sh
-# SPDX-License-Identifier: GPL-2.0+
-#
-# Generate the hardware extension to the litmus-test filename, or the
-# empty string if this is an LKMM run.  The extension is placed in
-# the shell variable hwfnseg.
-#
-# Usage:
-#	. hwfnseg.sh
-#
-# Copyright IBM Corporation, 2019
-#
-# Author: Paul E. McKenney <paulmck@linux.ibm.com>
-
-if test -z "$LKMM_HW_MAP_FILE"
-then
-	hwfnseg=
-else
-	hwfnseg=".$LKMM_HW_MAP_FILE"
-fi
diff --git a/tools/memory-model/scripts/initlitmushist.sh b/tools/memory-model/scripts/initlitmushist.sh
index 31ea78295..956b69574 100755
--- a/tools/memory-model/scripts/initlitmushist.sh
+++ b/tools/memory-model/scripts/initlitmushist.sh
@@ -60,7 +60,7 @@ fi
 
 # Create a list of the C-language litmus tests with no more than the
 # specified number of processes (per the --procs argument).
-find litmus -name '*.litmus' -print | mselect7 -arch C > $T/list-C
+find litmus -name '*.litmus' -exec grep -l -m 1 "^C " {} \; > $T/list-C
 xargs < $T/list-C -r grep -L "^P${LKMM_PROCS}" > $T/list-C-short
 
 scripts/runlitmushist.sh < $T/list-C-short
diff --git a/tools/memory-model/scripts/judgelitmus.sh b/tools/memory-model/scripts/judgelitmus.sh
index 1ec5d89fc..0cc63875e 100755
--- a/tools/memory-model/scripts/judgelitmus.sh
+++ b/tools/memory-model/scripts/judgelitmus.sh
@@ -1,22 +1,9 @@
 #!/bin/sh
 # SPDX-License-Identifier: GPL-2.0+
 #
-# Given a .litmus test and the corresponding litmus output file, check
-# the .litmus.out file against the "Result:" comment to judge whether the
-# test ran correctly.  If the --hw argument is omitted, check against the
-# LKMM output, which is assumed to be in file.litmus.out. If either a
-# "DATARACE" marker in the "Result:" comment or a "Flag data-race" marker
-# in the LKMM output is present, the other must also be as well, at least
-# for litmus tests having a "Result:" comment. In this case, a failure of
-# the Always/Sometimes/Never portion of the "Result:" prediction will be
-# noted, but forgiven.
-#
-# If the --hw argument is provided, this is assumed to be a hardware
-# test, and the output is assumed to be in file.litmus.HW.out, where
-# "HW" is the --hw argument. In addition, non-Sometimes verification
-# results will be noted, but forgiven.  Furthermore, if there is no
-# "Result:" comment but there is an LKMM .litmus.out file, the observation
-# in that file will be used to judge the assembly-language verification.
+# Given a .litmus test and the corresponding .litmus.out file, check
+# the .litmus.out file against the "Result:" comment to judge whether
+# the test ran correctly.
 #
 # Usage:
 #	judgelitmus.sh file.litmus
@@ -26,7 +13,7 @@
 #
 # Copyright IBM Corporation, 2018
 #
-# Author: Paul E. McKenney <paulmck@linux.ibm.com>
+# Author: Paul E. McKenney <paulmck@linux.vnet.ibm.com>
 
 litmus=$1
 
@@ -37,120 +24,55 @@ else
 	echo ' --- ' error: \"$litmus\" is not a readable file
 	exit 255
 fi
-if test -z "$LKMM_HW_MAP_FILE"
-then
-	litmusout=$litmus.out
-	lkmmout=
-else
-	litmusout="`echo $litmus |
-		sed -e 's/\.litmus$/.litmus.'${LKMM_HW_MAP_FILE}'/'`.out"
-	lkmmout=$litmus.out
-fi
-if test -f "$LKMM_DESTDIR/$litmusout" -a -r "$LKMM_DESTDIR/$litmusout"
+if test -f "$LKMM_DESTDIR/$litmus".out -a -r "$LKMM_DESTDIR/$litmus".out
 then
 	:
 else
-	echo ' --- ' error: \"$LKMM_DESTDIR/$litmusout is not a readable file
+	echo ' --- ' error: \"$LKMM_DESTDIR/$litmus\".out is not a readable file
 	exit 255
 fi
-if grep -q '^Flag data-race$' "$LKMM_DESTDIR/$litmusout"
-then
-	datarace_modeled=1
-fi
-if grep -q '^[( ]\* Result: ' $litmus
-then
-	outcome=`grep -m 1 '^[( ]\* Result: ' $litmus | awk '{ print $3 }'`
-	if grep -m1 '^[( ]\* Result: .* DATARACE' $litmus
-	then
-		datarace_predicted=1
-	fi
-	if test -n "$datarace_predicted" -a -z "$datarace_modeled" -a -z "$LKMM_HW_MAP_FILE"
-	then
-		echo '!!! Predicted data race not modeled' $litmus
-		exit 252
-	elif test -z "$datarace_predicted" -a -n "$datarace_modeled"
-	then
-		# Note that hardware models currently don't model data races
-		echo '!!! Unexpected data race modeled' $litmus
-		exit 253
-	fi
-elif test -n "$LKMM_HW_MAP_FILE" && grep -q '^Observation' $LKMM_DESTDIR/$lkmmout > /dev/null 2>&1
+if grep -q '^ \* Result: ' $litmus
 then
-	outcome=`grep -m 1 '^Observation ' $LKMM_DESTDIR/$lkmmout | awk '{ print $3 }'`
+	outcome=`grep -m 1 '^ \* Result: ' $litmus | awk '{ print $3 }'`
 else
 	outcome=specified
 fi
 
-grep '^Observation' $LKMM_DESTDIR/$litmusout
-if grep -q '^Observation' $LKMM_DESTDIR/$litmusout
+grep '^Observation' $LKMM_DESTDIR/$litmus.out
+if grep -q '^Observation' $LKMM_DESTDIR/$litmus.out
 then
 	:
-elif grep ': Unknown macro ' $LKMM_DESTDIR/$litmusout
-then
-	badname=`grep ': Unknown macro ' $LKMM_DESTDIR/$litmusout |
-		sed -e 's/^.*: Unknown macro //' |
-		sed -e 's/ (User error).*$//'`
-	badmsg=' !!! Current LKMM version does not know "'$badname'"'" $litmus"
-	echo $badmsg
-	if ! grep -q '!!!' $LKMM_DESTDIR/$litmusout
-	then
-		echo ' !!! '$badmsg >> $LKMM_DESTDIR/$litmusout 2>&1
-	fi
-	exit 254
-elif grep '^Command exited with non-zero status 124' $LKMM_DESTDIR/$litmusout
-then
-	echo ' !!! Timeout' $litmus
-	if ! grep -q '!!!' $LKMM_DESTDIR/$litmusout
-	then
-		echo ' !!! Timeout' >> $LKMM_DESTDIR/$litmusout 2>&1
-	fi
-	exit 124
 else
 	echo ' !!! Verification error' $litmus
-	if ! grep -q '!!!' $LKMM_DESTDIR/$litmusout
+	if ! grep -q '!!!' $LKMM_DESTDIR/$litmus.out
 	then
-		echo ' !!! Verification error' >> $LKMM_DESTDIR/$litmusout 2>&1
+		echo ' !!! Verification error' >> $LKMM_DESTDIR/$litmus.out 2>&1
 	fi
 	exit 255
 fi
 if test "$outcome" = DEADLOCK
 then
-	if grep '^Observation' $LKMM_DESTDIR/$litmusout | grep -q 'Never 0 0$'
+	if grep '^Observation' $LKMM_DESTDIR/$litmus.out | grep -q 'Never 0 0$'
 	then
 		ret=0
 	else
 		echo " !!! Unexpected non-$outcome verification" $litmus
-		if ! grep -q '!!!' $LKMM_DESTDIR/$litmusout
+		if ! grep -q '!!!' $LKMM_DESTDIR/$litmus.out
 		then
-			echo " !!! Unexpected non-$outcome verification" >> $LKMM_DESTDIR/$litmusout 2>&1
+			echo " !!! Unexpected non-$outcome verification" >> $LKMM_DESTDIR/$litmus.out 2>&1
 		fi
 		ret=1
 	fi
-elif grep '^Observation' $LKMM_DESTDIR/$litmusout | grep -q 'Never 0 0$'
-then
-	echo " !!! Unexpected non-$outcome deadlock" $litmus
-	if ! grep -q '!!!' $LKMM_DESTDIR/$litmusout
-	then
-		echo " !!! Unexpected non-$outcome deadlock" $litmus >> $LKMM_DESTDIR/$litmusout 2>&1
-	fi
-	ret=1
-elif grep '^Observation' $LKMM_DESTDIR/$litmusout | grep -q $outcome || test "$outcome" = Maybe
+elif grep '^Observation' $LKMM_DESTDIR/$litmus.out | grep -q $outcome || test "$outcome" = Maybe
 then
 	ret=0
 else
-	if test \( -n "$LKMM_HW_MAP_FILE" -a "$outcome" = Sometimes \) -o -n "$datarace_modeled"
+	echo " !!! Unexpected non-$outcome verification" $litmus
+	if ! grep -q '!!!' $LKMM_DESTDIR/$litmus.out
 	then
-		flag="--- Forgiven"
-		ret=0
-	else
-		flag="!!! Unexpected"
-		ret=1
-	fi
-	echo " $flag non-$outcome verification" $litmus
-	if ! grep -qe "$flag" $LKMM_DESTDIR/$litmusout
-	then
-		echo " $flag non-$outcome verification" >> $LKMM_DESTDIR/$litmusout 2>&1
+		echo " !!! Unexpected non-$outcome verification" >> $LKMM_DESTDIR/$litmus.out 2>&1
 	fi
+	ret=1
 fi
-tail -2 $LKMM_DESTDIR/$litmusout | head -1
+tail -2 $LKMM_DESTDIR/$litmus.out | head -1
 exit $ret
diff --git a/tools/memory-model/scripts/newlitmushist.sh b/tools/memory-model/scripts/newlitmushist.sh
index 25235e204..991f8f814 100755
--- a/tools/memory-model/scripts/newlitmushist.sh
+++ b/tools/memory-model/scripts/newlitmushist.sh
@@ -12,7 +12,7 @@
 #
 # Copyright IBM Corporation, 2018
 #
-# Author: Paul E. McKenney <paulmck@linux.ibm.com>
+# Author: Paul E. McKenney <paulmck@linux.vnet.ibm.com>
 
 . scripts/parseargs.sh
 
@@ -43,7 +43,7 @@ fi
 
 # Form full list of litmus tests with no more than the specified
 # number of processes (per the --procs argument).
-find litmus -name '*.litmus' -print | mselect7 -arch C > $T/list-C-all
+find litmus -name '*.litmus' -exec grep -l -m 1 "^C " {} \; > $T/list-C-all
 xargs < $T/list-C-all -r grep -L "^P${LKMM_PROCS}" > $T/list-C-short
 
 # Form list of new tests.  Note: This does not handle litmus-test deletion!
diff --git a/tools/memory-model/scripts/parseargs.sh b/tools/memory-model/scripts/parseargs.sh
index 08ded5909..40f52080f 100755
--- a/tools/memory-model/scripts/parseargs.sh
+++ b/tools/memory-model/scripts/parseargs.sh
@@ -1,7 +1,7 @@
 #!/bin/sh
 # SPDX-License-Identifier: GPL-2.0+
 #
-# Parse arguments common to the various scripts.
+# the corresponding .litmus.out file, and does not judge the result.
 #
 # . scripts/parseargs.sh
 #
@@ -9,7 +9,7 @@
 #
 # Copyright IBM Corporation, 2018
 #
-# Author: Paul E. McKenney <paulmck@linux.ibm.com>
+# Author: Paul E. McKenney <paulmck@linux.vnet.ibm.com>
 
 T=/tmp/parseargs.sh.$$
 mkdir $T
@@ -27,7 +27,6 @@ initparam () {
 
 initparam LKMM_DESTDIR "."
 initparam LKMM_HERD_OPTIONS "-conf linux-kernel.cfg"
-initparam LKMM_HW_MAP_FILE ""
 initparam LKMM_JOBS `getconf _NPROCESSORS_ONLN`
 initparam LKMM_PROCS "3"
 initparam LKMM_TIMEOUT "1m"
@@ -38,11 +37,10 @@ usagehelp () {
 	echo "Usage $scriptname [ arguments ]"
 	echo "      --destdir path (place for .litmus.out, default by .litmus)"
 	echo "      --herdopts -conf linux-kernel.cfg ..."
-	echo "      --hw AArch64"
 	echo "      --jobs N (number of jobs, default one per CPU)"
 	echo "      --procs N (litmus tests with at most this many processes)"
 	echo "      --timeout N (herd7 timeout (e.g., 10s, 1m, 2hr, 1d, '')"
-	echo "Defaults: --destdir '$LKMM_DESTDIR_DEF' --herdopts '$LKMM_HERD_OPTIONS_DEF' --hw '$LKMM_HW_MAP_FILE' --jobs '$LKMM_JOBS_DEF' --procs '$LKMM_PROCS_DEF' --timeout '$LKMM_TIMEOUT_DEF'"
+	echo "Defaults: --destdir '$LKMM_DESTDIR_DEF' --herdopts '$LKMM_HERD_OPTIONS_DEF' --jobs '$LKMM_JOBS_DEF' --procs '$LKMM_PROCS_DEF' --timeout '$LKMM_TIMEOUT_DEF'"
 	exit 1
 }
 
@@ -83,7 +81,7 @@ do
 			echo "Cannot create directory --destdir '$LKMM_DESTDIR'"
 			usage
 		fi
-		if test -d "$LKMM_DESTDIR" -a -x "$LKMM_DESTDIR"
+		if test -d "$LKMM_DESTDIR" -a -w "$LKMM_DESTDIR" -a -x "$LKMM_DESTDIR"
 		then
 			:
 		else
@@ -97,11 +95,6 @@ do
 		LKMM_HERD_OPTIONS="$2"
 		shift
 		;;
-	--hw)
-		checkarg --hw "(.map file architecture name)" "$#" "$2" '^[A-Za-z0-9_-]\+' '^--'
-		LKMM_HW_MAP_FILE="$2"
-		shift
-		;;
 	-j[1-9]*)
 		njobs="`echo $1 | sed -e 's/^-j//'`"
 		trailchars="`echo $njobs | sed -e 's/[0-9]\+\(.*\)$/\1/'`"
@@ -113,7 +106,7 @@ do
 		LKMM_JOBS="`echo $njobs | sed -e 's/^\([0-9]\+\).*$/\1/'`"
 		;;
 	--jobs|--job|-j)
-		checkarg --jobs "(number)" "$#" "$2" '^[1-9][0-9]*$' '^--'
+		checkarg --jobs "(number)" "$#" "$2" '^[1-9][0-9]\+$' '^--'
 		LKMM_JOBS="$2"
 		shift
 		;;
@@ -127,10 +120,6 @@ do
 		LKMM_TIMEOUT="$2"
 		shift
 		;;
-	--)
-		shift
-		break
-		;;
 	*)
 		echo Unknown argument $1
 		usage
diff --git a/tools/memory-model/scripts/runlitmus.sh b/tools/memory-model/scripts/runlitmus.sh
deleted file mode 100755
index 94608d4b6..000000000
--- a/tools/memory-model/scripts/runlitmus.sh
+++ /dev/null
@@ -1,80 +0,0 @@
-#!/bin/sh
-# SPDX-License-Identifier: GPL-2.0+
-#
-# Without the -hw argument, runs a herd7 test and outputs verification
-# results to a file whose name is that of the specified litmus test,
-# but with ".out" appended.
-#
-# If the --hw argument is specified, this script translates the .litmus
-# C-language file to the specified type of assembly and verifies that.
-# But in this case, litmus tests using complex synchronization (such as
-# locking, RCU, and SRCU) are cheerfully ignored.
-#
-# Either way, return the status of the herd7 command.
-#
-# Usage:
-#	runlitmus.sh file.litmus
-#
-# Run this in the directory containing the memory model, specifying the
-# pathname of the litmus test to check.  The caller is expected to have
-# properly set up the LKMM environment variables.
-#
-# Copyright IBM Corporation, 2019
-#
-# Author: Paul E. McKenney <paulmck@linux.ibm.com>
-
-litmus=$1
-if test -f "$litmus" -a -r "$litmus"
-then
-	:
-else
-	echo ' !!! ' error: \"$litmus\" is not a readable file
-	exit 255
-fi
-
-if test -z "$LKMM_HW_MAP_FILE" -o ! -e $LKMM_DESTDIR/$litmus.out
-then
-	# LKMM run
-	herdoptions=${LKMM_HERD_OPTIONS--conf linux-kernel.cfg}
-	echo Herd options: $herdoptions > $LKMM_DESTDIR/$litmus.out
-	/usr/bin/time $LKMM_TIMEOUT_CMD herd7 $herdoptions $litmus >> $LKMM_DESTDIR/$litmus.out 2>&1
-	ret=$?
-	if test -z "$LKMM_HW_MAP_FILE"
-	then
-		exit $ret
-	fi
-	echo " --- " Automatically generated LKMM output for '"'--hw $LKMM_HW_MAP_FILE'"' run
-fi
-
-# Hardware run
-
-T=/tmp/checklitmushw.sh.$$
-trap 'rm -rf $T' 0 2
-mkdir $T
-
-# Generate filenames
-mapfile="Linux2${LKMM_HW_MAP_FILE}.map"
-themefile="$T/${LKMM_HW_MAP_FILE}.theme"
-herdoptions="-model $LKMM_HW_CAT_FILE"
-hwlitmus=`echo $litmus | sed -e 's/\.litmus$/.litmus.'${LKMM_HW_MAP_FILE}'/'`
-hwlitmusfile=`echo $hwlitmus | sed -e 's,^.*/,,'`
-
-# Don't run on litmus tests with complex synchronization
-if ! scripts/simpletest.sh $litmus
-then
-	echo ' --- ' error: \"$litmus\" contains locking, RCU, or SRCU
-	exit 254
-fi
-
-# Generate the assembly code and run herd7 on it.
-gen_theme7 -n 10 -map $mapfile -call Linux.call > $themefile
-jingle7 -v -theme $themefile $litmus > $LKMM_DESTDIR/$hwlitmus 2> $T/$hwlitmusfile.jingle7.out
-if grep -q "Generated 0 tests" $T/$hwlitmusfile.jingle7.out
-then
-	echo ' !!! ' jingle7 failed, errors in $hwlitmus.err
-	cp $T/$hwlitmusfile.jingle7.out $LKMM_DESTDIR/$hwlitmus.err
-	exit 253
-fi
-/usr/bin/time $LKMM_TIMEOUT_CMD herd7 -unroll 0 $LKMM_DESTDIR/$hwlitmus > $LKMM_DESTDIR/$hwlitmus.out 2>&1
-
-exit $?
diff --git a/tools/memory-model/scripts/runlitmushist.sh b/tools/memory-model/scripts/runlitmushist.sh
index c6c2bdc67..6ed376f49 100755
--- a/tools/memory-model/scripts/runlitmushist.sh
+++ b/tools/memory-model/scripts/runlitmushist.sh
@@ -13,9 +13,7 @@
 #
 # Copyright IBM Corporation, 2018
 #
-# Author: Paul E. McKenney <paulmck@linux.ibm.com>
-
-. scripts/hwfnseg.sh
+# Author: Paul E. McKenney <paulmck@linux.vnet.ibm.com>
 
 T=/tmp/runlitmushist.sh.$$
 trap 'rm -rf $T' 0
@@ -32,12 +30,15 @@ fi
 # Prefixes for per-CPU scripts
 for ((i=0;i<$LKMM_JOBS;i++))
 do
+	echo dir="$LKMM_DESTDIR" > $T/$i.sh
 	echo T=$T >> $T/$i.sh
+	echo herdoptions=\"$LKMM_HERD_OPTIONS\" >> $T/$i.sh
 	cat << '___EOF___' >> $T/$i.sh
 	runtest () {
-		if scripts/runlitmus.sh $1
+		echo ' ... ' /usr/bin/time $LKMM_TIMEOUT_CMD herd7 $herdoptions $1 '>' $dir/$1.out '2>&1'
+		if /usr/bin/time $LKMM_TIMEOUT_CMD herd7 $herdoptions $1 > $dir/$1.out 2>&1
 		then
-			if ! grep -q '^Observation ' $LKMM_DESTDIR/$1$2.out
+			if ! grep -q '^Observation ' $dir/$1.out
 			then
 				echo ' !!! Herd failed, no Observation:' $1
 			fi
@@ -46,16 +47,10 @@ do
 			if test "$exitcode" -eq 124
 			then
 				exitmsg="timed out"
-			elif test "$exitcode" -eq 253
-			then
-				exitmsg=
 			else
 				exitmsg="failed, exit code $exitcode"
 			fi
-			if test -n "$exitmsg"
-			then
-				echo ' !!! Herd' ${exitmsg}: $1
-			fi
+			echo ' !!! Herd' ${exitmsg}: $1
 		fi
 	}
 ___EOF___
@@ -64,13 +59,11 @@ done
 awk -v q="'" -v b='\\' '
 {
 	print "echo `grep " q "^P[0-9]" b "+(" q " " $0 " | tail -1 | sed -e " q "s/^P" b "([0-9]" b "+" b ")(.*$/" b "1/" q "` " $0
-}' | sh | sort -k1n |
-awk -v dq='"' -v hwfnseg="$hwfnseg" -v ncpu="$LKMM_JOBS" -v t="$T" '
+}' | bash |
+sort -k1n |
+awk -v ncpu=$LKMM_JOBS -v t=$T '
 {
-	print "if test -z " dq hwfnseg dq " || scripts/simpletest.sh " dq $2 dq
-	print "then"
-	print "\techo runtest " dq $2 dq " " hwfnseg " >> " t "/" NR % ncpu ".sh";
-	print "fi"
+	print "runtest " $2 >> t "/" NR % ncpu ".sh";
 }
 
 END {
diff --git a/tools/memory-model/scripts/simpletest.sh b/tools/memory-model/scripts/simpletest.sh
deleted file mode 100755
index 7edc5d361..000000000
--- a/tools/memory-model/scripts/simpletest.sh
+++ /dev/null
@@ -1,35 +0,0 @@
-#!/bin/sh
-# SPDX-License-Identifier: GPL-2.0+
-#
-# Give zero status if this is a simple test and non-zero otherwise.
-# Simple tests do not contain locking, RCU, or SRCU.
-#
-# Usage:
-#	simpletest.sh file.litmus
-#
-# Copyright IBM Corporation, 2019
-#
-# Author: Paul E. McKenney <paulmck@linux.ibm.com>
-
-
-litmus=$1
-
-if test -f "$litmus" -a -r "$litmus"
-then
-	:
-else
-	echo ' --- ' error: \"$litmus\" is not a readable file
-	exit 255
-fi
-exclude="^[[:space:]]*\("
-exclude="${exclude}spin_lock(\|spin_unlock(\|spin_trylock(\|spin_is_locked("
-exclude="${exclude}\|rcu_read_lock(\|rcu_read_unlock("
-exclude="${exclude}\|synchronize_rcu(\|synchronize_rcu_expedited("
-exclude="${exclude}\|srcu_read_lock(\|srcu_read_unlock("
-exclude="${exclude}\|synchronize_srcu(\|synchronize_srcu_expedited("
-exclude="${exclude}\)"
-if grep -q $exclude $litmus
-then
-	exit 255
-fi
-exit 0
diff --git a/tools/objtool/check.c b/tools/objtool/check.c
index a7f1e6c8b..43ec14c29 100644
--- a/tools/objtool/check.c
+++ b/tools/objtool/check.c
@@ -999,16 +999,6 @@ static const char *uaccess_safe_builtin[] = {
 	"__tsan_read_write4",
 	"__tsan_read_write8",
 	"__tsan_read_write16",
-	"__tsan_volatile_read1",
-	"__tsan_volatile_read2",
-	"__tsan_volatile_read4",
-	"__tsan_volatile_read8",
-	"__tsan_volatile_read16",
-	"__tsan_volatile_write1",
-	"__tsan_volatile_write2",
-	"__tsan_volatile_write4",
-	"__tsan_volatile_write8",
-	"__tsan_volatile_write16",
 	"__tsan_atomic8_load",
 	"__tsan_atomic16_load",
 	"__tsan_atomic32_load",
diff --git a/tools/testing/selftests/nolibc/Makefile b/tools/testing/selftests/nolibc/Makefile
index 22f1e1d73..69ea659ca 100644
--- a/tools/testing/selftests/nolibc/Makefile
+++ b/tools/testing/selftests/nolibc/Makefile
@@ -95,7 +95,6 @@ all: run
 sysroot: sysroot/$(ARCH)/include
 
 sysroot/$(ARCH)/include:
-	$(Q)rm -rf sysroot/$(ARCH) sysroot/sysroot
 	$(QUIET_MKDIR)mkdir -p sysroot
 	$(Q)$(MAKE) -C ../../../include/nolibc ARCH=$(ARCH) OUTPUT=$(CURDIR)/sysroot/ headers_standalone
 	$(Q)mv sysroot/sysroot sysroot/$(ARCH)
@@ -134,5 +133,3 @@ clean:
 	$(Q)rm -rf initramfs
 	$(call QUIET_CLEAN, run.out)
 	$(Q)rm -rf run.out
-
-.PHONY: sysroot/$(ARCH)/include
diff --git a/tools/testing/selftests/nolibc/nolibc-test.c b/tools/testing/selftests/nolibc/nolibc-test.c
index f14f5076f..78bced95a 100644
--- a/tools/testing/selftests/nolibc/nolibc-test.c
+++ b/tools/testing/selftests/nolibc/nolibc-test.c
@@ -565,13 +565,6 @@ int run_stdlib(int min, int max)
 		CASE_TEST(strchr_foobar_z);    EXPECT_STRZR(1, strchr("foobar", 'z')); break;
 		CASE_TEST(strrchr_foobar_o);   EXPECT_STREQ(1, strrchr("foobar", 'o'), "obar"); break;
 		CASE_TEST(strrchr_foobar_z);   EXPECT_STRZR(1, strrchr("foobar", 'z')); break;
-		CASE_TEST(memcmp_20_20);       EXPECT_EQ(1, memcmp("aaa\x20", "aaa\x20", 4), 0); break;
-		CASE_TEST(memcmp_20_60);       EXPECT_LT(1, memcmp("aaa\x20", "aaa\x60", 4), 0); break;
-		CASE_TEST(memcmp_60_20);       EXPECT_GT(1, memcmp("aaa\x60", "aaa\x20", 4), 0); break;
-		CASE_TEST(memcmp_20_e0);       EXPECT_LT(1, memcmp("aaa\x20", "aaa\xe0", 4), 0); break;
-		CASE_TEST(memcmp_e0_20);       EXPECT_GT(1, memcmp("aaa\xe0", "aaa\x20", 4), 0); break;
-		CASE_TEST(memcmp_80_e0);       EXPECT_LT(1, memcmp("aaa\x80", "aaa\xe0", 4), 0); break;
-		CASE_TEST(memcmp_e0_80);       EXPECT_GT(1, memcmp("aaa\xe0", "aaa\x80", 4), 0); break;
 		case __LINE__:
 			return ret; /* must be last */
 		/* note: do not set any defaults so as to permit holes above */
-- 
2.38.1.473.ga0789512c5

