From 045c1abcf5cc36f6eb431b8463d18453349bd06d Mon Sep 17 00:00:00 2001
From: Suren Baghdasaryan <surenb@google.com>
Date: Sun, 28 May 2023 18:23:32 +0000
Subject: [PATCH 39/43] fixup! change to procfs

Signed-off-by: Suren Baghdasaryan <surenb@google.com>
---
 include/linux/codetag.h |   2 +-
 lib/Kconfig.debug       |   2 +-
 lib/alloc_tag.c         | 144 ++++++++++++++++------------------------
 lib/codetag.c           |   4 +-
 4 files changed, 60 insertions(+), 92 deletions(-)

diff --git a/include/linux/codetag.h b/include/linux/codetag.h
index d98e4c8e8..e8c5a8771 100644
--- a/include/linux/codetag.h
+++ b/include/linux/codetag.h
@@ -67,7 +67,7 @@ void codetag_lock_module_list(struct codetag_type *cttype, bool lock);
 struct codetag_iterator codetag_get_ct_iter(struct codetag_type *cttype);
 struct codetag *codetag_next_ct(struct codetag_iterator *iter);
 
-void codetag_to_text(struct seq_buf *out, struct codetag *ct);
+int codetag_to_text(char *buf, struct codetag *ct);
 
 struct codetag_type *
 codetag_register_type(const struct codetag_type_desc *desc);
diff --git a/lib/Kconfig.debug b/lib/Kconfig.debug
index 4157c2251..4c232d811 100644
--- a/lib/Kconfig.debug
+++ b/lib/Kconfig.debug
@@ -964,7 +964,7 @@ config CODE_TAGGING
 config MEM_ALLOC_PROFILING
 	bool "Enable memory allocation profiling"
 	default n
-	depends on DEBUG_FS
+	depends on PROC_FS
 	select CODE_TAGGING
 	select LAZY_PERCPU_COUNTER
 	select PAGE_EXTENSION
diff --git a/lib/alloc_tag.c b/lib/alloc_tag.c
index f9332e7cd..97858eb8c 100644
--- a/lib/alloc_tag.c
+++ b/lib/alloc_tag.c
@@ -5,6 +5,7 @@
 #include <linux/gfp.h>
 #include <linux/module.h>
 #include <linux/page_ext.h>
+#include <linux/proc_fs.h>
 #include <linux/seq_buf.h>
 #include <linux/uaccess.h>
 
@@ -25,99 +26,79 @@ static int __init mem_alloc_profiling_enable(char *s)
 }
 __setup("mem_profiling", mem_alloc_profiling_enable);
 
-struct alloc_tag_file_iterator {
-	struct codetag_iterator ct_iter;
-	struct seq_buf		buf;
-	char			rawbuf[4096];
-};
+static void *allocinfo_start(struct seq_file *m, loff_t *pos)
+{
+	struct codetag_iterator *iter;
+	struct codetag *ct;
+	loff_t node = *pos;
 
-struct user_buf {
-	char __user		*buf;	/* destination user buffer */
-	size_t			size;	/* size of requested read */
-	ssize_t			ret;	/* bytes read so far */
-};
+	iter = kzalloc(sizeof(*iter), GFP_KERNEL);
+	m->private = iter;
+	if (!iter)
+		return NULL;
 
-static int flush_ubuf(struct user_buf *dst, struct seq_buf *src)
-{
-	if (src->len) {
-		size_t bytes = min_t(size_t, src->len, dst->size);
-		int err = copy_to_user(dst->buf, src->buffer, bytes);
-
-		if (err)
-			return err;
-
-		dst->ret	+= bytes;
-		dst->buf	+= bytes;
-		dst->size	-= bytes;
-		src->len	-= bytes;
-		memmove(src->buffer, src->buffer + bytes, src->len);
-	}
+	codetag_lock_module_list(alloc_tag_cttype, true);
+	*iter = codetag_get_ct_iter(alloc_tag_cttype);
+	while ((ct = codetag_next_ct(iter)) != NULL && node)
+		node--;
 
-	return 0;
+	return ct ? iter : NULL;
 }
 
-static int allocations_file_open(struct inode *inode, struct file *file)
+static void *allocinfo_next(struct seq_file *m, void *arg, loff_t *pos)
 {
-	struct codetag_type *cttype = inode->i_private;
-	struct alloc_tag_file_iterator *iter;
-
-	iter = kzalloc(sizeof(*iter), GFP_KERNEL);
-	if (!iter)
-		return -ENOMEM;
+	struct codetag_iterator *iter = (struct codetag_iterator *)arg;
+	struct codetag *ct = codetag_next_ct(iter);
 
-	codetag_lock_module_list(cttype, true);
-	iter->ct_iter = codetag_get_ct_iter(cttype);
-	codetag_lock_module_list(cttype, false);
-	seq_buf_init(&iter->buf, iter->rawbuf, sizeof(iter->rawbuf));
-	file->private_data = iter;
+	(*pos)++;
+	if (!ct)
+		return NULL;
 
-	return 0;
+	return iter;
 }
 
-static int allocations_file_release(struct inode *inode, struct file *file)
+static void allocinfo_stop(struct seq_file *m, void *arg)
 {
-	struct alloc_tag_file_iterator *iter = file->private_data;
+	struct codetag_iterator *iter = (struct codetag_iterator *)m->private;
 
-	kfree(iter);
-	return 0;
+	if (iter) {
+		codetag_lock_module_list(alloc_tag_cttype, false);
+		kfree(iter);
+	}
 }
 
-static void alloc_tag_to_text(struct seq_buf *out, struct codetag *ct)
+static void alloc_tag_to_text(char *buf, struct codetag *ct)
 {
 	struct alloc_tag *tag = ct_to_alloc_tag(ct);
-	char buf[10];
+	char val[10];
 
 	string_get_size(lazy_percpu_counter_read(&tag->bytes_allocated), 1,
-			STRING_UNITS_2, buf, sizeof(buf));
+			STRING_UNITS_2, val, sizeof(val));
 
-	seq_buf_printf(out, "%8s ", buf);
-	codetag_to_text(out, ct);
-	seq_buf_putc(out, '\n');
+	buf += sprintf(buf, "%8s ", val);
+	buf += codetag_to_text(buf, ct);
 }
 
-static ssize_t allocations_file_read(struct file *file, char __user *ubuf,
-				     size_t size, loff_t *ppos)
+static int allocinfo_show(struct seq_file *m, void *arg)
 {
-	struct alloc_tag_file_iterator *iter = file->private_data;
-	struct user_buf	buf = { .buf = ubuf, .size = size };
-	struct codetag *ct;
-	int err = 0;
-
-	codetag_lock_module_list(iter->ct_iter.cttype, true);
-	while (1) {
-		err = flush_ubuf(&buf, &iter->buf);
-		if (err || !buf.size)
-			break;
+	struct codetag_iterator *iter = (struct codetag_iterator *)arg;
+	char buf[1024];
 
-		ct = codetag_next_ct(&iter->ct_iter);
-		if (!ct)
-			break;
+	alloc_tag_to_text(buf, iter->ct);
+	seq_printf(m, "%s\n", buf);
+	return 0;
+}
 
-		alloc_tag_to_text(&iter->buf, ct);
-	}
-	codetag_lock_module_list(iter->ct_iter.cttype, false);
+static const struct seq_operations allocinfo_seq_op = {
+	.start	= allocinfo_start,
+	.next	= allocinfo_next,
+	.stop	= allocinfo_stop,
+	.show	= allocinfo_show,
+};
 
-	return err ? : buf.ret;
+static void __init procfs_init(void)
+{
+	proc_create_seq("allocinfo", 0444, NULL, &allocinfo_seq_op);
 }
 
 void alloc_tags_show_mem_report(struct seq_buf *s)
@@ -129,6 +110,7 @@ void alloc_tags_show_mem_report(struct seq_buf *s)
 		size_t			bytes;
 	} tags[10], n;
 	unsigned int i, nr = 0;
+	char buf[1024];
 
 	codetag_lock_module_list(alloc_tag_cttype, true);
 	iter = codetag_get_ct_iter(alloc_tag_cttype);
@@ -150,29 +132,14 @@ void alloc_tags_show_mem_report(struct seq_buf *s)
 		}
 	}
 
-	for (i = 0; i < nr; i++)
-		alloc_tag_to_text(s, tags[i].tag);
+	for (i = 0; i < nr; i++) {
+		alloc_tag_to_text(buf, tags[i].tag);
+		seq_buf_printf(s, "%s\n", buf);
+	}
 
 	codetag_lock_module_list(alloc_tag_cttype, false);
 }
 
-static const struct file_operations allocations_file_ops = {
-	.owner	= THIS_MODULE,
-	.open	= allocations_file_open,
-	.release = allocations_file_release,
-	.read	= allocations_file_read,
-};
-
-static int __init dbgfs_init(struct codetag_type *cttype)
-{
-	struct dentry *file;
-
-	file = debugfs_create_file("allocations", 0444, NULL, cttype,
-				   &allocations_file_ops);
-
-	return IS_ERR(file) ? PTR_ERR(file) : 0;
-}
-
 static bool alloc_tag_module_unload(struct codetag_type *cttype, struct codetag_module *cmod)
 {
 	struct codetag_iterator iter = codetag_get_ct_iter(cttype);
@@ -226,6 +193,7 @@ static int __init alloc_tag_init(void)
 	if (IS_ERR_OR_NULL(alloc_tag_cttype))
 		return PTR_ERR(alloc_tag_cttype);
 
-	return dbgfs_init(alloc_tag_cttype);
+	procfs_init();
+	return 0;
 }
 module_init(alloc_tag_init);
diff --git a/lib/codetag.c b/lib/codetag.c
index 0ad4ea66c..b9762c183 100644
--- a/lib/codetag.c
+++ b/lib/codetag.c
@@ -92,9 +92,9 @@ struct codetag *codetag_next_ct(struct codetag_iterator *iter)
 	return ct;
 }
 
-void codetag_to_text(struct seq_buf *out, struct codetag *ct)
+int codetag_to_text(char *buf, struct codetag *ct)
 {
-	seq_buf_printf(out, "%s:%u module:%s func:%s",
+	return sprintf(buf, "%s:%u module:%s func:%s",
 		       ct->filename, ct->lineno,
 		       ct->modname, ct->function);
 }
-- 
2.40.1.445.gf85cd430b1

