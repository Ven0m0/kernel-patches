From 0ce026a20eafb5c63a8815c6e40a687ae082359c Mon Sep 17 00:00:00 2001
From: Kent Overstreet <kent.overstreet@linux.dev>
Date: Sat, 13 May 2023 02:39:24 -0400
Subject: [PATCH 45/50] mem profiling: Runtime switch

This converts the boot switch to a sysctl, which can be changed at
runtime when CONFIG_MEM_ALLOC_PROFILING_DEBUG=n

Signed-off-by: Kent Overstreet <kent.overstreet@linux.dev>
---
 include/linux/alloc_tag.h |  6 ------
 lib/alloc_tag.c           | 29 ++++++++++++++++-------------
 mm/slab.h                 |  3 ---
 3 files changed, 16 insertions(+), 22 deletions(-)

diff --git a/include/linux/alloc_tag.h b/include/linux/alloc_tag.h
index a8403a874..787d69e2d 100644
--- a/include/linux/alloc_tag.h
+++ b/include/linux/alloc_tag.h
@@ -70,9 +70,6 @@ static inline void __alloc_tag_sub(union codetag_ref *ref, size_t bytes,
 	struct alloc_tag *tag;
 
 #ifdef CONFIG_MEM_ALLOC_PROFILING_DEBUG
-	/* The switch should be checked before this */
-	BUG_ON(!mem_alloc_profiling_enabled());
-
 	WARN_ONCE(ref && !ref->ct, "alloc_tag was not set\n");
 #endif
 	if (!ref || !ref->ct)
@@ -105,9 +102,6 @@ static inline void alloc_tag_sub_noalloc(union codetag_ref *ref, size_t bytes)
 static inline void alloc_tag_add(union codetag_ref *ref, struct alloc_tag *tag, size_t bytes)
 {
 #ifdef CONFIG_MEM_ALLOC_PROFILING_DEBUG
-	/* The switch should be checked before this */
-	BUG_ON(!mem_alloc_profiling_enabled());
-
 	WARN_ONCE(ref && ref->ct,
 		  "alloc_tag was not cleared (got tag for %s:%u)\n",\
 		  ref->ct->filename, ref->ct->lineno);
diff --git a/lib/alloc_tag.c b/lib/alloc_tag.c
index 40a93f034..d9c92ac33 100644
--- a/lib/alloc_tag.c
+++ b/lib/alloc_tag.c
@@ -13,19 +13,6 @@ static struct codetag_type *alloc_tag_cttype;
 
 DEFINE_STATIC_KEY_FALSE(mem_alloc_profiling_key);
 
-/*
- * Won't need to be exported once page allocation accounting is moved to the
- * correct place:
- */
-EXPORT_SYMBOL(mem_alloc_profiling_key);
-
-static int __init mem_alloc_profiling_enable(char *s)
-{
-	static_branch_enable(&mem_alloc_profiling_key);
-	return 1;
-}
-__setup("mem_profiling", mem_alloc_profiling_enable);
-
 static void *allocinfo_start(struct seq_file *m, loff_t *pos)
 {
 	struct codetag_iterator *iter;
@@ -182,6 +169,20 @@ struct page_ext_operations page_alloc_tagging_ops = {
 };
 EXPORT_SYMBOL(page_alloc_tagging_ops);
 
+static struct ctl_table memory_allocation_profiling_sysctls[] = {
+	{
+		.procname	= "mem_profiling",
+		.data		= &mem_alloc_profiling_key,
+#ifdef CONFIG_MEM_ALLOC_PROFILING_DEBUG
+		.mode		= 0444,
+#else
+		.mode		= 0644,
+#endif
+		.proc_handler	= proc_do_static_key,
+	},
+	{ }
+};
+
 static int __init alloc_tag_init(void)
 {
 	const struct codetag_type_desc desc = {
@@ -190,6 +191,8 @@ static int __init alloc_tag_init(void)
 		.module_unload	= alloc_tag_module_unload,
 	};
 
+	register_sysctl_init("vm", memory_allocation_profiling_sysctls);
+
 	alloc_tag_cttype = codetag_register_type(&desc);
 	if (IS_ERR_OR_NULL(alloc_tag_cttype))
 		return PTR_ERR(alloc_tag_cttype);
diff --git a/mm/slab.h b/mm/slab.h
index 50d86008a..511086b13 100644
--- a/mm/slab.h
+++ b/mm/slab.h
@@ -535,9 +535,6 @@ static inline void alloc_tagging_slab_free_hook(struct kmem_cache *s, struct sla
 	struct slabobj_ext *obj_exts;
 	int i;
 
-	if (!mem_alloc_profiling_enabled())
-		return;
-
 	obj_exts = slab_obj_exts(slab);
 	if (!obj_exts)
 		return;
-- 
2.41.0

