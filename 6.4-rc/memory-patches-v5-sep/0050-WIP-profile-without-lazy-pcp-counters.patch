From c0cfb0a0420395d46a689871c49ba6c2595b1658 Mon Sep 17 00:00:00 2001
From: Suren Baghdasaryan <surenb@google.com>
Date: Thu, 15 Jun 2023 00:47:37 +0000
Subject: [PATCH 50/50] WIP: profile without lazy pcp counters

Signed-off-by: Suren Baghdasaryan <surenb@google.com>
---
 include/linux/mem_profiling.h | 25 +++++++++++++++++--------
 mm/profiling.c                | 22 ++++++++++++++++++----
 2 files changed, 35 insertions(+), 12 deletions(-)

diff --git a/include/linux/mem_profiling.h b/include/linux/mem_profiling.h
index 5e6b70815..bda4ac030 100644
--- a/include/linux/mem_profiling.h
+++ b/include/linux/mem_profiling.h
@@ -8,7 +8,8 @@
 #include <linux/bug.h>
 #include <linux/codetag.h>
 #include <linux/container_of.h>
-#include <linux/lazy-percpu-counter.h>
+#include <asm/percpu.h>
+#include <linux/cpumask.h>
 #include <linux/static_key.h>
 
 /*
@@ -18,7 +19,7 @@
  */
 struct alloc_tag {
 	struct codetag			ct;
-	struct lazy_percpu_counter	bytes_allocated;
+	u64 __percpu			*bytes_allocated;
 } __aligned(8);
 
 #ifdef CONFIG_MEM_ALLOC_PROFILING
@@ -66,8 +67,19 @@ static inline void set_codetag_empty(union codetag_ref *ref) {}
 
 #endif /* CONFIG_MEM_ALLOC_PROFILING_DEBUG */
 
+static inline u64 alloc_tag_read(struct alloc_tag *tag)
+{
+	u64 v = 0;
+	int cpu;
+
+	for_each_possible_cpu(cpu)
+		v += *per_cpu_ptr(tag->bytes_allocated, cpu);
+
+	return v;
+}
+
 static inline void __alloc_tag_sub(union codetag_ref *ref, size_t bytes,
-				   bool may_allocate)
+				   bool)
 {
 	struct alloc_tag *tag;
 
@@ -84,10 +96,7 @@ static inline void __alloc_tag_sub(union codetag_ref *ref, size_t bytes,
 
 	tag = ct_to_alloc_tag(ref->ct);
 
-	if (may_allocate)
-		lazy_percpu_counter_add(&tag->bytes_allocated, -bytes);
-	else
-		lazy_percpu_counter_add_noupgrade(&tag->bytes_allocated, -bytes);
+	this_cpu_add(*tag->bytes_allocated, -bytes);
 	ref->ct = NULL;
 }
 
@@ -114,7 +123,7 @@ static inline void alloc_tag_add(union codetag_ref *ref, struct alloc_tag *tag,
 		return;
 
 	ref->ct = &tag->ct;
-	lazy_percpu_counter_add(&tag->bytes_allocated, bytes);
+	this_cpu_add(*tag->bytes_allocated, bytes);
 }
 
 #else
diff --git a/mm/profiling.c b/mm/profiling.c
index 275b758ce..d5cc1e8f8 100644
--- a/mm/profiling.c
+++ b/mm/profiling.c
@@ -60,7 +60,7 @@ static void alloc_tag_to_text(char *buf, struct codetag *ct)
 	struct alloc_tag *tag = ct_to_alloc_tag(ct);
 	char val[10];
 
-	string_get_size(lazy_percpu_counter_read(&tag->bytes_allocated), 1,
+	string_get_size(alloc_tag_read(tag), 1,
 			STRING_SIZE_BASE2|STRING_SIZE_NOSPACE,
 			val, sizeof(val));
 
@@ -105,7 +105,7 @@ void alloc_tags_show_mem_report(struct seq_buf *s)
 	iter = codetag_get_ct_iter(alloc_tag_cttype);
 	while ((ct = codetag_next_ct(&iter))) {
 		n.tag	= ct;
-		n.bytes = lazy_percpu_counter_read(&ct_to_alloc_tag(ct)->bytes_allocated);
+		n.bytes = alloc_tag_read(ct_to_alloc_tag(ct));
 
 		for (i = 0; i < nr; i++)
 			if (n.bytes > tags[i].bytes)
@@ -129,6 +129,19 @@ void alloc_tags_show_mem_report(struct seq_buf *s)
 	codetag_lock_module_list(alloc_tag_cttype, false);
 }
 
+static void alloc_tag_module_load(struct codetag_type *cttype, struct codetag_module *cmod)
+{
+	struct codetag_iterator iter = codetag_get_ct_iter(cttype);
+	struct codetag *ct;
+
+	for (ct = codetag_next_ct(&iter); ct; ct = codetag_next_ct(&iter)) {
+		if (iter.cmod != cmod)
+			continue;
+
+		ct_to_alloc_tag(ct)->bytes_allocated = alloc_percpu(u64);
+	}
+}
+
 static bool alloc_tag_module_unload(struct codetag_type *cttype, struct codetag_module *cmod)
 {
 	struct codetag_iterator iter = codetag_get_ct_iter(cttype);
@@ -142,11 +155,11 @@ static bool alloc_tag_module_unload(struct codetag_type *cttype, struct codetag_
 			continue;
 
 		tag = ct_to_alloc_tag(ct);
-		bytes = lazy_percpu_counter_read(&tag->bytes_allocated);
+		bytes = alloc_tag_read(tag);
 
 		if (!WARN(bytes, "%s:%u module %s func:%s has %zu allocated at module unload",
 			  ct->filename, ct->lineno, ct->modname, ct->function, bytes))
-			lazy_percpu_counter_exit(&tag->bytes_allocated);
+			free_percpu(tag->bytes_allocated);
 		else
 			module_unused = false;
 	}
@@ -189,6 +202,7 @@ static int __init alloc_tag_init(void)
 	const struct codetag_type_desc desc = {
 		.section	= "alloc_tags",
 		.tag_size	= sizeof(struct alloc_tag),
+		.module_load	= alloc_tag_module_load,
 		.module_unload	= alloc_tag_module_unload,
 	};
 
-- 
2.41.0

