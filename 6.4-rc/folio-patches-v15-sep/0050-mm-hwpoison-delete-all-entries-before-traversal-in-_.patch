From a216d0573a2eb492feed83702f76b2ea7d6c5ca7 Mon Sep 17 00:00:00 2001
From: Jiaqi Yan <jiaqiyan@google.com>
Date: Fri, 23 Jun 2023 16:40:12 +0000
Subject: [PATCH 50/53] mm/hwpoison: delete all entries before traversal in
 __folio_free_raw_hwp

Traversal on llist (e.g. llist_for_each_safe) is only safe AFTER entries
are deleted from the llist.

llist_del_all are lock free with itself. folio_clear_hugetlb_hwpoison()s
from __update_and_free_hugetlb_folio and memory_failure won't need
explicit locking when freeing the raw_hwp_list.

Signed-off-by: Jiaqi Yan <jiaqiyan@google.com>
---
 mm/memory-failure.c | 8 +++-----
 1 file changed, 3 insertions(+), 5 deletions(-)

diff --git a/mm/memory-failure.c b/mm/memory-failure.c
index 5b663eca1..5fea679f8 100644
--- a/mm/memory-failure.c
+++ b/mm/memory-failure.c
@@ -1834,12 +1834,11 @@ static inline struct llist_head *raw_hwp_list_head(struct folio *folio)
 
 static unsigned long __folio_free_raw_hwp(struct folio *folio, bool move_flag)
 {
-	struct llist_head *head;
-	struct llist_node *t, *tnode;
+	struct llist_node *t, *tnode, *head;
 	unsigned long count = 0;
 
-	head = raw_hwp_list_head(folio);
-	llist_for_each_safe(tnode, t, head->first) {
+	head = llist_del_all(raw_hwp_list_head(folio));
+	llist_for_each_safe(tnode, t, head) {
 		struct raw_hwp_page *p = container_of(tnode, struct raw_hwp_page, node);
 
 		if (move_flag)
@@ -1849,7 +1848,6 @@ static unsigned long __folio_free_raw_hwp(struct folio *folio, bool move_flag)
 		kfree(p);
 		count++;
 	}
-	llist_del_all(head);
 	return count;
 }
 
-- 
2.41.0

