From 9115caccadeef3e704ad330656924541585caffb Mon Sep 17 00:00:00 2001
From: Eric Naim <dnaim@cachyos.org>
Date: Fri, 22 Nov 2024 16:45:09 +0800
Subject: [PATCH 29/35] Revert "drm/amd/pm: fix and simplify workload handling"

This reverts commit 764d1bfb3386050f01f1738ef75c9b55ab786031.
---
 drivers/gpu/drm/amd/pm/swsmu/amdgpu_smu.c     | 156 +++++++-----------
 drivers/gpu/drm/amd/pm/swsmu/inc/amdgpu_smu.h |  15 +-
 .../gpu/drm/amd/pm/swsmu/smu11/arcturus_ppt.c | 146 ++++++++--------
 .../gpu/drm/amd/pm/swsmu/smu11/navi10_ppt.c   | 146 ++++++++--------
 .../amd/pm/swsmu/smu11/sienna_cichlid_ppt.c   | 145 ++++++++--------
 .../gpu/drm/amd/pm/swsmu/smu11/vangogh_ppt.c  |  41 +++--
 .../gpu/drm/amd/pm/swsmu/smu12/renoir_ppt.c   |  43 +++--
 .../drm/amd/pm/swsmu/smu13/smu_v13_0_0_ppt.c  | 143 ++++++++--------
 .../drm/amd/pm/swsmu/smu13/smu_v13_0_7_ppt.c  | 117 ++++++-------
 .../drm/amd/pm/swsmu/smu14/smu_v14_0_2_ppt.c  | 144 ++++++++--------
 drivers/gpu/drm/amd/pm/swsmu/smu_cmn.c        |  30 ----
 drivers/gpu/drm/amd/pm/swsmu/smu_cmn.h        |   5 -
 12 files changed, 520 insertions(+), 611 deletions(-)

diff --git a/drivers/gpu/drm/amd/pm/swsmu/amdgpu_smu.c b/drivers/gpu/drm/amd/pm/swsmu/amdgpu_smu.c
index fdd94450a..157db29fb 100644
--- a/drivers/gpu/drm/amd/pm/swsmu/amdgpu_smu.c
+++ b/drivers/gpu/drm/amd/pm/swsmu/amdgpu_smu.c
@@ -72,10 +72,6 @@ static int smu_set_power_limit(void *handle, uint32_t limit);
 static int smu_set_fan_speed_rpm(void *handle, uint32_t speed);
 static int smu_set_gfx_cgpg(struct smu_context *smu, bool enabled);
 static int smu_set_mp1_state(void *handle, enum pp_mp1_state mp1_state);
-static void smu_power_profile_mode_get(struct smu_context *smu,
-				       enum PP_SMC_POWER_PROFILE profile_mode);
-static void smu_power_profile_mode_put(struct smu_context *smu,
-				       enum PP_SMC_POWER_PROFILE profile_mode);
 
 static int smu_sys_get_pp_feature_mask(void *handle,
 				       char *buf)
@@ -1261,19 +1257,35 @@ static int smu_sw_init(void *handle)
 	INIT_WORK(&smu->interrupt_work, smu_interrupt_work_fn);
 	atomic64_set(&smu->throttle_int_counter, 0);
 	smu->watermarks_bitmap = 0;
+	smu->power_profile_mode = PP_SMC_POWER_PROFILE_BOOTUP_DEFAULT;
+	smu->default_power_profile_mode = PP_SMC_POWER_PROFILE_BOOTUP_DEFAULT;
 
 	atomic_set(&smu->smu_power.power_gate.vcn_gated, 1);
 	atomic_set(&smu->smu_power.power_gate.jpeg_gated, 1);
 	atomic_set(&smu->smu_power.power_gate.vpe_gated, 1);
 	atomic_set(&smu->smu_power.power_gate.umsch_mm_gated, 1);
 
+	smu->workload_prority[PP_SMC_POWER_PROFILE_BOOTUP_DEFAULT] = 0;
+	smu->workload_prority[PP_SMC_POWER_PROFILE_FULLSCREEN3D] = 1;
+	smu->workload_prority[PP_SMC_POWER_PROFILE_POWERSAVING] = 2;
+	smu->workload_prority[PP_SMC_POWER_PROFILE_VIDEO] = 3;
+	smu->workload_prority[PP_SMC_POWER_PROFILE_VR] = 4;
+	smu->workload_prority[PP_SMC_POWER_PROFILE_COMPUTE] = 5;
+	smu->workload_prority[PP_SMC_POWER_PROFILE_CUSTOM] = 6;
+
 	if (smu->is_apu ||
 	    !smu_is_workload_profile_available(smu, PP_SMC_POWER_PROFILE_FULLSCREEN3D))
-		smu->power_profile_mode = PP_SMC_POWER_PROFILE_BOOTUP_DEFAULT;
+		smu->workload_mask = 1 << smu->workload_prority[PP_SMC_POWER_PROFILE_BOOTUP_DEFAULT];
 	else
-		smu->power_profile_mode = PP_SMC_POWER_PROFILE_FULLSCREEN3D;
-	smu_power_profile_mode_get(smu, smu->power_profile_mode);
-
+		smu->workload_mask = 1 << smu->workload_prority[PP_SMC_POWER_PROFILE_FULLSCREEN3D];
+
+	smu->workload_setting[0] = PP_SMC_POWER_PROFILE_BOOTUP_DEFAULT;
+	smu->workload_setting[1] = PP_SMC_POWER_PROFILE_FULLSCREEN3D;
+	smu->workload_setting[2] = PP_SMC_POWER_PROFILE_POWERSAVING;
+	smu->workload_setting[3] = PP_SMC_POWER_PROFILE_VIDEO;
+	smu->workload_setting[4] = PP_SMC_POWER_PROFILE_VR;
+	smu->workload_setting[5] = PP_SMC_POWER_PROFILE_COMPUTE;
+	smu->workload_setting[6] = PP_SMC_POWER_PROFILE_CUSTOM;
 	smu->display_config = &adev->pm.pm_display_cfg;
 
 	smu->smu_dpm.dpm_level = AMD_DPM_FORCED_LEVEL_AUTO;
@@ -2101,9 +2113,6 @@ static int smu_suspend(void *handle)
 	if (!ret)
 		adev->gfx.gfx_off_entrycount = count;
 
-	/* clear this on suspend so it will get reprogrammed on resume */
-	smu->workload_mask = 0;
-
 	return 0;
 }
 
@@ -2215,46 +2224,26 @@ static int smu_enable_umd_pstate(void *handle,
 	return 0;
 }
 
-static int smu_bump_power_profile_mode(struct smu_context *smu)
+static int smu_bump_power_profile_mode(struct smu_context *smu,
+					   long *param,
+					   uint32_t param_size)
 {
-	u32 workload_mask = 0;
-	int i, ret = 0;
-
-	for (i = 0; i < PP_SMC_POWER_PROFILE_COUNT; i++) {
-		if (smu->workload_refcount[i])
-			workload_mask |= 1 << i;
-	}
-
-	if (smu->workload_mask == workload_mask)
-		return 0;
+	int ret = 0;
 
 	if (smu->ppt_funcs->set_power_profile_mode)
-		ret = smu->ppt_funcs->set_power_profile_mode(smu, workload_mask);
-
-	if (!ret)
-		smu->workload_mask = workload_mask;
+		ret = smu->ppt_funcs->set_power_profile_mode(smu, param, param_size);
 
 	return ret;
 }
 
-static void smu_power_profile_mode_get(struct smu_context *smu,
-				       enum PP_SMC_POWER_PROFILE profile_mode)
-{
-	smu->workload_refcount[profile_mode]++;
-}
-
-static void smu_power_profile_mode_put(struct smu_context *smu,
-				       enum PP_SMC_POWER_PROFILE profile_mode)
-{
-	if (smu->workload_refcount[profile_mode])
-		smu->workload_refcount[profile_mode]--;
-}
-
 static int smu_adjust_power_state_dynamic(struct smu_context *smu,
 					  enum amd_dpm_forced_level level,
-					  bool skip_display_settings)
+					  bool skip_display_settings,
+					  bool init)
 {
 	int ret = 0;
+	int index = 0;
+	long workload[1];
 	struct smu_dpm_context *smu_dpm_ctx = &(smu->smu_dpm);
 
 	if (!skip_display_settings) {
@@ -2291,8 +2280,14 @@ static int smu_adjust_power_state_dynamic(struct smu_context *smu,
 	}
 
 	if (smu_dpm_ctx->dpm_level != AMD_DPM_FORCED_LEVEL_MANUAL &&
-	    smu_dpm_ctx->dpm_level != AMD_DPM_FORCED_LEVEL_PERF_DETERMINISM)
-		smu_bump_power_profile_mode(smu);
+		smu_dpm_ctx->dpm_level != AMD_DPM_FORCED_LEVEL_PERF_DETERMINISM) {
+		index = fls(smu->workload_mask);
+		index = index > 0 && index <= WORKLOAD_POLICY_MAX ? index - 1 : 0;
+		workload[0] = smu->workload_setting[index];
+
+		if (init || smu->power_profile_mode != workload[0])
+			smu_bump_power_profile_mode(smu, workload, 0);
+	}
 
 	return ret;
 }
@@ -2311,13 +2306,13 @@ static int smu_handle_task(struct smu_context *smu,
 		ret = smu_pre_display_config_changed(smu);
 		if (ret)
 			return ret;
-		ret = smu_adjust_power_state_dynamic(smu, level, false);
+		ret = smu_adjust_power_state_dynamic(smu, level, false, false);
 		break;
 	case AMD_PP_TASK_COMPLETE_INIT:
-		ret = smu_adjust_power_state_dynamic(smu, level, true);
+		ret = smu_adjust_power_state_dynamic(smu, level, true, true);
 		break;
 	case AMD_PP_TASK_READJUST_POWER_STATE:
-		ret = smu_adjust_power_state_dynamic(smu, level, true);
+		ret = smu_adjust_power_state_dynamic(smu, level, true, false);
 		break;
 	default:
 		break;
@@ -2339,11 +2334,12 @@ static int smu_handle_dpm_task(void *handle,
 
 static int smu_switch_power_profile(void *handle,
 				    enum PP_SMC_POWER_PROFILE type,
-				    bool enable)
+				    bool en)
 {
 	struct smu_context *smu = handle;
 	struct smu_dpm_context *smu_dpm_ctx = &(smu->smu_dpm);
-	int ret;
+	long workload[1];
+	uint32_t index;
 
 	if (!smu->pm_enabled || !smu->adev->pm.dpm_enabled)
 		return -EOPNOTSUPP;
@@ -2351,22 +2347,22 @@ static int smu_switch_power_profile(void *handle,
 	if (!(type < PP_SMC_POWER_PROFILE_CUSTOM))
 		return -EINVAL;
 
-	if (smu_dpm_ctx->dpm_level != AMD_DPM_FORCED_LEVEL_MANUAL &&
-	    smu_dpm_ctx->dpm_level != AMD_DPM_FORCED_LEVEL_PERF_DETERMINISM) {
-		if (enable)
-			smu_power_profile_mode_get(smu, type);
-		else
-			smu_power_profile_mode_put(smu, type);
-		ret = smu_bump_power_profile_mode(smu);
-		if (ret) {
-			if (enable)
-				smu_power_profile_mode_put(smu, type);
-			else
-				smu_power_profile_mode_get(smu, type);
-			return ret;
-		}
+	if (!en) {
+		smu->workload_mask &= ~(1 << smu->workload_prority[type]);
+		index = fls(smu->workload_mask);
+		index = index > 0 && index <= WORKLOAD_POLICY_MAX ? index - 1 : 0;
+		workload[0] = smu->workload_setting[index];
+	} else {
+		smu->workload_mask |= (1 << smu->workload_prority[type]);
+		index = fls(smu->workload_mask);
+		index = index <= WORKLOAD_POLICY_MAX ? index - 1 : 0;
+		workload[0] = smu->workload_setting[index];
 	}
 
+	if (smu_dpm_ctx->dpm_level != AMD_DPM_FORCED_LEVEL_MANUAL &&
+		smu_dpm_ctx->dpm_level != AMD_DPM_FORCED_LEVEL_PERF_DETERMINISM)
+		smu_bump_power_profile_mode(smu, workload, 0);
+
 	return 0;
 }
 
@@ -3057,48 +3053,12 @@ static int smu_set_power_profile_mode(void *handle,
 				      uint32_t param_size)
 {
 	struct smu_context *smu = handle;
-	bool custom_changed = false;
-	int ret = 0, i;
 
 	if (!smu->pm_enabled || !smu->adev->pm.dpm_enabled ||
 	    !smu->ppt_funcs->set_power_profile_mode)
 		return -EOPNOTSUPP;
 
-	if (param[param_size] == PP_SMC_POWER_PROFILE_CUSTOM) {
-		if (param_size > SMU_BACKEND_MAX_CUSTOM_PARAMETERS)
-			return -EINVAL;
-		/* param_size is actually a max index, not an array size */
-		for (i = 0; i <= param_size; i++) {
-			if (smu->custom_profile_input[i] != param[i]) {
-				custom_changed = true;
-				break;
-			}
-		}
-	}
-
-	if ((param[param_size] != smu->power_profile_mode) || custom_changed) {
-		/* save the parameters for custom */
-		if (custom_changed) {
-			/* param_size is actually a max index, not an array size */
-			for (i = 0; i <= param_size; i++)
-				smu->custom_profile_input[i] = param[i];
-			smu->custom_profile_size = param_size;
-			/* clear frontend mask so custom changes propogate */
-			smu->workload_mask = 0;
-		}
-		/* clear the old user preference */
-		smu_power_profile_mode_put(smu, smu->power_profile_mode);
-		/* set the new user preference */
-		smu_power_profile_mode_get(smu, param[param_size]);
-		ret = smu_bump_power_profile_mode(smu);
-		if (ret)
-			smu_power_profile_mode_put(smu, param[param_size]);
-		else
-			/* store the user's preference */
-			smu->power_profile_mode = param[param_size];
-	}
-
-	return ret;
+	return smu_bump_power_profile_mode(smu, param, param_size);
 }
 
 static int smu_get_fan_control_mode(void *handle, u32 *fan_mode)
diff --git a/drivers/gpu/drm/amd/pm/swsmu/inc/amdgpu_smu.h b/drivers/gpu/drm/amd/pm/swsmu/inc/amdgpu_smu.h
index cd7166346..b44a185d0 100644
--- a/drivers/gpu/drm/amd/pm/swsmu/inc/amdgpu_smu.h
+++ b/drivers/gpu/drm/amd/pm/swsmu/inc/amdgpu_smu.h
@@ -509,8 +509,6 @@ enum smu_fw_status {
  */
 #define SMU_WBRF_EVENT_HANDLING_PACE	10
 
-#define SMU_BACKEND_MAX_CUSTOM_PARAMETERS	11
-
 struct smu_context {
 	struct amdgpu_device            *adev;
 	struct amdgpu_irq_src		irq_source;
@@ -558,14 +556,11 @@ struct smu_context {
 	uint32_t hard_min_uclk_req_from_dal;
 	bool disable_uclk_switch;
 
-	/* asic agnostic workload mask */
 	uint32_t workload_mask;
-	/* default/user workload preference */
+	uint32_t workload_prority[WORKLOAD_POLICY_MAX];
+	uint32_t workload_setting[WORKLOAD_POLICY_MAX];
 	uint32_t power_profile_mode;
-	uint32_t workload_refcount[PP_SMC_POWER_PROFILE_COUNT];
-	/* backend specific custom workload settings */
-	long custom_profile_input[SMU_BACKEND_MAX_CUSTOM_PARAMETERS];
-	bool custom_profile_size;
+	uint32_t default_power_profile_mode;
 	bool pm_enabled;
 	bool is_apu;
 
@@ -736,9 +731,9 @@ struct pptable_funcs {
 	 * @set_power_profile_mode: Set a power profile mode. Also used to
 	 *                          create/set custom power profile modes.
 	 * &input: Power profile mode parameters.
-	 * &workload_mask: mask of workloads to enable
+	 * &size: Size of &input.
 	 */
-	int (*set_power_profile_mode)(struct smu_context *smu, u32 workload_mask);
+	int (*set_power_profile_mode)(struct smu_context *smu, long *input, uint32_t size);
 
 	/**
 	 * @dpm_set_vcn_enable: Enable/disable VCN engine dynamic power
diff --git a/drivers/gpu/drm/amd/pm/swsmu/smu11/arcturus_ppt.c b/drivers/gpu/drm/amd/pm/swsmu/smu11/arcturus_ppt.c
index 2d56ece18..c0f6b5936 100644
--- a/drivers/gpu/drm/amd/pm/swsmu/smu11/arcturus_ppt.c
+++ b/drivers/gpu/drm/amd/pm/swsmu/smu11/arcturus_ppt.c
@@ -1441,96 +1441,98 @@ static int arcturus_get_power_profile_mode(struct smu_context *smu,
 	return size;
 }
 
-static int arcturus_set_power_profile_mode_coeff(struct smu_context *smu,
-						 long *input,
-						 uint32_t size)
+static int arcturus_set_power_profile_mode(struct smu_context *smu,
+					   long *input,
+					   uint32_t size)
 {
 	DpmActivityMonitorCoeffInt_t activity_monitor;
-	int ret;
-
-	if (size != 10)
-		return -EINVAL;
-
-	ret = smu_cmn_update_table(smu,
-				   SMU_TABLE_ACTIVITY_MONITOR_COEFF,
-				   WORKLOAD_PPLIB_CUSTOM_BIT,
-				   (void *)(&activity_monitor),
-				   false);
-	if (ret) {
-		dev_err(smu->adev->dev, "[%s] Failed to get activity monitor!", __func__);
-		return ret;
-	}
+	int workload_type = 0;
+	uint32_t profile_mode = input[size];
+	int ret = 0;
 
-	switch (input[0]) {
-	case 0: /* Gfxclk */
-		activity_monitor.Gfx_FPS = input[1];
-		activity_monitor.Gfx_UseRlcBusy = input[2];
-		activity_monitor.Gfx_MinActiveFreqType = input[3];
-		activity_monitor.Gfx_MinActiveFreq = input[4];
-		activity_monitor.Gfx_BoosterFreqType = input[5];
-		activity_monitor.Gfx_BoosterFreq = input[6];
-		activity_monitor.Gfx_PD_Data_limit_c = input[7];
-		activity_monitor.Gfx_PD_Data_error_coeff = input[8];
-		activity_monitor.Gfx_PD_Data_error_rate_coeff = input[9];
-		break;
-	case 1: /* Uclk */
-		activity_monitor.Mem_FPS = input[1];
-		activity_monitor.Mem_UseRlcBusy = input[2];
-		activity_monitor.Mem_MinActiveFreqType = input[3];
-		activity_monitor.Mem_MinActiveFreq = input[4];
-		activity_monitor.Mem_BoosterFreqType = input[5];
-		activity_monitor.Mem_BoosterFreq = input[6];
-		activity_monitor.Mem_PD_Data_limit_c = input[7];
-		activity_monitor.Mem_PD_Data_error_coeff = input[8];
-		activity_monitor.Mem_PD_Data_error_rate_coeff = input[9];
-		break;
-	default:
+	if (profile_mode > PP_SMC_POWER_PROFILE_CUSTOM) {
+		dev_err(smu->adev->dev, "Invalid power profile mode %d\n", profile_mode);
 		return -EINVAL;
 	}
 
-	ret = smu_cmn_update_table(smu,
-				   SMU_TABLE_ACTIVITY_MONITOR_COEFF,
-				   WORKLOAD_PPLIB_CUSTOM_BIT,
-				   (void *)(&activity_monitor),
-				   true);
-	if (ret) {
-		dev_err(smu->adev->dev, "[%s] Failed to set activity monitor!", __func__);
-		return ret;
-	}
 
-	return ret;
-}
+	if ((profile_mode == PP_SMC_POWER_PROFILE_CUSTOM) &&
+	     (smu->smc_fw_version >= 0x360d00)) {
+		if (size != 10)
+			return -EINVAL;
 
-static int arcturus_set_power_profile_mode(struct smu_context *smu,
-					   u32 workload_mask)
-{
-	u32 backend_workload_mask = 0;
-	bool custom_enabled = false;
-	int ret;
+		ret = smu_cmn_update_table(smu,
+				       SMU_TABLE_ACTIVITY_MONITOR_COEFF,
+				       WORKLOAD_PPLIB_CUSTOM_BIT,
+				       (void *)(&activity_monitor),
+				       false);
+		if (ret) {
+			dev_err(smu->adev->dev, "[%s] Failed to get activity monitor!", __func__);
+			return ret;
+		}
 
-	smu_cmn_get_backend_workload_mask(smu, workload_mask,
-					  &backend_workload_mask,
-					  &custom_enabled);
+		switch (input[0]) {
+		case 0: /* Gfxclk */
+			activity_monitor.Gfx_FPS = input[1];
+			activity_monitor.Gfx_UseRlcBusy = input[2];
+			activity_monitor.Gfx_MinActiveFreqType = input[3];
+			activity_monitor.Gfx_MinActiveFreq = input[4];
+			activity_monitor.Gfx_BoosterFreqType = input[5];
+			activity_monitor.Gfx_BoosterFreq = input[6];
+			activity_monitor.Gfx_PD_Data_limit_c = input[7];
+			activity_monitor.Gfx_PD_Data_error_coeff = input[8];
+			activity_monitor.Gfx_PD_Data_error_rate_coeff = input[9];
+			break;
+		case 1: /* Uclk */
+			activity_monitor.Mem_FPS = input[1];
+			activity_monitor.Mem_UseRlcBusy = input[2];
+			activity_monitor.Mem_MinActiveFreqType = input[3];
+			activity_monitor.Mem_MinActiveFreq = input[4];
+			activity_monitor.Mem_BoosterFreqType = input[5];
+			activity_monitor.Mem_BoosterFreq = input[6];
+			activity_monitor.Mem_PD_Data_limit_c = input[7];
+			activity_monitor.Mem_PD_Data_error_coeff = input[8];
+			activity_monitor.Mem_PD_Data_error_rate_coeff = input[9];
+			break;
+		default:
+			return -EINVAL;
+		}
 
-	if (custom_enabled) {
-		ret = arcturus_set_power_profile_mode_coeff(smu,
-							    smu->custom_profile_input,
-							    smu->custom_profile_size);
-		if (ret)
+		ret = smu_cmn_update_table(smu,
+				       SMU_TABLE_ACTIVITY_MONITOR_COEFF,
+				       WORKLOAD_PPLIB_CUSTOM_BIT,
+				       (void *)(&activity_monitor),
+				       true);
+		if (ret) {
+			dev_err(smu->adev->dev, "[%s] Failed to set activity monitor!", __func__);
 			return ret;
+		}
+	}
+
+	/*
+	 * Conv PP_SMC_POWER_PROFILE* to WORKLOAD_PPLIB_*_BIT
+	 * Not all profile modes are supported on arcturus.
+	 */
+	workload_type = smu_cmn_to_asic_specific_index(smu,
+						       CMN2ASIC_MAPPING_WORKLOAD,
+						       profile_mode);
+	if (workload_type < 0) {
+		dev_dbg(smu->adev->dev, "Unsupported power profile mode %d on arcturus\n", profile_mode);
+		return -EINVAL;
 	}
 
 	ret = smu_cmn_send_smc_msg_with_param(smu,
-					      SMU_MSG_SetWorkloadMask,
-					      backend_workload_mask,
-					      NULL);
+					  SMU_MSG_SetWorkloadMask,
+					  1 << workload_type,
+					  NULL);
 	if (ret) {
-		dev_err(smu->adev->dev, "Failed to set workload mask 0x%08x\n",
-			workload_mask);
+		dev_err(smu->adev->dev, "Fail to set workload type %d\n", workload_type);
 		return ret;
 	}
 
-	return ret;
+	smu->power_profile_mode = profile_mode;
+
+	return 0;
 }
 
 static int arcturus_set_performance_level(struct smu_context *smu,
diff --git a/drivers/gpu/drm/amd/pm/swsmu/smu11/navi10_ppt.c b/drivers/gpu/drm/amd/pm/swsmu/smu11/navi10_ppt.c
index 72e30a3d0..16af1a329 100644
--- a/drivers/gpu/drm/amd/pm/swsmu/smu11/navi10_ppt.c
+++ b/drivers/gpu/drm/amd/pm/swsmu/smu11/navi10_ppt.c
@@ -2004,99 +2004,87 @@ static int navi10_get_power_profile_mode(struct smu_context *smu, char *buf)
 	return size;
 }
 
-static int navi10_set_power_profile_mode_coeff(struct smu_context *smu,
-					       long *input,
-					       uint32_t size)
+static int navi10_set_power_profile_mode(struct smu_context *smu, long *input, uint32_t size)
 {
 	DpmActivityMonitorCoeffInt_t activity_monitor;
-	int ret;
+	int workload_type, ret = 0;
 
-	if (size != 10)
-		return -EINVAL;
+	smu->power_profile_mode = input[size];
 
-	ret = smu_cmn_update_table(smu,
-				   SMU_TABLE_ACTIVITY_MONITOR_COEFF, WORKLOAD_PPLIB_CUSTOM_BIT,
-				   (void *)(&activity_monitor), false);
-	if (ret) {
-		dev_err(smu->adev->dev, "[%s] Failed to get activity monitor!", __func__);
-		return ret;
-	}
-
-	switch (input[0]) {
-	case 0: /* Gfxclk */
-		activity_monitor.Gfx_FPS = input[1];
-		activity_monitor.Gfx_MinFreqStep = input[2];
-		activity_monitor.Gfx_MinActiveFreqType = input[3];
-		activity_monitor.Gfx_MinActiveFreq = input[4];
-		activity_monitor.Gfx_BoosterFreqType = input[5];
-		activity_monitor.Gfx_BoosterFreq = input[6];
-		activity_monitor.Gfx_PD_Data_limit_c = input[7];
-		activity_monitor.Gfx_PD_Data_error_coeff = input[8];
-		activity_monitor.Gfx_PD_Data_error_rate_coeff = input[9];
-		break;
-	case 1: /* Socclk */
-		activity_monitor.Soc_FPS = input[1];
-		activity_monitor.Soc_MinFreqStep = input[2];
-		activity_monitor.Soc_MinActiveFreqType = input[3];
-		activity_monitor.Soc_MinActiveFreq = input[4];
-		activity_monitor.Soc_BoosterFreqType = input[5];
-		activity_monitor.Soc_BoosterFreq = input[6];
-		activity_monitor.Soc_PD_Data_limit_c = input[7];
-		activity_monitor.Soc_PD_Data_error_coeff = input[8];
-		activity_monitor.Soc_PD_Data_error_rate_coeff = input[9];
-		break;
-	case 2: /* Memclk */
-		activity_monitor.Mem_FPS = input[1];
-		activity_monitor.Mem_MinFreqStep = input[2];
-		activity_monitor.Mem_MinActiveFreqType = input[3];
-		activity_monitor.Mem_MinActiveFreq = input[4];
-		activity_monitor.Mem_BoosterFreqType = input[5];
-		activity_monitor.Mem_BoosterFreq = input[6];
-		activity_monitor.Mem_PD_Data_limit_c = input[7];
-		activity_monitor.Mem_PD_Data_error_coeff = input[8];
-		activity_monitor.Mem_PD_Data_error_rate_coeff = input[9];
-		break;
-	default:
+	if (smu->power_profile_mode > PP_SMC_POWER_PROFILE_CUSTOM) {
+		dev_err(smu->adev->dev, "Invalid power profile mode %d\n", smu->power_profile_mode);
 		return -EINVAL;
 	}
 
-	ret = smu_cmn_update_table(smu,
-				   SMU_TABLE_ACTIVITY_MONITOR_COEFF, WORKLOAD_PPLIB_CUSTOM_BIT,
-				   (void *)(&activity_monitor), true);
-	if (ret) {
-		dev_err(smu->adev->dev, "[%s] Failed to set activity monitor!", __func__);
-		return ret;
-	}
-
-	return ret;
-}
+	if (smu->power_profile_mode == PP_SMC_POWER_PROFILE_CUSTOM) {
+		if (size != 10)
+			return -EINVAL;
 
-static int navi10_set_power_profile_mode(struct smu_context *smu,
-					 u32 workload_mask)
-{
-	u32 backend_workload_mask = 0;
-	bool custom_enabled = false;
-	int ret;
+		ret = smu_cmn_update_table(smu,
+				       SMU_TABLE_ACTIVITY_MONITOR_COEFF, WORKLOAD_PPLIB_CUSTOM_BIT,
+				       (void *)(&activity_monitor), false);
+		if (ret) {
+			dev_err(smu->adev->dev, "[%s] Failed to get activity monitor!", __func__);
+			return ret;
+		}
 
-	smu_cmn_get_backend_workload_mask(smu, workload_mask,
-					  &backend_workload_mask,
-					  &custom_enabled);
+		switch (input[0]) {
+		case 0: /* Gfxclk */
+			activity_monitor.Gfx_FPS = input[1];
+			activity_monitor.Gfx_MinFreqStep = input[2];
+			activity_monitor.Gfx_MinActiveFreqType = input[3];
+			activity_monitor.Gfx_MinActiveFreq = input[4];
+			activity_monitor.Gfx_BoosterFreqType = input[5];
+			activity_monitor.Gfx_BoosterFreq = input[6];
+			activity_monitor.Gfx_PD_Data_limit_c = input[7];
+			activity_monitor.Gfx_PD_Data_error_coeff = input[8];
+			activity_monitor.Gfx_PD_Data_error_rate_coeff = input[9];
+			break;
+		case 1: /* Socclk */
+			activity_monitor.Soc_FPS = input[1];
+			activity_monitor.Soc_MinFreqStep = input[2];
+			activity_monitor.Soc_MinActiveFreqType = input[3];
+			activity_monitor.Soc_MinActiveFreq = input[4];
+			activity_monitor.Soc_BoosterFreqType = input[5];
+			activity_monitor.Soc_BoosterFreq = input[6];
+			activity_monitor.Soc_PD_Data_limit_c = input[7];
+			activity_monitor.Soc_PD_Data_error_coeff = input[8];
+			activity_monitor.Soc_PD_Data_error_rate_coeff = input[9];
+			break;
+		case 2: /* Memclk */
+			activity_monitor.Mem_FPS = input[1];
+			activity_monitor.Mem_MinFreqStep = input[2];
+			activity_monitor.Mem_MinActiveFreqType = input[3];
+			activity_monitor.Mem_MinActiveFreq = input[4];
+			activity_monitor.Mem_BoosterFreqType = input[5];
+			activity_monitor.Mem_BoosterFreq = input[6];
+			activity_monitor.Mem_PD_Data_limit_c = input[7];
+			activity_monitor.Mem_PD_Data_error_coeff = input[8];
+			activity_monitor.Mem_PD_Data_error_rate_coeff = input[9];
+			break;
+		default:
+			return -EINVAL;
+		}
 
-	if (custom_enabled) {
-		ret = navi10_set_power_profile_mode_coeff(smu,
-							  smu->custom_profile_input,
-							  smu->custom_profile_size);
-		if (ret)
+		ret = smu_cmn_update_table(smu,
+				       SMU_TABLE_ACTIVITY_MONITOR_COEFF, WORKLOAD_PPLIB_CUSTOM_BIT,
+				       (void *)(&activity_monitor), true);
+		if (ret) {
+			dev_err(smu->adev->dev, "[%s] Failed to set activity monitor!", __func__);
 			return ret;
+		}
 	}
 
+	/* conv PP_SMC_POWER_PROFILE* to WORKLOAD_PPLIB_*_BIT */
+	workload_type = smu_cmn_to_asic_specific_index(smu,
+						       CMN2ASIC_MAPPING_WORKLOAD,
+						       smu->power_profile_mode);
+	if (workload_type < 0)
+		return -EINVAL;
 	ret = smu_cmn_send_smc_msg_with_param(smu, SMU_MSG_SetWorkloadMask,
-					      backend_workload_mask, NULL);
-	if (ret) {
-		dev_err(smu->adev->dev, "Failed to set workload mask 0x%08x\n",
-			workload_mask);
-		return ret;
-	}
+				    1 << workload_type, NULL);
+	if (ret)
+		dev_err(smu->adev->dev, "[%s] Failed to set work load mask!", __func__);
 
 	return ret;
 }
diff --git a/drivers/gpu/drm/amd/pm/swsmu/smu11/sienna_cichlid_ppt.c b/drivers/gpu/drm/amd/pm/swsmu/smu11/sienna_cichlid_ppt.c
index 4945a3dda..9c3c48297 100644
--- a/drivers/gpu/drm/amd/pm/swsmu/smu11/sienna_cichlid_ppt.c
+++ b/drivers/gpu/drm/amd/pm/swsmu/smu11/sienna_cichlid_ppt.c
@@ -1706,101 +1706,90 @@ static int sienna_cichlid_get_power_profile_mode(struct smu_context *smu, char *
 	return size;
 }
 
-static int sienna_cichlid_set_power_profile_mode_coeff(struct smu_context *smu,
-						       long *input, uint32_t size)
+static int sienna_cichlid_set_power_profile_mode(struct smu_context *smu, long *input, uint32_t size)
 {
 
 	DpmActivityMonitorCoeffIntExternal_t activity_monitor_external;
 	DpmActivityMonitorCoeffInt_t *activity_monitor =
 		&(activity_monitor_external.DpmActivityMonitorCoeffInt);
-	int ret;
-
-	if (size != 10)
-		return -EINVAL;
+	int workload_type, ret = 0;
 
-	ret = smu_cmn_update_table(smu,
-				   SMU_TABLE_ACTIVITY_MONITOR_COEFF, WORKLOAD_PPLIB_CUSTOM_BIT,
-				   (void *)(&activity_monitor_external), false);
-	if (ret) {
-		dev_err(smu->adev->dev, "[%s] Failed to get activity monitor!", __func__);
-		return ret;
-	}
+	smu->power_profile_mode = input[size];
 
-	switch (input[0]) {
-	case 0: /* Gfxclk */
-		activity_monitor->Gfx_FPS = input[1];
-		activity_monitor->Gfx_MinFreqStep = input[2];
-		activity_monitor->Gfx_MinActiveFreqType = input[3];
-		activity_monitor->Gfx_MinActiveFreq = input[4];
-		activity_monitor->Gfx_BoosterFreqType = input[5];
-		activity_monitor->Gfx_BoosterFreq = input[6];
-		activity_monitor->Gfx_PD_Data_limit_c = input[7];
-		activity_monitor->Gfx_PD_Data_error_coeff = input[8];
-		activity_monitor->Gfx_PD_Data_error_rate_coeff = input[9];
-		break;
-	case 1: /* Socclk */
-		activity_monitor->Fclk_FPS = input[1];
-		activity_monitor->Fclk_MinFreqStep = input[2];
-		activity_monitor->Fclk_MinActiveFreqType = input[3];
-		activity_monitor->Fclk_MinActiveFreq = input[4];
-		activity_monitor->Fclk_BoosterFreqType = input[5];
-		activity_monitor->Fclk_BoosterFreq = input[6];
-		activity_monitor->Fclk_PD_Data_limit_c = input[7];
-		activity_monitor->Fclk_PD_Data_error_coeff = input[8];
-		activity_monitor->Fclk_PD_Data_error_rate_coeff = input[9];
-		break;
-	case 2: /* Memclk */
-		activity_monitor->Mem_FPS = input[1];
-		activity_monitor->Mem_MinFreqStep = input[2];
-		activity_monitor->Mem_MinActiveFreqType = input[3];
-		activity_monitor->Mem_MinActiveFreq = input[4];
-		activity_monitor->Mem_BoosterFreqType = input[5];
-		activity_monitor->Mem_BoosterFreq = input[6];
-		activity_monitor->Mem_PD_Data_limit_c = input[7];
-		activity_monitor->Mem_PD_Data_error_coeff = input[8];
-		activity_monitor->Mem_PD_Data_error_rate_coeff = input[9];
-		break;
-	default:
+	if (smu->power_profile_mode > PP_SMC_POWER_PROFILE_CUSTOM) {
+		dev_err(smu->adev->dev, "Invalid power profile mode %d\n", smu->power_profile_mode);
 		return -EINVAL;
 	}
 
-	ret = smu_cmn_update_table(smu,
-				   SMU_TABLE_ACTIVITY_MONITOR_COEFF, WORKLOAD_PPLIB_CUSTOM_BIT,
-				   (void *)(&activity_monitor_external), true);
-	if (ret) {
-		dev_err(smu->adev->dev, "[%s] Failed to set activity monitor!", __func__);
-		return ret;
-	}
-
-	return ret;
-}
+	if (smu->power_profile_mode == PP_SMC_POWER_PROFILE_CUSTOM) {
+		if (size != 10)
+			return -EINVAL;
 
-static int sienna_cichlid_set_power_profile_mode(struct smu_context *smu,
-						 u32 workload_mask)
-{
-	u32 backend_workload_mask = 0;
-	bool custom_enabled = false;
-	int ret;
+		ret = smu_cmn_update_table(smu,
+				       SMU_TABLE_ACTIVITY_MONITOR_COEFF, WORKLOAD_PPLIB_CUSTOM_BIT,
+				       (void *)(&activity_monitor_external), false);
+		if (ret) {
+			dev_err(smu->adev->dev, "[%s] Failed to get activity monitor!", __func__);
+			return ret;
+		}
 
-	smu_cmn_get_backend_workload_mask(smu, workload_mask,
-					  &backend_workload_mask,
-					  &custom_enabled);
+		switch (input[0]) {
+		case 0: /* Gfxclk */
+			activity_monitor->Gfx_FPS = input[1];
+			activity_monitor->Gfx_MinFreqStep = input[2];
+			activity_monitor->Gfx_MinActiveFreqType = input[3];
+			activity_monitor->Gfx_MinActiveFreq = input[4];
+			activity_monitor->Gfx_BoosterFreqType = input[5];
+			activity_monitor->Gfx_BoosterFreq = input[6];
+			activity_monitor->Gfx_PD_Data_limit_c = input[7];
+			activity_monitor->Gfx_PD_Data_error_coeff = input[8];
+			activity_monitor->Gfx_PD_Data_error_rate_coeff = input[9];
+			break;
+		case 1: /* Socclk */
+			activity_monitor->Fclk_FPS = input[1];
+			activity_monitor->Fclk_MinFreqStep = input[2];
+			activity_monitor->Fclk_MinActiveFreqType = input[3];
+			activity_monitor->Fclk_MinActiveFreq = input[4];
+			activity_monitor->Fclk_BoosterFreqType = input[5];
+			activity_monitor->Fclk_BoosterFreq = input[6];
+			activity_monitor->Fclk_PD_Data_limit_c = input[7];
+			activity_monitor->Fclk_PD_Data_error_coeff = input[8];
+			activity_monitor->Fclk_PD_Data_error_rate_coeff = input[9];
+			break;
+		case 2: /* Memclk */
+			activity_monitor->Mem_FPS = input[1];
+			activity_monitor->Mem_MinFreqStep = input[2];
+			activity_monitor->Mem_MinActiveFreqType = input[3];
+			activity_monitor->Mem_MinActiveFreq = input[4];
+			activity_monitor->Mem_BoosterFreqType = input[5];
+			activity_monitor->Mem_BoosterFreq = input[6];
+			activity_monitor->Mem_PD_Data_limit_c = input[7];
+			activity_monitor->Mem_PD_Data_error_coeff = input[8];
+			activity_monitor->Mem_PD_Data_error_rate_coeff = input[9];
+			break;
+		default:
+			return -EINVAL;
+		}
 
-	if (custom_enabled) {
-		ret = sienna_cichlid_set_power_profile_mode_coeff(smu,
-								  smu->custom_profile_input,
-								  smu->custom_profile_size);
-		if (ret)
+		ret = smu_cmn_update_table(smu,
+				       SMU_TABLE_ACTIVITY_MONITOR_COEFF, WORKLOAD_PPLIB_CUSTOM_BIT,
+				       (void *)(&activity_monitor_external), true);
+		if (ret) {
+			dev_err(smu->adev->dev, "[%s] Failed to set activity monitor!", __func__);
 			return ret;
+		}
 	}
 
+	/* conv PP_SMC_POWER_PROFILE* to WORKLOAD_PPLIB_*_BIT */
+	workload_type = smu_cmn_to_asic_specific_index(smu,
+						       CMN2ASIC_MAPPING_WORKLOAD,
+						       smu->power_profile_mode);
+	if (workload_type < 0)
+		return -EINVAL;
 	ret = smu_cmn_send_smc_msg_with_param(smu, SMU_MSG_SetWorkloadMask,
-					      backend_workload_mask, NULL);
-	if (ret) {
-		dev_err(smu->adev->dev, "Failed to set workload mask 0x%08x\n",
-			workload_mask);
-		return ret;
-	}
+				    1 << workload_type, NULL);
+	if (ret)
+		dev_err(smu->adev->dev, "[%s] Failed to set work load mask!", __func__);
 
 	return ret;
 }
diff --git a/drivers/gpu/drm/amd/pm/swsmu/smu11/vangogh_ppt.c b/drivers/gpu/drm/amd/pm/swsmu/smu11/vangogh_ppt.c
index 85e2f9260..1fe020f1f 100644
--- a/drivers/gpu/drm/amd/pm/swsmu/smu11/vangogh_ppt.c
+++ b/drivers/gpu/drm/amd/pm/swsmu/smu11/vangogh_ppt.c
@@ -1054,27 +1054,42 @@ static int vangogh_get_power_profile_mode(struct smu_context *smu,
 	return size;
 }
 
-static int vangogh_set_power_profile_mode(struct smu_context *smu,
-					  u32 workload_mask)
+static int vangogh_set_power_profile_mode(struct smu_context *smu, long *input, uint32_t size)
 {
-	u32 backend_workload_mask = 0;
-	bool custom_enabled = false;
-	int ret;
+	int workload_type, ret;
+	uint32_t profile_mode = input[size];
 
-	smu_cmn_get_backend_workload_mask(smu, workload_mask,
-					  &backend_workload_mask,
-					  &custom_enabled);
+	if (profile_mode >= PP_SMC_POWER_PROFILE_COUNT) {
+		dev_err(smu->adev->dev, "Invalid power profile mode %d\n", profile_mode);
+		return -EINVAL;
+	}
+
+	if (profile_mode == PP_SMC_POWER_PROFILE_BOOTUP_DEFAULT ||
+			profile_mode == PP_SMC_POWER_PROFILE_POWERSAVING)
+		return 0;
+
+	/* conv PP_SMC_POWER_PROFILE* to WORKLOAD_PPLIB_*_BIT */
+	workload_type = smu_cmn_to_asic_specific_index(smu,
+						       CMN2ASIC_MAPPING_WORKLOAD,
+						       profile_mode);
+	if (workload_type < 0) {
+		dev_dbg(smu->adev->dev, "Unsupported power profile mode %d on VANGOGH\n",
+					profile_mode);
+		return -EINVAL;
+	}
 
 	ret = smu_cmn_send_smc_msg_with_param(smu, SMU_MSG_ActiveProcessNotify,
-					      backend_workload_mask,
-					      NULL);
+				    1 << workload_type,
+				    NULL);
 	if (ret) {
-		dev_err_once(smu->adev->dev, "Fail to set workload mask 0x%08x\n",
-			     workload_mask);
+		dev_err_once(smu->adev->dev, "Fail to set workload type %d\n",
+					workload_type);
 		return ret;
 	}
 
-	return ret;
+	smu->power_profile_mode = profile_mode;
+
+	return 0;
 }
 
 static int vangogh_set_soft_freq_limited_range(struct smu_context *smu,
diff --git a/drivers/gpu/drm/amd/pm/swsmu/smu12/renoir_ppt.c b/drivers/gpu/drm/amd/pm/swsmu/smu12/renoir_ppt.c
index 70dd631c4..cc0504b06 100644
--- a/drivers/gpu/drm/amd/pm/swsmu/smu12/renoir_ppt.c
+++ b/drivers/gpu/drm/amd/pm/swsmu/smu12/renoir_ppt.c
@@ -862,27 +862,44 @@ static int renoir_force_clk_levels(struct smu_context *smu,
 	return ret;
 }
 
-static int renoir_set_power_profile_mode(struct smu_context *smu,
-					 u32 workload_mask)
+static int renoir_set_power_profile_mode(struct smu_context *smu, long *input, uint32_t size)
 {
-	int ret;
-	u32 backend_workload_mask = 0;
-	bool custom_enabled = false;
+	int workload_type, ret;
+	uint32_t profile_mode = input[size];
 
-	smu_cmn_get_backend_workload_mask(smu, workload_mask,
-					  &backend_workload_mask,
-					  &custom_enabled);
+	if (profile_mode > PP_SMC_POWER_PROFILE_CUSTOM) {
+		dev_err(smu->adev->dev, "Invalid power profile mode %d\n", profile_mode);
+		return -EINVAL;
+	}
+
+	if (profile_mode == PP_SMC_POWER_PROFILE_BOOTUP_DEFAULT ||
+			profile_mode == PP_SMC_POWER_PROFILE_POWERSAVING)
+		return 0;
+
+	/* conv PP_SMC_POWER_PROFILE* to WORKLOAD_PPLIB_*_BIT */
+	workload_type = smu_cmn_to_asic_specific_index(smu,
+						       CMN2ASIC_MAPPING_WORKLOAD,
+						       profile_mode);
+	if (workload_type < 0) {
+		/*
+		 * TODO: If some case need switch to powersave/default power mode
+		 * then can consider enter WORKLOAD_COMPUTE/WORKLOAD_CUSTOM for power saving.
+		 */
+		dev_dbg(smu->adev->dev, "Unsupported power profile mode %d on RENOIR\n", profile_mode);
+		return -EINVAL;
+	}
 
 	ret = smu_cmn_send_smc_msg_with_param(smu, SMU_MSG_ActiveProcessNotify,
-					      backend_workload_mask,
-					      NULL);
+				    1 << workload_type,
+				    NULL);
 	if (ret) {
-		dev_err_once(smu->adev->dev, "Failed to set workload mask 0x08%x\n",
-			     workload_mask);
+		dev_err_once(smu->adev->dev, "Fail to set workload type %d\n", workload_type);
 		return ret;
 	}
 
-	return ret;
+	smu->power_profile_mode = profile_mode;
+
+	return 0;
 }
 
 static int renoir_set_peak_clock_by_device(struct smu_context *smu)
diff --git a/drivers/gpu/drm/amd/pm/swsmu/smu13/smu_v13_0_0_ppt.c b/drivers/gpu/drm/amd/pm/swsmu/smu13/smu_v13_0_0_ppt.c
index 9dfa01db0..24675a1d9 100644
--- a/drivers/gpu/drm/amd/pm/swsmu/smu13/smu_v13_0_0_ppt.c
+++ b/drivers/gpu/drm/amd/pm/swsmu/smu13/smu_v13_0_0_ppt.c
@@ -2583,76 +2583,82 @@ static int smu_v13_0_0_get_power_profile_mode(struct smu_context *smu,
 	return size;
 }
 
-static int smu_v13_0_0_set_power_profile_mode_coeff(struct smu_context *smu,
-						    long *input,
-						    uint32_t size)
+static int smu_v13_0_0_set_power_profile_mode(struct smu_context *smu,
+					      long *input,
+					      uint32_t size)
 {
 	DpmActivityMonitorCoeffIntExternal_t activity_monitor_external;
 	DpmActivityMonitorCoeffInt_t *activity_monitor =
 		&(activity_monitor_external.DpmActivityMonitorCoeffInt);
-	int ret;
+	int workload_type, ret = 0;
+	u32 workload_mask, selected_workload_mask;
 
-	if (size != 9)
-		return -EINVAL;
+	smu->power_profile_mode = input[size];
 
-	ret = smu_cmn_update_table(smu,
-				   SMU_TABLE_ACTIVITY_MONITOR_COEFF,
-				   WORKLOAD_PPLIB_CUSTOM_BIT,
-				   (void *)(&activity_monitor_external),
-				   false);
-	if (ret) {
-		dev_err(smu->adev->dev, "[%s] Failed to get activity monitor!", __func__);
-		return ret;
-	}
-
-	switch (input[0]) {
-	case 0: /* Gfxclk */
-		activity_monitor->Gfx_FPS = input[1];
-		activity_monitor->Gfx_MinActiveFreqType = input[2];
-		activity_monitor->Gfx_MinActiveFreq = input[3];
-		activity_monitor->Gfx_BoosterFreqType = input[4];
-		activity_monitor->Gfx_BoosterFreq = input[5];
-		activity_monitor->Gfx_PD_Data_limit_c = input[6];
-		activity_monitor->Gfx_PD_Data_error_coeff = input[7];
-		activity_monitor->Gfx_PD_Data_error_rate_coeff = input[8];
-		break;
-	case 1: /* Fclk */
-		activity_monitor->Fclk_FPS = input[1];
-		activity_monitor->Fclk_MinActiveFreqType = input[2];
-		activity_monitor->Fclk_MinActiveFreq = input[3];
-		activity_monitor->Fclk_BoosterFreqType = input[4];
-		activity_monitor->Fclk_BoosterFreq = input[5];
-		activity_monitor->Fclk_PD_Data_limit_c = input[6];
-		activity_monitor->Fclk_PD_Data_error_coeff = input[7];
-		activity_monitor->Fclk_PD_Data_error_rate_coeff = input[8];
-		break;
-	default:
+	if (smu->power_profile_mode >= PP_SMC_POWER_PROFILE_COUNT) {
+		dev_err(smu->adev->dev, "Invalid power profile mode %d\n", smu->power_profile_mode);
 		return -EINVAL;
 	}
 
-	ret = smu_cmn_update_table(smu,
-				   SMU_TABLE_ACTIVITY_MONITOR_COEFF,
-				   WORKLOAD_PPLIB_CUSTOM_BIT,
-				   (void *)(&activity_monitor_external),
-				   true);
-	if (ret) {
-		dev_err(smu->adev->dev, "[%s] Failed to set activity monitor!", __func__);
-		return ret;
+	if (smu->power_profile_mode == PP_SMC_POWER_PROFILE_CUSTOM) {
+		if (size != 9)
+			return -EINVAL;
+
+		ret = smu_cmn_update_table(smu,
+					   SMU_TABLE_ACTIVITY_MONITOR_COEFF,
+					   WORKLOAD_PPLIB_CUSTOM_BIT,
+					   (void *)(&activity_monitor_external),
+					   false);
+		if (ret) {
+			dev_err(smu->adev->dev, "[%s] Failed to get activity monitor!", __func__);
+			return ret;
+		}
+
+		switch (input[0]) {
+		case 0: /* Gfxclk */
+			activity_monitor->Gfx_FPS = input[1];
+			activity_monitor->Gfx_MinActiveFreqType = input[2];
+			activity_monitor->Gfx_MinActiveFreq = input[3];
+			activity_monitor->Gfx_BoosterFreqType = input[4];
+			activity_monitor->Gfx_BoosterFreq = input[5];
+			activity_monitor->Gfx_PD_Data_limit_c = input[6];
+			activity_monitor->Gfx_PD_Data_error_coeff = input[7];
+			activity_monitor->Gfx_PD_Data_error_rate_coeff = input[8];
+			break;
+		case 1: /* Fclk */
+			activity_monitor->Fclk_FPS = input[1];
+			activity_monitor->Fclk_MinActiveFreqType = input[2];
+			activity_monitor->Fclk_MinActiveFreq = input[3];
+			activity_monitor->Fclk_BoosterFreqType = input[4];
+			activity_monitor->Fclk_BoosterFreq = input[5];
+			activity_monitor->Fclk_PD_Data_limit_c = input[6];
+			activity_monitor->Fclk_PD_Data_error_coeff = input[7];
+			activity_monitor->Fclk_PD_Data_error_rate_coeff = input[8];
+			break;
+		default:
+			return -EINVAL;
+		}
+
+		ret = smu_cmn_update_table(smu,
+					   SMU_TABLE_ACTIVITY_MONITOR_COEFF,
+					   WORKLOAD_PPLIB_CUSTOM_BIT,
+					   (void *)(&activity_monitor_external),
+					   true);
+		if (ret) {
+			dev_err(smu->adev->dev, "[%s] Failed to set activity monitor!", __func__);
+			return ret;
+		}
 	}
 
-	return ret;
-}
+	/* conv PP_SMC_POWER_PROFILE* to WORKLOAD_PPLIB_*_BIT */
+	workload_type = smu_cmn_to_asic_specific_index(smu,
+						       CMN2ASIC_MAPPING_WORKLOAD,
+						       smu->power_profile_mode);
 
-static int smu_v13_0_0_set_power_profile_mode(struct smu_context *smu,
-					      u32 workload_mask)
-{
-	u32 backend_workload_mask = 0;
-	bool custom_enabled = false;
-	int workload_type, ret;
+	if (workload_type < 0)
+		return -EINVAL;
 
-	smu_cmn_get_backend_workload_mask(smu, workload_mask,
-					  &backend_workload_mask,
-					  &custom_enabled);
+	selected_workload_mask = workload_mask = 1 << workload_type;
 
 	/* Add optimizations for SMU13.0.0/10.  Reuse the power saving profile */
 	if ((amdgpu_ip_version(smu->adev, MP1_HWIP, 0) == IP_VERSION(13, 0, 0) &&
@@ -2664,26 +2670,15 @@ static int smu_v13_0_0_set_power_profile_mode(struct smu_context *smu,
 							       CMN2ASIC_MAPPING_WORKLOAD,
 							       PP_SMC_POWER_PROFILE_POWERSAVING);
 		if (workload_type >= 0)
-			backend_workload_mask |= 1 << workload_type;
-	}
-
-	if (custom_enabled) {
-		ret = smu_v13_0_0_set_power_profile_mode_coeff(smu,
-							       smu->custom_profile_input,
-							       smu->custom_profile_size);
-		if (ret)
-			return ret;
+			workload_mask |= 1 << workload_type;
 	}
 
 	ret = smu_cmn_send_smc_msg_with_param(smu,
-					      SMU_MSG_SetWorkloadMask,
-					      backend_workload_mask,
-					      NULL);
-	if (ret) {
-		dev_err(smu->adev->dev, "Failed to set workload mask 0x%08x\n",
-			workload_mask);
-		return ret;
-	}
+					       SMU_MSG_SetWorkloadMask,
+					       workload_mask,
+					       NULL);
+	if (!ret)
+		smu->workload_mask = selected_workload_mask;
 
 	return ret;
 }
diff --git a/drivers/gpu/drm/amd/pm/swsmu/smu13/smu_v13_0_7_ppt.c b/drivers/gpu/drm/amd/pm/swsmu/smu13/smu_v13_0_7_ppt.c
index 3ae328348..50d16301f 100644
--- a/drivers/gpu/drm/amd/pm/swsmu/smu13/smu_v13_0_7_ppt.c
+++ b/drivers/gpu/drm/amd/pm/swsmu/smu13/smu_v13_0_7_ppt.c
@@ -2540,87 +2540,78 @@ do {													\
 	return result;
 }
 
-static int smu_v13_0_7_set_power_profile_mode_coeff(struct smu_context *smu,
-						    long *input, uint32_t size)
+static int smu_v13_0_7_set_power_profile_mode(struct smu_context *smu, long *input, uint32_t size)
 {
 
 	DpmActivityMonitorCoeffIntExternal_t activity_monitor_external;
 	DpmActivityMonitorCoeffInt_t *activity_monitor =
 		&(activity_monitor_external.DpmActivityMonitorCoeffInt);
-	int ret;
+	int workload_type, ret = 0;
 
-	if (size != 8)
-		return -EINVAL;
+	smu->power_profile_mode = input[size];
 
-	ret = smu_cmn_update_table(smu,
-				   SMU_TABLE_ACTIVITY_MONITOR_COEFF, WORKLOAD_PPLIB_CUSTOM_BIT,
-				   (void *)(&activity_monitor_external), false);
-	if (ret) {
-		dev_err(smu->adev->dev, "[%s] Failed to get activity monitor!", __func__);
-		return ret;
-	}
-
-	switch (input[0]) {
-	case 0: /* Gfxclk */
-		activity_monitor->Gfx_ActiveHystLimit = input[1];
-		activity_monitor->Gfx_IdleHystLimit = input[2];
-		activity_monitor->Gfx_FPS = input[3];
-		activity_monitor->Gfx_MinActiveFreqType = input[4];
-		activity_monitor->Gfx_BoosterFreqType = input[5];
-		activity_monitor->Gfx_MinActiveFreq = input[6];
-		activity_monitor->Gfx_BoosterFreq = input[7];
-		break;
-	case 1: /* Fclk */
-		activity_monitor->Fclk_ActiveHystLimit = input[1];
-		activity_monitor->Fclk_IdleHystLimit = input[2];
-		activity_monitor->Fclk_FPS = input[3];
-		activity_monitor->Fclk_MinActiveFreqType = input[4];
-		activity_monitor->Fclk_BoosterFreqType = input[5];
-		activity_monitor->Fclk_MinActiveFreq = input[6];
-		activity_monitor->Fclk_BoosterFreq = input[7];
-		break;
-	default:
+	if (smu->power_profile_mode > PP_SMC_POWER_PROFILE_WINDOW3D) {
+		dev_err(smu->adev->dev, "Invalid power profile mode %d\n", smu->power_profile_mode);
 		return -EINVAL;
 	}
 
-	ret = smu_cmn_update_table(smu,
-				   SMU_TABLE_ACTIVITY_MONITOR_COEFF, WORKLOAD_PPLIB_CUSTOM_BIT,
-				   (void *)(&activity_monitor_external), true);
-	if (ret) {
-		dev_err(smu->adev->dev, "[%s] Failed to set activity monitor!", __func__);
-		return ret;
-	}
-
-	return ret;
-}
+	if (smu->power_profile_mode == PP_SMC_POWER_PROFILE_CUSTOM) {
+		if (size != 8)
+			return -EINVAL;
 
-static int smu_v13_0_7_set_power_profile_mode(struct smu_context *smu,
-					      u32 workload_mask)
-{
-	u32 backend_workload_mask = 0;
-	bool custom_enabled = false;
-	int ret;
+		ret = smu_cmn_update_table(smu,
+				       SMU_TABLE_ACTIVITY_MONITOR_COEFF, WORKLOAD_PPLIB_CUSTOM_BIT,
+				       (void *)(&activity_monitor_external), false);
+		if (ret) {
+			dev_err(smu->adev->dev, "[%s] Failed to get activity monitor!", __func__);
+			return ret;
+		}
 
-	smu_cmn_get_backend_workload_mask(smu, workload_mask,
-					  &backend_workload_mask,
-					  &custom_enabled);
+		switch (input[0]) {
+		case 0: /* Gfxclk */
+			activity_monitor->Gfx_ActiveHystLimit = input[1];
+			activity_monitor->Gfx_IdleHystLimit = input[2];
+			activity_monitor->Gfx_FPS = input[3];
+			activity_monitor->Gfx_MinActiveFreqType = input[4];
+			activity_monitor->Gfx_BoosterFreqType = input[5];
+			activity_monitor->Gfx_MinActiveFreq = input[6];
+			activity_monitor->Gfx_BoosterFreq = input[7];
+			break;
+		case 1: /* Fclk */
+			activity_monitor->Fclk_ActiveHystLimit = input[1];
+			activity_monitor->Fclk_IdleHystLimit = input[2];
+			activity_monitor->Fclk_FPS = input[3];
+			activity_monitor->Fclk_MinActiveFreqType = input[4];
+			activity_monitor->Fclk_BoosterFreqType = input[5];
+			activity_monitor->Fclk_MinActiveFreq = input[6];
+			activity_monitor->Fclk_BoosterFreq = input[7];
+			break;
+		default:
+			return -EINVAL;
+		}
 
-	if (custom_enabled) {
-		ret = smu_v13_0_7_set_power_profile_mode_coeff(smu,
-							       smu->custom_profile_input,
-							       smu->custom_profile_size);
-		if (ret)
+		ret = smu_cmn_update_table(smu,
+				       SMU_TABLE_ACTIVITY_MONITOR_COEFF, WORKLOAD_PPLIB_CUSTOM_BIT,
+				       (void *)(&activity_monitor_external), true);
+		if (ret) {
+			dev_err(smu->adev->dev, "[%s] Failed to set activity monitor!", __func__);
 			return ret;
+		}
 	}
 
+	/* conv PP_SMC_POWER_PROFILE* to WORKLOAD_PPLIB_*_BIT */
+	workload_type = smu_cmn_to_asic_specific_index(smu,
+						       CMN2ASIC_MAPPING_WORKLOAD,
+						       smu->power_profile_mode);
+	if (workload_type < 0)
+		return -EINVAL;
 	ret = smu_cmn_send_smc_msg_with_param(smu, SMU_MSG_SetWorkloadMask,
-					      backend_workload_mask, NULL);
+				    1 << workload_type, NULL);
 
-	if (ret) {
-		dev_err(smu->adev->dev, "Failed to set workload mask 0x%08x\n",
-			workload_mask);
-		return ret;
-	}
+	if (ret)
+		dev_err(smu->adev->dev, "[%s] Failed to set work load mask!", __func__);
+	else
+		smu->workload_mask = (1 << workload_type);
 
 	return ret;
 }
diff --git a/drivers/gpu/drm/amd/pm/swsmu/smu14/smu_v14_0_2_ppt.c b/drivers/gpu/drm/amd/pm/swsmu/smu14/smu_v14_0_2_ppt.c
index aa147105a..1e16a281f 100644
--- a/drivers/gpu/drm/amd/pm/swsmu/smu14/smu_v14_0_2_ppt.c
+++ b/drivers/gpu/drm/amd/pm/swsmu/smu14/smu_v14_0_2_ppt.c
@@ -1729,98 +1729,90 @@ static int smu_v14_0_2_get_power_profile_mode(struct smu_context *smu,
 	return size;
 }
 
-static int smu_v14_0_2_set_power_profile_mode_coeff(struct smu_context *smu,
-						    long *input,
-						    uint32_t size)
+static int smu_v14_0_2_set_power_profile_mode(struct smu_context *smu,
+					      long *input,
+					      uint32_t size)
 {
 	DpmActivityMonitorCoeffIntExternal_t activity_monitor_external;
 	DpmActivityMonitorCoeffInt_t *activity_monitor =
 		&(activity_monitor_external.DpmActivityMonitorCoeffInt);
-	int ret;
-
-	if (size != 9)
-		return -EINVAL;
+	int workload_type, ret = 0;
+	uint32_t current_profile_mode = smu->power_profile_mode;
+	smu->power_profile_mode = input[size];
 
-	ret = smu_cmn_update_table(smu,
-				   SMU_TABLE_ACTIVITY_MONITOR_COEFF,
-				   WORKLOAD_PPLIB_CUSTOM_BIT,
-				   (void *)(&activity_monitor_external),
-				   false);
-	if (ret) {
-		dev_err(smu->adev->dev, "[%s] Failed to get activity monitor!", __func__);
-		return ret;
-	}
-
-	switch (input[0]) {
-	case 0: /* Gfxclk */
-		activity_monitor->Gfx_FPS = input[1];
-		activity_monitor->Gfx_MinActiveFreqType = input[2];
-		activity_monitor->Gfx_MinActiveFreq = input[3];
-		activity_monitor->Gfx_BoosterFreqType = input[4];
-		activity_monitor->Gfx_BoosterFreq = input[5];
-		activity_monitor->Gfx_PD_Data_limit_c = input[6];
-		activity_monitor->Gfx_PD_Data_error_coeff = input[7];
-		activity_monitor->Gfx_PD_Data_error_rate_coeff = input[8];
-		break;
-	case 1: /* Fclk */
-		activity_monitor->Fclk_FPS = input[1];
-		activity_monitor->Fclk_MinActiveFreqType = input[2];
-		activity_monitor->Fclk_MinActiveFreq = input[3];
-		activity_monitor->Fclk_BoosterFreqType = input[4];
-		activity_monitor->Fclk_BoosterFreq = input[5];
-		activity_monitor->Fclk_PD_Data_limit_c = input[6];
-		activity_monitor->Fclk_PD_Data_error_coeff = input[7];
-		activity_monitor->Fclk_PD_Data_error_rate_coeff = input[8];
-		break;
-	default:
+	if (smu->power_profile_mode >= PP_SMC_POWER_PROFILE_COUNT) {
+		dev_err(smu->adev->dev, "Invalid power profile mode %d\n", smu->power_profile_mode);
 		return -EINVAL;
 	}
 
-	ret = smu_cmn_update_table(smu,
-				   SMU_TABLE_ACTIVITY_MONITOR_COEFF,
-				   WORKLOAD_PPLIB_CUSTOM_BIT,
-				   (void *)(&activity_monitor_external),
-				   true);
-	if (ret) {
-		dev_err(smu->adev->dev, "[%s] Failed to set activity monitor!", __func__);
-		return ret;
-	}
+	if (smu->power_profile_mode == PP_SMC_POWER_PROFILE_CUSTOM) {
+		if (size != 9)
+			return -EINVAL;
 
-	return ret;
-}
+		ret = smu_cmn_update_table(smu,
+					   SMU_TABLE_ACTIVITY_MONITOR_COEFF,
+					   WORKLOAD_PPLIB_CUSTOM_BIT,
+					   (void *)(&activity_monitor_external),
+					   false);
+		if (ret) {
+			dev_err(smu->adev->dev, "[%s] Failed to get activity monitor!", __func__);
+			return ret;
+		}
 
-static int smu_v14_0_2_set_power_profile_mode(struct smu_context *smu,
-					      u32 workload_mask)
-{
-	u32 backend_workload_mask = 0;
-	bool custom_enabled = false;
-	int ret;
+		switch (input[0]) {
+		case 0: /* Gfxclk */
+			activity_monitor->Gfx_FPS = input[1];
+			activity_monitor->Gfx_MinActiveFreqType = input[2];
+			activity_monitor->Gfx_MinActiveFreq = input[3];
+			activity_monitor->Gfx_BoosterFreqType = input[4];
+			activity_monitor->Gfx_BoosterFreq = input[5];
+			activity_monitor->Gfx_PD_Data_limit_c = input[6];
+			activity_monitor->Gfx_PD_Data_error_coeff = input[7];
+			activity_monitor->Gfx_PD_Data_error_rate_coeff = input[8];
+			break;
+		case 1: /* Fclk */
+			activity_monitor->Fclk_FPS = input[1];
+			activity_monitor->Fclk_MinActiveFreqType = input[2];
+			activity_monitor->Fclk_MinActiveFreq = input[3];
+			activity_monitor->Fclk_BoosterFreqType = input[4];
+			activity_monitor->Fclk_BoosterFreq = input[5];
+			activity_monitor->Fclk_PD_Data_limit_c = input[6];
+			activity_monitor->Fclk_PD_Data_error_coeff = input[7];
+			activity_monitor->Fclk_PD_Data_error_rate_coeff = input[8];
+			break;
+		default:
+			return -EINVAL;
+		}
 
-	smu_cmn_get_backend_workload_mask(smu, workload_mask,
-					  &backend_workload_mask,
-					  &custom_enabled);
+		ret = smu_cmn_update_table(smu,
+					   SMU_TABLE_ACTIVITY_MONITOR_COEFF,
+					   WORKLOAD_PPLIB_CUSTOM_BIT,
+					   (void *)(&activity_monitor_external),
+					   true);
+		if (ret) {
+			dev_err(smu->adev->dev, "[%s] Failed to set activity monitor!", __func__);
+			return ret;
+		}
+	}
 
-	/* disable deep sleep if compute is enabled */
-	if (workload_mask & (1 << PP_SMC_POWER_PROFILE_COMPUTE))
+	if (smu->power_profile_mode == PP_SMC_POWER_PROFILE_COMPUTE)
 		smu_v14_0_deep_sleep_control(smu, false);
-	else
+	else if (current_profile_mode == PP_SMC_POWER_PROFILE_COMPUTE)
 		smu_v14_0_deep_sleep_control(smu, true);
 
-	if (custom_enabled) {
-		ret = smu_v14_0_2_set_power_profile_mode_coeff(smu,
-							       smu->custom_profile_input,
-							       smu->custom_profile_size);
-		if (ret)
-			return ret;
-	}
+	/* conv PP_SMC_POWER_PROFILE* to WORKLOAD_PPLIB_*_BIT */
+	workload_type = smu_cmn_to_asic_specific_index(smu,
+						       CMN2ASIC_MAPPING_WORKLOAD,
+						       smu->power_profile_mode);
+	if (workload_type < 0)
+		return -EINVAL;
 
-	ret = smu_cmn_send_smc_msg_with_param(smu, SMU_MSG_SetWorkloadMask,
-					      backend_workload_mask, NULL);
-	if (ret) {
-		dev_err(smu->adev->dev, "Failed to set workload mask 0x%08x\n",
-			workload_mask);
-		return ret;
-	}
+	ret = smu_cmn_send_smc_msg_with_param(smu,
+					       SMU_MSG_SetWorkloadMask,
+					       1 << workload_type,
+					       NULL);
+	if (!ret)
+		smu->workload_mask = 1 << workload_type;
 
 	return ret;
 }
diff --git a/drivers/gpu/drm/amd/pm/swsmu/smu_cmn.c b/drivers/gpu/drm/amd/pm/swsmu/smu_cmn.c
index 79406463a..91ad434bc 100644
--- a/drivers/gpu/drm/amd/pm/swsmu/smu_cmn.c
+++ b/drivers/gpu/drm/amd/pm/swsmu/smu_cmn.c
@@ -1215,33 +1215,3 @@ void smu_cmn_generic_plpd_policy_desc(struct smu_dpm_policy *policy)
 {
 	policy->desc = &xgmi_plpd_policy_desc;
 }
-
-void smu_cmn_get_backend_workload_mask(struct smu_context *smu,
-				       u32 workload_mask,
-				       u32 *backend_workload_mask,
-				       bool *custom_enabled)
-{
-	int workload_type;
-	u32 profile_mode;
-
-	*custom_enabled = false;
-	*backend_workload_mask = 0;
-
-	for (profile_mode = 0; profile_mode < PP_SMC_POWER_PROFILE_COUNT; profile_mode++) {
-		if (!(workload_mask & (1 << profile_mode)))
-			continue;
-
-		/* conv PP_SMC_POWER_PROFILE* to WORKLOAD_PPLIB_*_BIT */
-		workload_type = smu_cmn_to_asic_specific_index(smu,
-							       CMN2ASIC_MAPPING_WORKLOAD,
-							       profile_mode);
-
-		if (workload_type < 0)
-			continue;
-
-		*backend_workload_mask |= 1 << workload_type;
-
-		if (profile_mode == PP_SMC_POWER_PROFILE_CUSTOM)
-			*custom_enabled = true;
-	}
-}
diff --git a/drivers/gpu/drm/amd/pm/swsmu/smu_cmn.h b/drivers/gpu/drm/amd/pm/swsmu/smu_cmn.h
index 8d40c02ef..1de685def 100644
--- a/drivers/gpu/drm/amd/pm/swsmu/smu_cmn.h
+++ b/drivers/gpu/drm/amd/pm/swsmu/smu_cmn.h
@@ -147,10 +147,5 @@ bool smu_cmn_is_audio_func_enabled(struct amdgpu_device *adev);
 void smu_cmn_generic_soc_policy_desc(struct smu_dpm_policy *policy);
 void smu_cmn_generic_plpd_policy_desc(struct smu_dpm_policy *policy);
 
-void smu_cmn_get_backend_workload_mask(struct smu_context *smu,
-				       u32 workload_mask,
-				       u32 *backend_workload_mask,
-				       bool *custom_enabled);
-
 #endif
 #endif
-- 
2.47.0

