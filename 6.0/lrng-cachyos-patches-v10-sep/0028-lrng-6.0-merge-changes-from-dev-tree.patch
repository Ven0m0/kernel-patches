From e1bfe443d7d1b5568a311096d356dc2ccc91e897 Mon Sep 17 00:00:00 2001
From: Piotr Gorski <lucjan.lucjanov@gmail.com>
Date: Fri, 14 Oct 2022 10:31:07 +0200
Subject: [PATCH 28/29] lrng-6.0: merge changes from dev tree

Signed-off-by: Piotr Gorski <lucjan.lucjanov@gmail.com>
---
 drivers/char/lrng/lrng_definitions.h |  7 +++
 drivers/char/lrng/lrng_drng_atomic.c |  2 +-
 drivers/char/lrng/lrng_drng_mgr.c    | 66 +++++++++++++++++++++++-----
 drivers/char/lrng/lrng_es_mgr.c      | 49 ++++++++++++++++-----
 drivers/char/lrng/lrng_es_mgr.h      |  7 +--
 drivers/char/lrng/lrng_proc.c        |  2 +-
 6 files changed, 105 insertions(+), 28 deletions(-)

diff --git a/drivers/char/lrng/lrng_definitions.h b/drivers/char/lrng/lrng_definitions.h
index c0d2fcff8..f1059334e 100644
--- a/drivers/char/lrng/lrng_definitions.h
+++ b/drivers/char/lrng/lrng_definitions.h
@@ -121,6 +121,13 @@
  */
 #define LRNG_POOL_SIZE	(sizeof(struct shash_desc) + HASH_MAX_DESCSIZE)
 
+/*
+ * How many attempts to reach fully seeded are allowed before trying to force
+ * reseed from available entropy (pull data from entropy sources in a repeated
+ * fashion allowing to sum up the entropy).
+ */
+#define LRNG_FORCE_FULLY_SEEDED_ATTEMPT	5
+
 /****************************** Helper code ***********************************/
 
 static inline u32 lrng_fast_noise_entropylevel(u32 ent_bits, u32 requested_bits)
diff --git a/drivers/char/lrng/lrng_drng_atomic.c b/drivers/char/lrng/lrng_drng_atomic.c
index b58a32017..ce9b5b48d 100644
--- a/drivers/char/lrng/lrng_drng_atomic.c
+++ b/drivers/char/lrng/lrng_drng_atomic.c
@@ -118,7 +118,7 @@ void lrng_drng_atomic_seed_es(void)
 	pr_debug("atomic DRNG seeding attempt to pull %u bits of entropy directly from entropy sources\n",
 		 requested_bits);
 
-	lrng_fill_seed_buffer(&seedbuf, requested_bits);
+	lrng_fill_seed_buffer(&seedbuf, requested_bits, false);
 	spin_lock_irqsave(&drng->spin_lock, flags);
 	lrng_drng_inject(&lrng_drng_atomic, (u8 *)&seedbuf, sizeof(seedbuf),
 			 lrng_fully_seeded(drng->fully_seeded,
diff --git a/drivers/char/lrng/lrng_drng_mgr.c b/drivers/char/lrng/lrng_drng_mgr.c
index 7ac03fc07..c1f743221 100644
--- a/drivers/char/lrng/lrng_drng_mgr.c
+++ b/drivers/char/lrng/lrng_drng_mgr.c
@@ -244,20 +244,58 @@ void lrng_drng_inject(struct lrng_drng *drng, const u8 *inbuf, u32 inbuflen,
  */
 static u32 lrng_drng_seed_es_nolock(struct lrng_drng *drng)
 {
-	struct entropy_buf seedbuf __aligned(LRNG_KCAPI_ALIGN);
-	u32 collected_entropy;
+	struct entropy_buf seedbuf __aligned(LRNG_KCAPI_ALIGN),
+			   collected_seedbuf;
+	u32 collected_entropy = 0;
+	unsigned int i, num_es_delivered = 0;
+	bool force = lrng_state_min_seeded() > LRNG_FORCE_FULLY_SEEDED_ATTEMPT;
 
-	lrng_fill_seed_buffer(&seedbuf,
-			      lrng_get_seed_entropy_osr(drng->fully_seeded));
+	for_each_lrng_es(i)
+		collected_seedbuf.e_bits[i] = 0;
 
-	collected_entropy = lrng_entropy_rate_eb(&seedbuf);
-	lrng_drng_inject(drng, (u8 *)&seedbuf, sizeof(seedbuf),
-			 lrng_fully_seeded(drng->fully_seeded,
-					   collected_entropy, &seedbuf),
-			 "regular");
+	do {
+		/* Count the number of ES which delivered entropy */
+		num_es_delivered = 0;
 
-	/* Set the seeding state of the LRNG */
-	lrng_init_ops(&seedbuf);
+		if (collected_entropy)
+			pr_debug("Force fully seeding level by repeatedly pull entropy from available entropy sources\n");
+
+		lrng_fill_seed_buffer(&seedbuf,
+			lrng_get_seed_entropy_osr(drng->fully_seeded), force);
+
+		collected_entropy += lrng_entropy_rate_eb(&seedbuf);
+
+		/* Sum iterations up. */
+		for_each_lrng_es(i) {
+			collected_seedbuf.e_bits[i] += seedbuf.e_bits[i];
+			num_es_delivered += !!seedbuf.e_bits[i];
+		}
+
+		lrng_drng_inject(drng, (u8 *)&seedbuf, sizeof(seedbuf),
+				 lrng_fully_seeded(drng->fully_seeded,
+						   collected_entropy,
+						   &collected_seedbuf),
+				 "regular");
+
+		/* Set the seeding state of the LRNG */
+		lrng_init_ops(&collected_seedbuf);
+
+	/*
+	 * Emergency reseeding: If we reached the min seed threshold now
+	 * multiple times but never reached fully seeded level and we collect
+	 * entropy, keep doing it until we reached fully seeded level for
+	 * at least one DRNG. This operation is not continued if the
+	 * ES do not deliver entropy such that we cannot reach the fully seeded
+	 * level.
+	 *
+	 * The emergency reseeding implies that the consecutively injected
+	 * entropy can be added up. This is applicable due to the fact that
+	 * the entire operation is atomic which means that the DRNG is not
+	 * producing data while this is ongoing.
+	 */
+	} while (force &&
+		 num_es_delivered >= (lrng_ntg1_2022_compliant() ? 2 : 1) &&
+		 !drng->fully_seeded);
 
 	memzero_explicit(&seedbuf, sizeof(seedbuf));
 
@@ -541,6 +579,7 @@ void lrng_reset(void)
 
 static int lrng_drng_sleep_while_not_all_nodes_seeded(unsigned int nonblock)
 {
+	lrng_es_add_entropy();
 	if (lrng_pool_all_numa_nodes_seeded_get())
 		return 0;
 	if (nonblock)
@@ -552,6 +591,7 @@ static int lrng_drng_sleep_while_not_all_nodes_seeded(unsigned int nonblock)
 
 int lrng_drng_sleep_while_nonoperational(int nonblock)
 {
+	lrng_es_add_entropy();
 	if (likely(lrng_state_operational()))
 		return 0;
 	if (nonblock)
@@ -562,6 +602,7 @@ int lrng_drng_sleep_while_nonoperational(int nonblock)
 
 int lrng_drng_sleep_while_non_min_seeded(void)
 {
+	lrng_es_add_entropy();
 	if (likely(lrng_state_min_seeded()))
 		return 0;
 	return wait_event_interruptible(lrng_init_wait,
@@ -607,7 +648,8 @@ ssize_t lrng_get_seed(u64 *buf, size_t nbytes, unsigned int flags)
 	for (;;) {
 		lrng_fill_seed_buffer(eb,
 			lrng_get_seed_entropy_osr(flags &
-						  LRNG_GET_SEED_FULLY_SEEDED));
+						  LRNG_GET_SEED_FULLY_SEEDED),
+						  false);
 		collected_bits = lrng_entropy_rate_eb(eb);
 
 		/* Break the collection loop if we got entropy, ... */
diff --git a/drivers/char/lrng/lrng_es_mgr.c b/drivers/char/lrng/lrng_es_mgr.c
index 9bfcae617..0c3797e34 100644
--- a/drivers/char/lrng/lrng_es_mgr.c
+++ b/drivers/char/lrng/lrng_es_mgr.c
@@ -28,8 +28,8 @@ struct lrng_state {
 	bool perform_seedwork;		/* Can seed work be performed? */
 	bool lrng_operational;		/* Is DRNG operational? */
 	bool lrng_fully_seeded;		/* Is DRNG fully seeded? */
-	bool lrng_min_seeded;		/* Is DRNG minimally seeded? */
 	bool all_online_numa_node_seeded;/* All NUMA DRNGs seeded? */
+	unsigned char lrng_min_seeded;	/* Is DRNG minimally seeded? */
 
 	/*
 	 * To ensure that external entropy providers cannot dominate the
@@ -90,7 +90,7 @@ MODULE_PARM_DESC(ntg1, "Enable AIS20/31 NTG.1 compliant seeding strategy\n");
 
 /********************************** Helper ***********************************/
 
-bool lrng_ntg1_compliant(void)
+bool lrng_ntg1_2022_compliant(void)
 {
 	/* Implies use of /dev/random w/ O_SYNC / getrandom w/ GRND_RANDOM */
 	return ntg1;
@@ -154,7 +154,7 @@ void lrng_reset_state(void)
 	}
 	lrng_state.lrng_operational = false;
 	lrng_state.lrng_fully_seeded = false;
-	lrng_state.lrng_min_seeded = false;
+	lrng_state.lrng_min_seeded = 0;
 	lrng_state.all_online_numa_node_seeded = false;
 	pr_debug("reset LRNG\n");
 }
@@ -165,6 +165,12 @@ void lrng_pool_all_numa_nodes_seeded(bool set)
 	lrng_state.all_online_numa_node_seeded = set;
 	if (set)
 		wake_up_all(&lrng_init_wait);
+	/*
+	 * Once all DRNGs are fully seeded, the forced seeding is not needed
+	 * any more. Thus, set the min_seeded level below the
+	 * LRNG_FORCE_FULLY_SEEDED_ATTEMPT threshold.
+	 */
+	lrng_state.lrng_min_seeded = 1;
 }
 
 bool lrng_pool_all_numa_nodes_seeded_get(void)
@@ -173,7 +179,7 @@ bool lrng_pool_all_numa_nodes_seeded_get(void)
 }
 
 /* Return boolean whether LRNG reached minimally seed level */
-bool lrng_state_min_seeded(void)
+unsigned int lrng_state_min_seeded(void)
 {
 	return lrng_state.lrng_min_seeded;
 }
@@ -334,6 +340,8 @@ void lrng_init_ops(struct entropy_buf *eb)
 	if (state->lrng_fully_seeded) {
 		lrng_set_operational();
 		lrng_set_entropy_thresh(requested_bits);
+
+		state->lrng_min_seeded = 1;
 	} else if (lrng_fully_seeded(state->all_online_numa_node_seeded,
 				     seed_bits, eb)) {
 		if (state->can_invalidate)
@@ -341,7 +349,13 @@ void lrng_init_ops(struct entropy_buf *eb)
 
 		state->lrng_fully_seeded = true;
 		lrng_set_operational();
-		state->lrng_min_seeded = true;
+
+		/*
+		 * Reset min-seeded trigger to allow it being counted up for
+		 * the next DRNG. This gives other entropy sources time to
+		 * collect entropy to seed the DRNG as well.
+		 */
+		state->lrng_min_seeded = 1;
 		pr_info("LRNG fully seeded with %u bits of entropy\n",
 			seed_bits);
 		lrng_set_entropy_thresh(requested_bits);
@@ -352,7 +366,7 @@ void lrng_init_ops(struct entropy_buf *eb)
 			if (state->can_invalidate)
 				invalidate_batched_entropy();
 
-			state->lrng_min_seeded = true;
+			state->lrng_min_seeded++;
 			pr_info("LRNG minimally seeded with %u bits of entropy\n",
 				seed_bits);
 			lrng_set_entropy_thresh(requested_bits);
@@ -427,6 +441,9 @@ early_initcall(lrng_rand_initialize);
 /* Interface requesting a reseed of the DRNG */
 void lrng_es_add_entropy(void)
 {
+	struct lrng_state *state = &lrng_state;
+	u32 avail_entropy;
+
 	/*
 	 * Once all DRNGs are fully seeded, the system-triggered arrival of
 	 * entropy will not cause any reseeding any more.
@@ -434,9 +451,17 @@ void lrng_es_add_entropy(void)
 	if (likely(lrng_state.all_online_numa_node_seeded))
 		return;
 
-	/* Only trigger the DRNG reseed if we have collected entropy. */
-	if (lrng_avail_entropy() <
-	    atomic_read_u32(&lrng_state.boot_entropy_thresh))
+	/*
+	 * Only trigger the DRNG reseed if we have collected entropy. If
+	 * we have several min-seeded entropy requests without reaching fully
+	 * seeded, we force the seeding with the available entropy.
+	 */
+	state->lrng_min_seeded++;
+	avail_entropy = lrng_avail_entropy();
+	if ((state->lrng_min_seeded < 5 &&
+	    (avail_entropy <
+	     atomic_read_u32(&lrng_state.boot_entropy_thresh))) ||
+	    avail_entropy == 0)
 		return;
 
 	/* Ensure that the seeding only occurs once at any given time. */
@@ -451,7 +476,8 @@ void lrng_es_add_entropy(void)
 }
 
 /* Fill the seed buffer with data from the noise sources */
-void lrng_fill_seed_buffer(struct entropy_buf *eb, u32 requested_bits)
+void lrng_fill_seed_buffer(struct entropy_buf *eb, u32 requested_bits,
+			   bool force)
 {
 	struct lrng_state *state = &lrng_state;
 	u32 i, req_ent = lrng_sp80090c_compliant() ?
@@ -468,7 +494,8 @@ void lrng_fill_seed_buffer(struct entropy_buf *eb, u32 requested_bits)
 	 * operated SP800-90C compliant we want to comply with SP800-90A section
 	 * 9.2 mandating that DRNG is reseeded with the security strength.
 	 */
-	if (state->lrng_fully_seeded && (lrng_avail_entropy() < req_ent)) {
+	if (!force &&
+	    state->lrng_fully_seeded && (lrng_avail_entropy() < req_ent)) {
 		for_each_lrng_es(i)
 			eb->e_bits[i] = 0;
 
diff --git a/drivers/char/lrng/lrng_es_mgr.h b/drivers/char/lrng/lrng_es_mgr.h
index 8fa24ebbd..6304728d8 100644
--- a/drivers/char/lrng/lrng_es_mgr.h
+++ b/drivers/char/lrng/lrng_es_mgr.h
@@ -23,9 +23,9 @@ extern struct lrng_es_cb *lrng_es[];
 #define for_each_lrng_es(ctr)		\
 	for ((ctr) = 0; (ctr) < lrng_ext_es_last; (ctr)++)
 
-bool lrng_ntg1_compliant(void);
+bool lrng_ntg1_2022_compliant(void);
 bool lrng_pool_all_numa_nodes_seeded_get(void);
-bool lrng_state_min_seeded(void);
+unsigned int lrng_state_min_seeded(void);
 void lrng_debug_report_seedlevel(const char *name);
 int lrng_rand_initialize(void);
 bool lrng_state_operational(void);
@@ -47,7 +47,8 @@ bool lrng_fully_seeded(bool fully_seeded, u32 collected_entropy,
 		       struct entropy_buf *eb);
 u32 lrng_entropy_rate_eb(struct entropy_buf *eb);
 void lrng_unset_fully_seeded(struct lrng_drng *drng);
-void lrng_fill_seed_buffer(struct entropy_buf *eb, u32 requested_bits);
+void lrng_fill_seed_buffer(struct entropy_buf *eb, u32 requested_bits,
+			   bool force);
 void lrng_init_ops(struct entropy_buf *eb);
 
 #endif /* _LRNG_ES_MGR_H */
diff --git a/drivers/char/lrng/lrng_proc.c b/drivers/char/lrng/lrng_proc.c
index 2818591be..a9c8d90c7 100644
--- a/drivers/char/lrng/lrng_proc.c
+++ b/drivers/char/lrng/lrng_proc.c
@@ -42,7 +42,7 @@ static int lrng_proc_type_show(struct seq_file *m, void *v)
 		 lrng_security_strength(),
 		 numa_drngs,
 		 lrng_sp80090c_compliant() ? "SP800-90C, " : "",
-		 lrng_ntg1_compliant() ? " / 2022" : "",
+		 lrng_ntg1_2022_compliant() ? " / 2022" : "",
 		 lrng_state_min_seeded() ? "true" : "false",
 		 lrng_state_fully_seeded() ? "true" : "false",
 		 lrng_avail_entropy());
-- 
2.38.0.rc1.6.g4fd6c5e444

