From b98a924dca18599f95d41e1603f62a28e130de65 Mon Sep 17 00:00:00 2001
From: Sultan Alsawaf <sultan@kerneltoast.com>
Date: Wed, 20 Oct 2021 20:50:11 -0700
Subject: [PATCH 01/41] ZEN: mm: Lower the non-hugetlbpage pageblock size to
 reduce scheduling delays

The page allocator processes free pages in groups of pageblocks, where
the size of a pageblock is typically quite large (1024 pages without
hugetlbpage support). Pageblocks are processed atomically with the zone
lock held, which can cause severe scheduling delays on both the CPU
going through the pageblock and any other CPUs waiting to acquire the
zone lock. A frequent offender is move_freepages_block(), which is used
by rmqueue() for page allocation.

As it turns out, there's no requirement for pageblocks to be so large,
so the pageblock order can simply be reduced to ease the scheduling
delays and zone lock contention. PAGE_ALLOC_COSTLY_ORDER is used as a
reasonable setting to ensure non-costly page allocation requests can
still be serviced without always needing to free up more than one
pageblock's worth of pages at a time.

This has a noticeable effect on overall system latency when memory
pressure is elevated. The various mm functions which operate on
pageblocks no longer appear in the preemptoff tracer, where previously
they would spend up to 100 ms on a mobile arm64 CPU processing a
pageblock with preemption disabled and the zone lock held.

Signed-off-by: Sultan Alsawaf <sultan@kerneltoast.com>
---
 include/linux/pageblock-flags.h | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/include/linux/pageblock-flags.h b/include/linux/pageblock-flags.h
index 83c724805..d2b8741ea 100644
--- a/include/linux/pageblock-flags.h
+++ b/include/linux/pageblock-flags.h
@@ -48,7 +48,7 @@ extern unsigned int pageblock_order;
 #else /* CONFIG_HUGETLB_PAGE */
 
 /* If huge pages are not used, group by MAX_ORDER_NR_PAGES */
-#define pageblock_order		(MAX_ORDER-1)
+#define pageblock_order		PAGE_ALLOC_COSTLY_ORDER
 
 #endif /* CONFIG_HUGETLB_PAGE */
 
-- 
2.37.3.485.gbe1a02a17e


From 62b18d6cb4c6a4804af390c9aee48200606e0ff3 Mon Sep 17 00:00:00 2001
From: Sean Christopherson <seanjc@google.com>
Date: Thu, 26 May 2022 21:08:10 +0000
Subject: [PATCH 02/41] KVM: x86: Grab regs_dirty in local 'unsigned long'

Capture ctxt->regs_dirty in a local 'unsigned long' instead of casting it
to an 'unsigned long *' for use in for_each_set_bit().  The bitops helpers
really do read the entire 'unsigned long', even though the walking of the
read value is capped at the specified size.  I.e. 64-bit KVM is reading
memory beyond ctxt->regs_dirty, which is a u32 and thus 4 bytes, whereas
an unsigned long is 8 bytes.  Functionally it's not an issue because
regs_dirty is in the middle of x86_emulate_ctxt, i.e. KVM is just reading
its own memory, but relying on that coincidence is gross and unsafe.

Reviewed-by: Vitaly Kuznetsov <vkuznets@redhat.com>
Reviewed-by: Kees Cook <keescook@chromium.org>
Signed-off-by: Sean Christopherson <seanjc@google.com>
Message-Id: <20220526210817.3428868-2-seanjc@google.com>
Signed-off-by: Paolo Bonzini <pbonzini@redhat.com>
---
 arch/x86/kvm/emulate.c | 3 ++-
 1 file changed, 2 insertions(+), 1 deletion(-)

diff --git a/arch/x86/kvm/emulate.c b/arch/x86/kvm/emulate.c
index 09fa8a948..102187cda 100644
--- a/arch/x86/kvm/emulate.c
+++ b/arch/x86/kvm/emulate.c
@@ -266,9 +266,10 @@ static ulong *reg_rmw(struct x86_emulate_ctxt *ctxt, unsigned nr)
 
 static void writeback_registers(struct x86_emulate_ctxt *ctxt)
 {
+	unsigned long dirty = ctxt->regs_dirty;
 	unsigned reg;
 
-	for_each_set_bit(reg, (ulong *)&ctxt->regs_dirty, 16)
+	for_each_set_bit(reg, &dirty, 16)
 		ctxt->ops->write_gpr(ctxt, reg, ctxt->_regs[reg]);
 }
 
-- 
2.37.3.485.gbe1a02a17e


From 387e91019ff6a461e5fd1e307f168c52b2c75fed Mon Sep 17 00:00:00 2001
From: Sean Christopherson <seanjc@google.com>
Date: Thu, 26 May 2022 21:08:11 +0000
Subject: [PATCH 03/41] KVM: x86: Harden _regs accesses to guard against buggy
 input

WARN and truncate the incoming GPR number/index when reading/writing GPRs
in the emulator to guard against KVM bugs, e.g. to avoid out-of-bounds
accesses to ctxt->_regs[] if KVM generates a bogus index.  Truncate the
index instead of returning e.g. zero, as reg_write() returns a pointer
to the register, i.e. returning zero would result in a NULL pointer
dereference.  KVM could also force the index to any arbitrary GPR, but
that's no better or worse, just different.

Open code the restriction to 16 registers; RIP is handled via _eip and
should never be accessed through reg_read() or reg_write().  See the
comments above the declarations of reg_read() and reg_write(), and the
behavior of writeback_registers().  The horrific open coded mess will be
cleaned up in a future commit.

There are no such bugs known to exist in the emulator, but determining
that KVM is bug-free is not at all simple and requires a deep dive into
the emulator.  The code is so convoluted that GCC-12 with the recently
enable -Warray-bounds spits out a false-positive due to a GCC bug:

  arch/x86/kvm/emulate.c:254:27: warning: array subscript 32 is above array
                                 bounds of 'long unsigned int[17]' [-Warray-bounds]
    254 |         return ctxt->_regs[nr];
        |                ~~~~~~~~~~~^~~~
  In file included from arch/x86/kvm/emulate.c:23:
  arch/x86/kvm/kvm_emulate.h: In function 'reg_rmw':
  arch/x86/kvm/kvm_emulate.h:366:23: note: while referencing '_regs'
    366 |         unsigned long _regs[NR_VCPU_REGS];
        |                       ^~~~~

Link: https://lore.kernel.org/all/YofQlBrlx18J7h9Y@google.com
Link: https://bugzilla.kernel.org/show_bug.cgi?id=216026
Link: https://gcc.gnu.org/bugzilla/show_bug.cgi?id=105679
Reported-and-tested-by: Robert Dinse <nanook@eskimo.com>
Reported-by: Kees Cook <keescook@chromium.org>
Reviewed-by: Kees Cook <keescook@chromium.org>
Signed-off-by: Sean Christopherson <seanjc@google.com>
Message-Id: <20220526210817.3428868-3-seanjc@google.com>
Signed-off-by: Paolo Bonzini <pbonzini@redhat.com>
---
 arch/x86/kvm/emulate.c | 6 ++++++
 1 file changed, 6 insertions(+)

diff --git a/arch/x86/kvm/emulate.c b/arch/x86/kvm/emulate.c
index 102187cda..b1904f5ec 100644
--- a/arch/x86/kvm/emulate.c
+++ b/arch/x86/kvm/emulate.c
@@ -244,6 +244,9 @@ enum x86_transfer_type {
 
 static ulong reg_read(struct x86_emulate_ctxt *ctxt, unsigned nr)
 {
+	if (WARN_ON_ONCE(nr >= 16))
+		nr &= 16 - 1;
+
 	if (!(ctxt->regs_valid & (1 << nr))) {
 		ctxt->regs_valid |= 1 << nr;
 		ctxt->_regs[nr] = ctxt->ops->read_gpr(ctxt, nr);
@@ -253,6 +256,9 @@ static ulong reg_read(struct x86_emulate_ctxt *ctxt, unsigned nr)
 
 static ulong *reg_write(struct x86_emulate_ctxt *ctxt, unsigned nr)
 {
+	if (WARN_ON_ONCE(nr >= 16))
+		nr &= 16 - 1;
+
 	ctxt->regs_valid |= 1 << nr;
 	ctxt->regs_dirty |= 1 << nr;
 	return &ctxt->_regs[nr];
-- 
2.37.3.485.gbe1a02a17e


From ac17d5022b0ee6e37eb3c55398ea0ab35b5b71e8 Mon Sep 17 00:00:00 2001
From: Uros Bizjak <ubizjak@gmail.com>
Date: Fri, 24 Jun 2022 16:14:12 +0200
Subject: [PATCH 04/41] compiler-gcc.h: remove ancient workaround for gcc PR
 58670

The workaround for 'asm goto' miscompilation introduces a compiler barrier
quirk that inhibits many useful compiler optimizations.  For example,
__try_cmpxchg_user compiles to:

   11375:	41 8b 4d 00          	mov    0x0(%r13),%ecx
   11379:	41 8b 02             	mov    (%r10),%eax
   1137c:	f0 0f b1 0a          	lock cmpxchg %ecx,(%rdx)
   11380:	0f 94 c2             	sete   %dl
   11383:	84 d2                	test   %dl,%dl
   11385:	75 c4                	jne    1134b <...>
   11387:	41 89 02             	mov    %eax,(%r10)

where the barrier inhibits flags propagation from asm when compiled with
gcc-12.

When the mentioned quirk is removed, the following code is generated:

   11553:	41 8b 4d 00          	mov    0x0(%r13),%ecx
   11557:	41 8b 02             	mov    (%r10),%eax
   1155a:	f0 0f b1 0a          	lock cmpxchg %ecx,(%rdx)
   1155e:	74 c9                	je     11529 <...>
   11560:	41 89 02             	mov    %eax,(%r10)

The refered compiler bug:

http://gcc.gnu.org/bugzilla/show_bug.cgi?id=58670

was fixed for gcc-4.8.2.

Current minimum required version of GCC is version 5.1 which has the above
'asm goto' miscompilation fixed, so remove the workaround.

Link: https://lkml.kernel.org/r/20220624141412.72274-1-ubizjak@gmail.com
Signed-off-by: Uros Bizjak <ubizjak@gmail.com>
Cc: Ingo Molnar <mingo@kernel.org>
Cc: "H. Peter Anvin" <hpa@zytor.com>
Cc: Thomas Gleixner <tglx@linutronix.de>
Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
---
 include/linux/compiler-gcc.h | 11 -----------
 1 file changed, 11 deletions(-)

diff --git a/include/linux/compiler-gcc.h b/include/linux/compiler-gcc.h
index a0c55eeae..9b157b710 100644
--- a/include/linux/compiler-gcc.h
+++ b/include/linux/compiler-gcc.h
@@ -66,17 +66,6 @@
 		__builtin_unreachable();	\
 	} while (0)
 
-/*
- * GCC 'asm goto' miscompiles certain code sequences:
- *
- *   http://gcc.gnu.org/bugzilla/show_bug.cgi?id=58670
- *
- * Work it around via a compiler barrier quirk suggested by Jakub Jelinek.
- *
- * (asm goto is automatically volatile - the naming reflects this.)
- */
-#define asm_volatile_goto(x...)	do { asm goto(x); asm (""); } while (0)
-
 #if defined(CONFIG_ARCH_USE_BUILTIN_BSWAP)
 #define __HAVE_BUILTIN_BSWAP32__
 #define __HAVE_BUILTIN_BSWAP64__
-- 
2.37.3.485.gbe1a02a17e


From 03d13f9bfd3b92ef689e0b85ad4f6f807c37fc56 Mon Sep 17 00:00:00 2001
From: Yosry Ahmed <yosryahmed@google.com>
Date: Thu, 14 Jul 2022 06:49:18 +0000
Subject: [PATCH 05/41] mm: vmpressure: don't count proactive reclaim in
 vmpressure

vmpressure is used in cgroup v1 to notify userspace of reclaim
efficiency events, and is also used in both cgroup v1 and v2 as a signal
for memory pressure for networking, see
mem_cgroup_under_socket_pressure().

Proactive reclaim intends to probe memcgs for cold memory, without
affecting their performance. Hence, reclaim caused by writing to
memory.reclaim should not trigger vmpressure.

Signed-off-by: Yosry Ahmed <yosryahmed@google.com>
Acked-by: Shakeel Butt <shakeelb@google.com>
---
 include/linux/swap.h |  5 ++++-
 mm/memcontrol.c      | 24 ++++++++++++++----------
 mm/vmscan.c          | 27 +++++++++++++++++----------
 3 files changed, 35 insertions(+), 21 deletions(-)

diff --git a/include/linux/swap.h b/include/linux/swap.h
index 0c0fed1b3..f6e9eaa23 100644
--- a/include/linux/swap.h
+++ b/include/linux/swap.h
@@ -411,10 +411,13 @@ extern void lru_cache_add_inactive_or_unevictable(struct page *page,
 extern unsigned long zone_reclaimable_pages(struct zone *zone);
 extern unsigned long try_to_free_pages(struct zonelist *zonelist, int order,
 					gfp_t gfp_mask, nodemask_t *mask);
+
+#define MEMCG_RECLAIM_MAY_SWAP (1 << 1)
+#define MEMCG_RECLAIM_PROACTIVE (1 << 2)
 extern unsigned long try_to_free_mem_cgroup_pages(struct mem_cgroup *memcg,
 						  unsigned long nr_pages,
 						  gfp_t gfp_mask,
-						  bool may_swap);
+						  unsigned int reclaim_options);
 extern unsigned long mem_cgroup_shrink_node(struct mem_cgroup *mem,
 						gfp_t gfp_mask, bool noswap,
 						pg_data_t *pgdat,
diff --git a/mm/memcontrol.c b/mm/memcontrol.c
index 618c366a2..504c01c34 100644
--- a/mm/memcontrol.c
+++ b/mm/memcontrol.c
@@ -2331,7 +2331,8 @@ static unsigned long reclaim_high(struct mem_cgroup *memcg,
 
 		psi_memstall_enter(&pflags);
 		nr_reclaimed += try_to_free_mem_cgroup_pages(memcg, nr_pages,
-							     gfp_mask, true);
+							gfp_mask,
+							MEMCG_RECLAIM_MAY_SWAP);
 		psi_memstall_leave(&pflags);
 	} while ((memcg = parent_mem_cgroup(memcg)) &&
 		 !mem_cgroup_is_root(memcg));
@@ -2576,7 +2577,7 @@ static int try_charge_memcg(struct mem_cgroup *memcg, gfp_t gfp_mask,
 	struct page_counter *counter;
 	unsigned long nr_reclaimed;
 	bool passed_oom = false;
-	bool may_swap = true;
+	unsigned int reclaim_options = MEMCG_RECLAIM_MAY_SWAP;
 	bool drained = false;
 	unsigned long pflags;
 
@@ -2593,7 +2594,7 @@ static int try_charge_memcg(struct mem_cgroup *memcg, gfp_t gfp_mask,
 		mem_over_limit = mem_cgroup_from_counter(counter, memory);
 	} else {
 		mem_over_limit = mem_cgroup_from_counter(counter, memsw);
-		may_swap = false;
+		reclaim_options &= ~MEMCG_RECLAIM_MAY_SWAP;
 	}
 
 	if (batch > nr_pages) {
@@ -2620,7 +2621,7 @@ static int try_charge_memcg(struct mem_cgroup *memcg, gfp_t gfp_mask,
 
 	psi_memstall_enter(&pflags);
 	nr_reclaimed = try_to_free_mem_cgroup_pages(mem_over_limit, nr_pages,
-						    gfp_mask, may_swap);
+						    gfp_mask, reclaim_options);
 	psi_memstall_leave(&pflags);
 
 	if (mem_cgroup_margin(mem_over_limit) >= nr_pages)
@@ -3402,8 +3403,8 @@ static int mem_cgroup_resize_max(struct mem_cgroup *memcg,
 			continue;
 		}
 
-		if (!try_to_free_mem_cgroup_pages(memcg, 1,
-					GFP_KERNEL, !memsw)) {
+		if (!try_to_free_mem_cgroup_pages(memcg, 1, GFP_KERNEL,
+					memsw ? 0 : MEMCG_RECLAIM_MAY_SWAP)) {
 			ret = -EBUSY;
 			break;
 		}
@@ -3513,7 +3514,8 @@ static int mem_cgroup_force_empty(struct mem_cgroup *memcg)
 		if (signal_pending(current))
 			return -EINTR;
 
-		if (!try_to_free_mem_cgroup_pages(memcg, 1, GFP_KERNEL, true))
+		if (!try_to_free_mem_cgroup_pages(memcg, 1, GFP_KERNEL,
+						  MEMCG_RECLAIM_MAY_SWAP))
 			nr_retries--;
 	}
 
@@ -6241,7 +6243,7 @@ static ssize_t memory_high_write(struct kernfs_open_file *of,
 		}
 
 		reclaimed = try_to_free_mem_cgroup_pages(memcg, nr_pages - high,
-							 GFP_KERNEL, true);
+					GFP_KERNEL, MEMCG_RECLAIM_MAY_SWAP);
 
 		if (!reclaimed && !nr_retries--)
 			break;
@@ -6290,7 +6292,7 @@ static ssize_t memory_max_write(struct kernfs_open_file *of,
 
 		if (nr_reclaims) {
 			if (!try_to_free_mem_cgroup_pages(memcg, nr_pages - max,
-							  GFP_KERNEL, true))
+					GFP_KERNEL, MEMCG_RECLAIM_MAY_SWAP))
 				nr_reclaims--;
 			continue;
 		}
@@ -6419,6 +6421,7 @@ static ssize_t memory_reclaim(struct kernfs_open_file *of, char *buf,
 	struct mem_cgroup *memcg = mem_cgroup_from_css(of_css(of));
 	unsigned int nr_retries = MAX_RECLAIM_RETRIES;
 	unsigned long nr_to_reclaim, nr_reclaimed = 0;
+	unsigned int reclaim_options;
 	int err;
 
 	buf = strstrip(buf);
@@ -6426,6 +6429,7 @@ static ssize_t memory_reclaim(struct kernfs_open_file *of, char *buf,
 	if (err)
 		return err;
 
+	reclaim_options	= MEMCG_RECLAIM_MAY_SWAP | MEMCG_RECLAIM_PROACTIVE;
 	while (nr_reclaimed < nr_to_reclaim) {
 		unsigned long reclaimed;
 
@@ -6442,7 +6446,7 @@ static ssize_t memory_reclaim(struct kernfs_open_file *of, char *buf,
 
 		reclaimed = try_to_free_mem_cgroup_pages(memcg,
 						nr_to_reclaim - nr_reclaimed,
-						GFP_KERNEL, true);
+						GFP_KERNEL, reclaim_options);
 
 		if (!reclaimed && !nr_retries--)
 			return -EAGAIN;
diff --git a/mm/vmscan.c b/mm/vmscan.c
index f7d9a683e..0969e6408 100644
--- a/mm/vmscan.c
+++ b/mm/vmscan.c
@@ -102,6 +102,9 @@ struct scan_control {
 	/* Can pages be swapped as part of reclaim? */
 	unsigned int may_swap:1;
 
+	/* Proactive reclaim invoked by userspace through memory.reclaim */
+	unsigned int proactive:1;
+
 	/*
 	 * Cgroup memory below memory.low is protected as long as we
 	 * don't threaten to OOM. If any cgroup is reclaimed at
@@ -3125,9 +3128,10 @@ static void shrink_node_memcgs(pg_data_t *pgdat, struct scan_control *sc)
 			    sc->priority);
 
 		/* Record the group's reclaim efficiency */
-		vmpressure(sc->gfp_mask, memcg, false,
-			   sc->nr_scanned - scanned,
-			   sc->nr_reclaimed - reclaimed);
+		if (!sc->proactive)
+			vmpressure(sc->gfp_mask, memcg, false,
+				   sc->nr_scanned - scanned,
+				   sc->nr_reclaimed - reclaimed);
 
 	} while ((memcg = mem_cgroup_iter(target_memcg, memcg, NULL)));
 }
@@ -3250,9 +3254,10 @@ static void shrink_node(pg_data_t *pgdat, struct scan_control *sc)
 	}
 
 	/* Record the subtree's reclaim efficiency */
-	vmpressure(sc->gfp_mask, sc->target_mem_cgroup, true,
-		   sc->nr_scanned - nr_scanned,
-		   sc->nr_reclaimed - nr_reclaimed);
+	if (!sc->proactive)
+		vmpressure(sc->gfp_mask, sc->target_mem_cgroup, true,
+			   sc->nr_scanned - nr_scanned,
+			   sc->nr_reclaimed - nr_reclaimed);
 
 	if (sc->nr_reclaimed - nr_reclaimed)
 		reclaimable = true;
@@ -3534,8 +3539,9 @@ static unsigned long do_try_to_free_pages(struct zonelist *zonelist,
 		__count_zid_vm_events(ALLOCSTALL, sc->reclaim_idx, 1);
 
 	do {
-		vmpressure_prio(sc->gfp_mask, sc->target_mem_cgroup,
-				sc->priority);
+		if (!sc->proactive)
+			vmpressure_prio(sc->gfp_mask, sc->target_mem_cgroup,
+					sc->priority);
 		sc->nr_scanned = 0;
 		shrink_zones(zonelist, sc);
 
@@ -3825,7 +3831,7 @@ unsigned long mem_cgroup_shrink_node(struct mem_cgroup *memcg,
 unsigned long try_to_free_mem_cgroup_pages(struct mem_cgroup *memcg,
 					   unsigned long nr_pages,
 					   gfp_t gfp_mask,
-					   bool may_swap)
+					   unsigned int reclaim_options)
 {
 	unsigned long nr_reclaimed;
 	unsigned int noreclaim_flag;
@@ -3838,7 +3844,8 @@ unsigned long try_to_free_mem_cgroup_pages(struct mem_cgroup *memcg,
 		.priority = DEF_PRIORITY,
 		.may_writepage = !laptop_mode,
 		.may_unmap = 1,
-		.may_swap = may_swap,
+		.may_swap = !!(reclaim_options & MEMCG_RECLAIM_MAY_SWAP),
+		.proactive = !!(reclaim_options & MEMCG_RECLAIM_PROACTIVE),
 	};
 	/*
 	 * Traverse the ZONELIST_FALLBACK zonelist of the current node to put
-- 
2.37.3.485.gbe1a02a17e


From de60976965e3380d7ef3e85641dc77d891d04e1d Mon Sep 17 00:00:00 2001
From: Ian Pilcher <arequipeno@gmail.com>
Date: Thu, 2 Jun 2022 11:12:23 -0500
Subject: [PATCH 06/41] docs: Add block device (blkdev) LED trigger
 documentation

Add Documentation/ABI/testing/sysfs-class-led-trigger-blkdev to
document:

  * /sys/class/leds/<led>/blink_time
  * /sys/class/leds/<led>/check_interval
  * /sys/class/leds/<led>/blink_on_{read,write,discard,flush}
  * /sys/class/leds/<led>/link_dev_by_path
  * /sys/class/leds/<led>/unlink_dev_by_path
  * /sys/class/leds/<led>/linked_devices

Add /sys/block/<disk>/linked_leds to
Documentation/ABI/stable/sysfs-block.

Add overview in Documentation/leds/ledtrig-blkdev.rst.

Signed-off-by: Ian Pilcher <arequipeno@gmail.com>
---
 Documentation/ABI/stable/sysfs-block          |  10 ++
 .../testing/sysfs-class-led-trigger-blkdev    |  68 ++++++++
 Documentation/leds/index.rst                  |   1 +
 Documentation/leds/ledtrig-blkdev.rst         | 155 ++++++++++++++++++
 4 files changed, 234 insertions(+)
 create mode 100644 Documentation/ABI/testing/sysfs-class-led-trigger-blkdev
 create mode 100644 Documentation/leds/ledtrig-blkdev.rst

diff --git a/Documentation/ABI/stable/sysfs-block b/Documentation/ABI/stable/sysfs-block
index e8797cd09..289c2447f 100644
--- a/Documentation/ABI/stable/sysfs-block
+++ b/Documentation/ABI/stable/sysfs-block
@@ -101,6 +101,16 @@ Description:
 		devices that support receiving integrity metadata.
 
 
+What:		/sys/block/<disk>/linked_leds
+Date:		March 2022
+Contact:	Ian Pilcher <arequipeno@gmail.com>
+Description:
+		Directory that contains symbolic links to all LEDs that
+		are associated with (linked to) this block device by the
+		blkdev LED trigger.  Only present when at least one LED
+		is linked.  (See Documentation/leds/ledtrig-blkdev.rst.)
+
+
 What:		/sys/block/<disk>/<partition>/alignment_offset
 Date:		April 2009
 Contact:	Martin K. Petersen <martin.petersen@oracle.com>
diff --git a/Documentation/ABI/testing/sysfs-class-led-trigger-blkdev b/Documentation/ABI/testing/sysfs-class-led-trigger-blkdev
new file mode 100644
index 000000000..9214439b0
--- /dev/null
+++ b/Documentation/ABI/testing/sysfs-class-led-trigger-blkdev
@@ -0,0 +1,68 @@
+What:		/sys/class/leds/<led>/blink_time
+Date:		March 2022
+Contact:	Ian Pilcher <arequipeno@gmail.com>
+Description:
+		Time (in milliseconds) that the LED will be on during a single
+		"blink".
+
+What:		/sys/class/leds/<led>/check_interval
+Date:		March 2022
+Contact:	Ian Pilcher <arequipeno@gmail.com>
+Description:
+		Frequency (in milliseconds) with which block devices linked to
+		this LED will be checked for activity and the LED will
+		(potentially) be blinked.
+
+What:		/sys/class/leds/<led>/blink_on_read
+Date:		March 2022
+Contact:	Ian Pilcher <arequipeno@gmail.com>
+Description:
+		Boolean that determines whether the LED will blink in response
+		to read activity on any of its linked block devices.
+
+What:		/sys/class/leds/<led>/blink_on_write
+Date:		March 2022
+Contact:	Ian Pilcher <arequipeno@gmail.com>
+Description:
+		Boolean that determines whether the LED will blink in response
+		to write activity on any of its linked block devices.
+
+What:		/sys/class/leds/<led>/blink_on_discard
+Date:		March 2022
+Contact:	Ian Pilcher <arequipeno@gmail.com>
+Description:
+		Boolean that determines whether the LED will blink in response
+		to discard activity on any of its linked block devices.
+
+What:		/sys/class/leds/<led>/blink_on_flush
+Date:		March 2022
+Contact:	Ian Pilcher <arequipeno@gamil.com>
+Description:
+		Boolean that determines whether the LED will blink in response
+		to cache flush activity on any of its linked block devices.
+
+What:		/sys/class/leds/<led>/link_dev_by_path
+Date:		March 2022
+Contact:	Ian Pilcher <arequipeno@gmail.com>
+Description:
+		Associate a block device with this LED by writing the path to
+		the device special file (e.g. /dev/sda) to this attribute.
+		Symbolic links are followed.
+
+What:		/sys/class/leds/<led>/unlink_dev_by_path
+Date:		March 2022
+Contact:	Ian Pilcher <arequipeno@gmail.com>
+Description:
+		Remove the association between this LED and a block device by
+		writing the path to the device special file (e.g. /dev/sda) to
+		this attribute.  Symbolic links are followed.
+
+What:		/sys/class/leds/<led>/linked_devices
+Date:		March 2022
+Contact:	Ian Pilcher <arequipeno@gmail.com>
+Description:
+		Directory containing links to all block devices that are
+		associated with this LED.  (Note that the names of the
+		symbolic links in this directory are *kernel* names, which
+		may not match the device special file paths written to
+		link_device and unlink_device.)
diff --git a/Documentation/leds/index.rst b/Documentation/leds/index.rst
index e5d63b940..e3c24e468 100644
--- a/Documentation/leds/index.rst
+++ b/Documentation/leds/index.rst
@@ -10,6 +10,7 @@ LEDs
    leds-class
    leds-class-flash
    leds-class-multicolor
+   ledtrig-blkdev
    ledtrig-oneshot
    ledtrig-transient
    ledtrig-usbport
diff --git a/Documentation/leds/ledtrig-blkdev.rst b/Documentation/leds/ledtrig-blkdev.rst
new file mode 100644
index 000000000..ae92aa559
--- /dev/null
+++ b/Documentation/leds/ledtrig-blkdev.rst
@@ -0,0 +1,155 @@
+.. SPDX-License-Identifier: GPL-2.0
+
+=================================
+Block Device (blkdev) LED Trigger
+=================================
+
+Available when ``CONFIG_LEDS_TRIGGER_BLKDEV=y`` or
+``CONFIG_LEDS_TRIGGER_BLKDEV=m``.
+
+See also:
+
+* ``Documentation/ABI/testing/sysfs-class-led-trigger-blkdev``
+* ``Documentation/ABI/stable/sysfs-block`` (``/sys/block/<disk>/linked_leds``)
+
+Overview
+========
+
+.. note::
+	The examples below use ``<LED>`` to refer to the name of a
+	system-specific LED.  If no suitable LED is available on a test
+	system (in a virtual machine, for example), it is possible to
+	use a userspace LED.  (See ``Documentation/leds/uleds.rst``.)
+
+Verify that the ``blkdev`` LED trigger is available::
+
+	# grep blkdev /sys/class/leds/<LED>/trigger
+	... rfkill-none blkdev
+
+(If the previous command produces no output, you may need to load the trigger
+module - ``modprobe ledtrig_blkdev``.  If the module is not available, check
+the value of ``CONFIG_LEDS_TRIGGER_BLKDEV`` in your kernel configuration.)
+
+Associate the LED with the ``blkdev`` LED trigger::
+
+	# echo blkdev > /sys/class/leds/<LED>/trigger
+
+	# cat /sys/class/leds/<LED>/trigger
+	... rfkill-none [blkdev]
+
+Note that several new device attributes are available in the
+``/sys/class/leds/<LED>`` directory.
+
+* ``link_dev_by_path`` and ``unlink_dev_by_path`` are used to manage the set of
+  block devices associated with this LED.  The LED will blink in response to
+  read or write activity on its linked devices.
+
+* ``blink_on_read``, ``blink_on_write``, ``blink_on_discard``, and
+  ``blink_on_flush`` are boolean values that determine whether the LED will
+  blink when a particular type of activity is detected on one of its linked
+  block devices.
+
+* ``blink_time`` is the duration (in milliseconds) of each blink of this LED.
+  (The minimum value is 10 milliseconds.)
+
+* ``check_interval`` is the frequency (in milliseconds) with which block devices
+  linked to this LED will be checked for activity and the LED blinked (if the
+  correct type of activity has occurred).
+
+* The ``linked_devices`` directory will contain a symbolic link to every device
+  that is associated with this LED.
+
+Link a block device to the LED::
+
+	# echo /dev/sda > /sys/class/leds/<LED>/link_dev_by_path
+
+	# ls /sys/class/leds/<LED>/linked_devices
+	sda
+
+(The value written to ``link_dev_by_path`` must be the path of the device
+special file, such as ``/dev/sda``, that represents the block device - or the
+path of a symbolic link to such a device special file.)
+
+Activity on the device will now cause the LED to blink.  The duration of each
+blink (in milliseconds) can be adjusted by setting
+``/sys/class/leds/<LED>/blink_time``.  (But see **check_interval and
+blink_time** below.)
+
+Associate a second device with the LED::
+
+	# echo /dev/sdb > /sys/class/leds/<LED>/link_dev_by_path
+
+	# ls /sys/class/leds/<LED>/linked_devices
+	sda  sdb
+
+When a block device is linked to one or more LEDs, the LEDs are linked from
+the device's ``linked_leds`` directory::
+
+	# ls /sys/class/block/sd{a,b}/linked_leds
+	/sys/class/block/sda/linked_leds:
+	<LED>
+
+	/sys/class/block/sdb/linked_leds:
+	<LED>
+
+(The ``linked_leds`` directory only exists when the block device is linked to
+at least one LED.)
+
+``check_interval`` and ``blink_time``
+=====================================
+
+* By default, linked block devices are checked for activity every 100
+  milliseconds.  This frequency can be changed for an LED via the
+  ``/sys/class/leds/<led>/check_interval`` attribute.  (The minimum value is 25
+  milliseconds.)
+
+* All block devices associated with an LED are checked for activity every
+  ``check_interval`` milliseconds, and a blink is triggered if the correct type
+  of activity (as determined by the LED's ``blink_on_*`` attributes) is
+  detected.  The duration of an LED's blink is determined by its ``blink_time``
+  attribute.  Thus (when the correct type of activity is detected), the LED will
+  be on for ``blink_time`` milliseconds and off for
+  ``check_interval - blink_time`` milliseconds.
+
+* The LED subsystem ignores new blink requests for an LED that is already in
+  in the process of blinking, so setting a ``blink_time`` greater than or equal
+  to ``check_interval`` will cause some blinks to be missed.
+
+* Because of processing times, scheduling latencies, etc., avoiding missed
+  blinks actually requires a difference of at least a few milliseconds between
+  the ``blink_time`` and ``check_interval``.  The required difference is likely
+  to vary from system to system.  As a  reference, a Thecus N5550 NAS requires a
+  difference of 7 milliseconds (e.g. ``check_interval == 100``,
+  ``blink_time == 93``).
+
+* The default values (``check_interval == 100``, ``blink_time == 75``) cause the
+  LED associated with a continuously active device to blink rapidly.  For a more
+  "always on" effect, increase the ``blink_time`` (but not too much; see the
+  previous bullet).
+
+Other Notes
+===========
+
+* Many (possibly all) types of block devices work with this trigger, including:
+
+  * SCSI (including SATA and USB) hard disk drives and SSDs
+  * SCSI (including SATA and USB) optical drives
+  * NVMe SSDs
+  * SD cards
+  * loopback block devices (``/dev/loop*``)
+  * device mapper devices, such as LVM logical volumes
+  * MD RAID devices
+  * zRAM compressed RAM-disks
+  * partitions on block devics that support them
+
+* The names of the symbolic links in ``/sys/class/leds/<LED>/linked_devices``
+  are **kernel** names, which may not match the paths used for
+  ``link_dev_by_path`` and ``unlink_dev_by_path``.  This is most likely when a
+  symbolic link is used to refer to the device (as is common with logical
+  volumes), but it can be true for any device, because nothing prevents the
+  creation of device special files with arbitrary names (e.g.
+  ``sudo mknod /foo b 8 0``).
+
+* The ``blkdev`` LED trigger supports many-to-many device/LED associations.
+  A device can be associated with multiple LEDs, and an LED can be associated
+  with multiple devices.
-- 
2.37.3.485.gbe1a02a17e


From 1d9ef68a3f2bcaffb63ce027d8295c932a025aee Mon Sep 17 00:00:00 2001
From: Ian Pilcher <arequipeno@gmail.com>
Date: Thu, 2 Jun 2022 11:12:24 -0500
Subject: [PATCH 07/41] leds: trigger: Add block device LED trigger

Add "blkdev" LED trigger to blink LEDs in response to block device
activity.

Add LEDS_TRIGGER_BLKDEV (tristate) config option to control building of
the trigger.

Signed-off-by: Ian Pilcher <arequipeno@gmail.com>
---
 drivers/leds/trigger/Kconfig          |    9 +
 drivers/leds/trigger/Makefile         |    1 +
 drivers/leds/trigger/ledtrig-blkdev.c | 1139 +++++++++++++++++++++++++
 3 files changed, 1149 insertions(+)
 create mode 100644 drivers/leds/trigger/ledtrig-blkdev.c

diff --git a/drivers/leds/trigger/Kconfig b/drivers/leds/trigger/Kconfig
index dc6816d36..bda249068 100644
--- a/drivers/leds/trigger/Kconfig
+++ b/drivers/leds/trigger/Kconfig
@@ -154,4 +154,13 @@ config LEDS_TRIGGER_TTY
 
 	  When build as a module this driver will be called ledtrig-tty.
 
+config LEDS_TRIGGER_BLKDEV
+	tristate "LED Trigger for block devices"
+	depends on BLOCK
+	help
+	  The blkdev LED trigger allows LEDs to be controlled by block device
+	  activity (reads and writes).
+
+	  See Documentation/leds/ledtrig-blkdev.rst.
+
 endif # LEDS_TRIGGERS
diff --git a/drivers/leds/trigger/Makefile b/drivers/leds/trigger/Makefile
index 25c4db97c..d53bab5d9 100644
--- a/drivers/leds/trigger/Makefile
+++ b/drivers/leds/trigger/Makefile
@@ -16,3 +16,4 @@ obj-$(CONFIG_LEDS_TRIGGER_NETDEV)	+= ledtrig-netdev.o
 obj-$(CONFIG_LEDS_TRIGGER_PATTERN)	+= ledtrig-pattern.o
 obj-$(CONFIG_LEDS_TRIGGER_AUDIO)	+= ledtrig-audio.o
 obj-$(CONFIG_LEDS_TRIGGER_TTY)		+= ledtrig-tty.o
+obj-$(CONFIG_LEDS_TRIGGER_BLKDEV)	+= ledtrig-blkdev.o
diff --git a/drivers/leds/trigger/ledtrig-blkdev.c b/drivers/leds/trigger/ledtrig-blkdev.c
new file mode 100644
index 000000000..999c48a7a
--- /dev/null
+++ b/drivers/leds/trigger/ledtrig-blkdev.c
@@ -0,0 +1,1139 @@
+// SPDX-License-Identifier: GPL-2.0-only
+
+/*
+ *	Block device LED trigger
+ *
+ *	Copyright 2021-2022 Ian Pilcher <arequipeno@gmail.com>
+ */
+
+#include <linux/blkdev.h>
+#include <linux/leds.h>
+#include <linux/module.h>
+#include <linux/part_stat.h>
+#include <linux/xarray.h>
+
+/* Default, minimum & maximum blink duration (milliseconds) */
+#define BLKDEV_TRIG_BLINK_DEF	75
+#define BLKDEV_TRIG_BLINK_MIN	10
+#define BLKDEV_TRIG_BLINK_MAX	86400000  /* 24 hours */
+
+/* Default, minimum & maximum activity check interval (milliseconds) */
+#define BLKDEV_TRIG_CHECK_DEF	100
+#define BLKDEV_TRIG_CHECK_MIN	25
+#define BLKDEV_TRIG_CHECK_MAX	86400000
+
+/*
+ * If blkdev_trig_check() can't lock the mutex, how long to wait before trying
+ * again (milliseconds)
+ */
+#define BLKDEV_TRIG_CHECK_RETRY	5
+
+/* Mode for blkdev_get_by_path() & blkdev_put() */
+#define BLKDEV_TRIG_FMODE	0
+
+/* When unlinking a block device from an LED, is the blkdev being released? */
+enum blkdev_trig_unlink_mode {
+	BLKDEV_TRIG_RELEASING,
+	BLKDEV_TRIG_NOT_RELEASING
+};
+
+/* Every block device linked to at least one LED gets a "BTB" */
+struct blkdev_trig_bdev {
+	unsigned long		last_checked;
+	unsigned long		last_activity[NR_STAT_GROUPS];
+	unsigned long		ios[NR_STAT_GROUPS];
+	unsigned long		index;
+	struct block_device	*bdev;
+	struct xarray		linked_leds;
+};
+
+/* Every LED associated with the blkdev trigger gets one of these */
+struct blkdev_trig_led {
+	unsigned long		last_checked;
+	unsigned long		index;
+	unsigned long		mode;  /* must be ulong for atomic bit ops */
+	struct led_classdev	*led_cdev;
+	unsigned int		blink_msec;
+	unsigned int		check_jiffies;
+	struct xarray		linked_btbs;
+	struct hlist_node	all_leds_node;
+};
+
+/* Forward declarations to make this file compile in a more readable order */
+static void blkdev_trig_check(struct work_struct *work);
+static struct blkdev_trig_bdev *blkdev_trig_get_btb(const char *buf,
+						    size_t size);
+static struct block_device *blkdev_trig_get_bdev(const char *buf, size_t size,
+						 fmode_t mode);
+static int blkdev_trig_link(struct blkdev_trig_led *led,
+			    struct blkdev_trig_bdev *btb);
+static void blkdev_trig_put_btb(struct blkdev_trig_bdev *btb);
+static void blkdev_trig_btb_release(struct device *dev, void *res);
+static void blkdev_trig_unlink(struct blkdev_trig_led *led,
+			       struct blkdev_trig_bdev *btb,
+			       enum blkdev_trig_unlink_mode unlink_mode);
+static void blkdev_trig_update_btb(struct blkdev_trig_bdev *btb,
+				   unsigned long now);
+static bool blkdev_trig_blink(const struct blkdev_trig_led *led,
+			      const struct blkdev_trig_bdev *btb);
+static void blkdev_trig_sched_led(const struct blkdev_trig_led *led);
+
+/* Index for next BTB or LED */
+static unsigned long blkdev_trig_next_index;
+
+/* Protects everything except sysfs attributes */
+static DEFINE_MUTEX(blkdev_trig_mutex);
+
+/* All LEDs associated with the trigger */
+static HLIST_HEAD(blkdev_trig_all_leds);
+
+/* Delayed work to periodically check for activity & blink LEDs */
+static DECLARE_DELAYED_WORK(blkdev_trig_work, blkdev_trig_check);
+
+/* When is the delayed work scheduled to run next (jiffies) */
+static unsigned long blkdev_trig_next_check;
+
+/* Total number of device-to-LED associations (links) */
+static unsigned int blkdev_trig_link_count;
+
+/* Empty attribute list, for next 2 declarations */
+static struct attribute *blkdev_trig_attrs_empty[] = { NULL };
+
+/* linked_leds sysfs directory for block devs linked to 1 or more LEDs */
+static const struct attribute_group blkdev_trig_linked_leds = {
+	.name	= "linked_leds",
+	.attrs	= blkdev_trig_attrs_empty,
+};
+
+/* linked_devices sysfs directory for each LED associated with the trigger */
+static const struct attribute_group blkdev_trig_linked_devs = {
+	.name	= "linked_devices",
+	.attrs	= blkdev_trig_attrs_empty,
+};
+
+/**
+ * blkdev_trig_activate() - Called when an LED is associated with the trigger.
+ * @led_cdev:	The LED
+ *
+ * Allocates & initializes the @blkdev_trig_led structure, adds it to the
+ * @blkdev_trig_all_leds list, and sets the LED's trigger data.
+ *
+ * Context:	Process context.  Takes and releases @blkdev_trig_mutex.
+ * Return:	``0`` on success, ``-errno`` on error.
+ */
+static int blkdev_trig_activate(struct led_classdev *led_cdev)
+{
+	struct blkdev_trig_led *led;
+	int err;
+
+	led = kzalloc(sizeof(*led), GFP_KERNEL);
+	if (led == NULL)
+		return -ENOMEM;
+
+	err = mutex_lock_interruptible(&blkdev_trig_mutex);
+	if (err)
+		goto exit_free;
+
+	if (blkdev_trig_next_index == ULONG_MAX) {
+		err = -EOVERFLOW;
+		goto exit_unlock;
+	}
+
+	led->index = blkdev_trig_next_index++;
+	led->last_checked = jiffies;
+	led->mode = -1;  /* set all bits */
+	led->led_cdev = led_cdev;
+	led->blink_msec = BLKDEV_TRIG_BLINK_DEF;
+	led->check_jiffies = msecs_to_jiffies(BLKDEV_TRIG_CHECK_DEF);
+	xa_init(&led->linked_btbs);
+
+	hlist_add_head(&led->all_leds_node, &blkdev_trig_all_leds);
+	led_set_trigger_data(led_cdev, led);
+
+exit_unlock:
+	mutex_unlock(&blkdev_trig_mutex);
+exit_free:
+	if (err)
+		kfree(led);
+	return err;
+}
+
+/**
+ * link_dev_by_path_store() - ``link_dev_by_path`` device attribute store
+ *			      function.
+ * @dev:	The LED device
+ * @attr:	The ``link_dev_by_path`` attribute (@dev_attr_link_dev_by_path)
+ * @buf:	The value written to the attribute, which should be the path to
+ *		the special file that represents the block device to be linked
+ *		to the LED (e.g. /dev/sda)
+ * @count:	The number of characters in @buf
+ *
+ * Calls blkdev_trig_get_btb() to find or create the BTB for the block device,
+ * checks that the device isn't already linked to this LED, and calls
+ * blkdev_trig_link() to create the link.
+ *
+ * Context:	Process context.  Takes and releases @blkdev_trig_mutex.
+ * Return:	@count on success, ``-errno`` on error.
+ */
+static ssize_t link_dev_by_path_store(struct device *dev,
+				      struct device_attribute *attr,
+				      const char *buf, size_t count)
+{
+	struct blkdev_trig_led *led = led_trigger_get_drvdata(dev);
+	struct blkdev_trig_bdev *btb;
+	int err;
+
+	err = mutex_lock_interruptible(&blkdev_trig_mutex);
+	if (err)
+		return err;
+
+	btb = blkdev_trig_get_btb(buf, count);
+	if (IS_ERR(btb)) {
+		err = PTR_ERR(btb);
+		goto exit_unlock;
+	}
+
+	if (xa_load(&btb->linked_leds, led->index) != NULL) {
+		err = -EEXIST;
+		goto exit_put_btb;
+	}
+
+	err = blkdev_trig_link(led, btb);
+
+exit_put_btb:
+	if (err)
+		blkdev_trig_put_btb(btb);
+exit_unlock:
+	mutex_unlock(&blkdev_trig_mutex);
+	return err ? : count;
+}
+
+/**
+ * blkdev_trig_get_btb() - Find or create the BTB for a block device.
+ * @buf:	The value written to the ``link_dev_by_path`` attribute, which
+ *		should be the path to a special file that represents a block
+ *		device
+ * @count:	The number of characters in @buf
+ *
+ * Calls blkdev_trig_get_bdev() to get the block device represented by the path
+ * in @buf.  If the device already has a BTB (because it is already linked to
+ * an LED), simply returns the existing BTB.
+ *
+ * Otherwise, allocates a new BTB (as a device resource), creates the block
+ * device's ``linked_leds`` directory (attribute group), calls
+ * blkdev_trig_update_btb() to set the BTB's activity counters, and adds the
+ * BTB resource to the block device.
+ *
+ * Context:	Process context.  Caller must hold @blkdev_trig_mutex.
+ * Return:	Pointer to the BTB, error pointer on error.
+ */
+static struct blkdev_trig_bdev *blkdev_trig_get_btb(const char *buf,
+						    size_t count)
+{
+	struct block_device *bdev;
+	struct blkdev_trig_bdev *btb;
+	int err;
+
+	bdev = blkdev_trig_get_bdev(buf, count, BLKDEV_TRIG_FMODE);
+	if (IS_ERR(bdev))
+		return ERR_CAST(bdev);
+
+	btb = devres_find(&bdev->bd_device, blkdev_trig_btb_release,
+			  NULL, NULL);
+	if (btb != NULL) {
+		err = 0;
+		goto exit_put_bdev;
+	}
+
+	if (blkdev_trig_next_index == ULONG_MAX) {
+		err = -EOVERFLOW;
+		goto exit_put_bdev;
+	}
+
+	btb = devres_alloc(blkdev_trig_btb_release, sizeof(*btb), GFP_KERNEL);
+	if (btb == NULL) {
+		err = -ENOMEM;
+		goto exit_put_bdev;
+	}
+
+	err = sysfs_create_group(bdev_kobj(bdev), &blkdev_trig_linked_leds);
+	if (err)
+		goto exit_free_btb;
+
+	btb->index = blkdev_trig_next_index++;
+	btb->bdev = bdev;
+	xa_init(&btb->linked_leds);
+	blkdev_trig_update_btb(btb, jiffies);
+
+	devres_add(&bdev->bd_device, btb);
+
+exit_free_btb:
+	if (err)
+		devres_free(btb);
+exit_put_bdev:
+	blkdev_put(bdev, BLKDEV_TRIG_FMODE);
+	return err ? ERR_PTR(err) : btb;
+}
+
+/**
+ * blkdev_trig_get_bdev() - Get a block device by path.
+ * @buf:	The value written to the ``link_dev_by_path`` or
+ *		``unlink_dev_by_path`` attribute, which should be the path to a
+ *		special file that represents a block device
+ * @count:	The number of characters in @buf (not including its terminating
+ *		null)
+ *
+ * Copies @buf to a writable buffer, trims the trailing newline (if any), and
+ * calls blkdev_get_by_path() to resolve the block device.
+ *
+ * The caller must call blkdev_put() when finished with the device.
+ *
+ * Context:	Process context.
+ * Return:	The block device, or an error pointer.
+ */
+static struct block_device *blkdev_trig_get_bdev(const char *buf, size_t count,
+						 fmode_t mode)
+{
+	struct block_device *bdev;
+	char *path;
+
+	path = kmemdup(buf, count + 1, GFP_KERNEL);  /* +1 to include null */
+	if (path == NULL)
+		return ERR_PTR(-ENOMEM);
+
+	if (path[count - 1] == '\n')
+		path[count - 1] = 0;
+
+	bdev = blkdev_get_by_path(path, mode, THIS_MODULE);
+	kfree(path);
+	return bdev;
+}
+
+/**
+ * blkdev_trig_update_btb() - Update a BTB's activity counters.
+ * @btb:	The BTB
+ *
+ * Checks each of the BTB's block device's I/O counters.  If the counter has
+ * changed since the last check, updates the counter and its timestamp in the
+ * BTB.
+ *
+ * Context:	Process context.  Caller must hold @blkdev_trig_mutex.
+ */
+static void blkdev_trig_update_btb(struct blkdev_trig_bdev *btb,
+				   unsigned long now)
+{
+	unsigned long new_ios;
+	enum stat_group i;
+
+	for (i = STAT_READ; i <= STAT_FLUSH; ++i) {
+
+		new_ios = part_stat_read(btb->bdev, ios[i]);
+
+		if (new_ios != btb->ios[i]) {
+			btb->ios[i] = new_ios;
+			btb->last_activity[i] = now;
+		}
+	}
+
+	btb->last_checked = now;
+}
+
+/**
+ * blkdev_trig_link() - "Link" a block device to an LED.
+ * @led:	The LED
+ * @btb:	The block device
+ *
+ * Called from link_dev_by_path_store() to create the link between an LED and a
+ * block device.
+ *
+ *   * Adds block device symlink to LED's ``linked_devices`` directory.
+ *   * Adds LED symlink to block devices's ``linked_leds`` directory.
+ *   * Adds the BTB to the LED's @linked_btbs and adds the LED to the BTB's
+ *     @linked_leds.
+ *   * If this is the first block device linked to this LED, calls
+ *     blkdev_trig_new_sched() to (if needed) schedule or reschedule the delayed
+ *     work which periodically checks for block device activity and blinks LEDs.
+ *
+ * Context:	Process context.  Caller must hold @blkdev_trig_mutex.
+ * Return:	0 on success, ``-errno`` on error.
+ */
+static int blkdev_trig_link(struct blkdev_trig_led *led,
+			    struct blkdev_trig_bdev *btb)
+{
+	bool led_first_link;
+	int err;
+
+	led_first_link = xa_empty(&led->linked_btbs);
+
+	err = xa_insert(&btb->linked_leds, led->index, led, GFP_KERNEL);
+	if (err)
+		return err;
+
+	err = xa_insert(&led->linked_btbs, btb->index, btb, GFP_KERNEL);
+	if (err)
+		goto error_erase_led;
+
+	/* Create /sys/class/block/<bdev>/linked_leds/<led> symlink */
+	err = sysfs_add_link_to_group(bdev_kobj(btb->bdev),
+				      blkdev_trig_linked_leds.name,
+				      &led->led_cdev->dev->kobj,
+				      led->led_cdev->name);
+	if (err)
+		goto error_erase_btb;
+
+	/* Create /sys/class/leds/<led>/linked_devices/<bdev> symlink */
+	err = sysfs_add_link_to_group(&led->led_cdev->dev->kobj,
+				      blkdev_trig_linked_devs.name,
+				      bdev_kobj(btb->bdev),
+				      dev_name(&btb->bdev->bd_device));
+	if (err)
+		goto error_remove_symlink;
+
+	/*
+	 * If this isn't the first block device linked to this LED, then the
+	 * delayed work schedule already reflects this LED.
+	 */
+	if (led_first_link)
+		blkdev_trig_sched_led(led);
+
+	++blkdev_trig_link_count;
+
+	return 0;
+
+error_remove_symlink:
+	sysfs_remove_link_from_group(bdev_kobj(btb->bdev),
+				     blkdev_trig_linked_leds.name,
+				     led->led_cdev->name);
+error_erase_btb:
+	xa_erase(&led->linked_btbs, btb->index);
+error_erase_led:
+	xa_erase(&btb->linked_leds, led->index);
+	return err;
+}
+
+/**
+ * blkdev_trig_sched_led() - Set the schedule of the delayed work when a new
+ *			     LED is added to the schedule.
+ * @led:	The LED
+ *
+ * Called from blkdev_trig_link() to set or adjust the schedule of the delayed
+ * work which periodically checks block devices for activity and blinks LEDs,
+ * if necessary.
+ *
+ *   * If no other links exist, the delayed work is scheduled.
+ *   * If the delayed work is already scheduled to run soon enough to
+ *     accommodate the newly linked LED's @check_jiffies, no change is made to
+ *     the delayed work's schedule.
+ *   * If the delayed work is already scheduled, but it isn't scheduled to
+ *     run soon enough, the schedule is modified.
+ *
+ * Context:	Process context.  Caller must hold @blkdev_trig_mutex.
+ */
+static void blkdev_trig_sched_led(const struct blkdev_trig_led *led)
+{
+	unsigned long delay = READ_ONCE(led->check_jiffies);
+	unsigned long check_by = jiffies + delay;
+
+	if (blkdev_trig_link_count == 0) {
+		WARN_ON(!schedule_delayed_work(&blkdev_trig_work, delay));
+		blkdev_trig_next_check = check_by;
+		return;
+	}
+
+	if (time_after_eq(check_by, blkdev_trig_next_check))
+		return;
+
+	WARN_ON(!mod_delayed_work(system_wq, &blkdev_trig_work, delay));
+	blkdev_trig_next_check = check_by;
+}
+
+/**
+ * unlink_dev_by_path_store() - ``unlink_dev_by_path`` device attribute store
+ *				function.
+ * @dev:	The LED device
+ * @attr:	The ``unlink_dev_by_path`` attribute
+ *		(@dev_attr_unlink_dev_by_path)
+ * @buf:	The value written to the attribute, which should be the path to
+ *		the special file that represents the block device to be unlinked
+ *		from the LED (e.g. /dev/sda)
+ * @count:	The number of characters in @buf
+ *
+ * Block device name is written to the attribute to "unlink" the block device
+ * from the LED.  I.e. the LED will no longer blink to show activity on that
+ * block device.
+ *
+ * Calls blkdev_trig_get_bdev() to get the block device represented by the path
+ * in @buf.  If the device has a BTB, searches the BTB's list of LEDs for a
+ * link to this LED and (if found) calls blkdev_trig_unlink() to destroy the
+ * link.
+ *
+ * Context:	Process context.  Takes and releases @blkdev_trig_mutex.
+ * Return:	@count on success, ``-errno`` on error.
+ */
+static ssize_t unlink_dev_by_path_store(struct device *dev,
+					struct device_attribute *attr,
+					const char *buf, size_t count)
+{
+	struct blkdev_trig_led *led = led_trigger_get_drvdata(dev);
+	struct block_device *bdev;
+	struct blkdev_trig_bdev *btb;
+	int err;
+
+	bdev = blkdev_trig_get_bdev(buf, count, BLKDEV_TRIG_FMODE);
+	if (IS_ERR(bdev))
+		return PTR_ERR(bdev);
+
+	err = mutex_lock_interruptible(&blkdev_trig_mutex);
+	if (err)
+		goto exit_put_bdev;
+
+	btb = devres_find(&bdev->bd_device, blkdev_trig_btb_release,
+			  NULL, NULL);
+	if (btb == NULL) {
+		err = -EUNATCH;  /* bdev isn't linked to any LED */
+		goto exit_unlock;
+	}
+
+	if (xa_load(&btb->linked_leds, led->index) == NULL) {
+		err = -EUNATCH;  /* bdev isn't linked to this LED */
+		goto exit_unlock;
+	}
+
+	blkdev_trig_unlink(led, btb, BLKDEV_TRIG_NOT_RELEASING);
+
+exit_unlock:
+	mutex_unlock(&blkdev_trig_mutex);
+exit_put_bdev:
+	blkdev_put(bdev, BLKDEV_TRIG_FMODE);
+	return err ? : count;
+}
+
+/**
+ * blkdev_trig_unlink() - "Unlink" a block device from an LED.
+ * @led:		The LED
+ * @btb:		The block device
+ * @unlink_mode:	Indicates whether the BTB is being released (because
+ *			the block device has been removed)
+ *
+ * Removes the link between an LED and a block device.
+ *
+ *   * Removes the BTB from the LED's @linked_btbs and removes the LED from
+ *     the BTB's @linked_leds.
+ *   * Removes the block device symlink from the LED's ``linked_devices``
+ *     directory.
+ *
+ * If the block device is **not** being released:
+ *
+ *   * Removes the LED symlink from the block device's ``linked_leds``
+ *     directory.
+ *   * Calls blkdev_trig_put_btb() to clean up the BTB, if required.
+ *
+ * If the removed link was the only one (i.e. there are no existing block
+ * device/LED links after its removal), cancels the periodic delayed work
+ * which checks for device activity.
+ *
+ * This function is called from multiple locations.
+ *
+ *   * unlink_dev_by_path_store() calls this function when a block device is
+ *     unlinked from an LED via the ``unlink_dev_by_path`` sysfs attribute.
+ *     (@unlink_mode == ``BLKDEV_TRIG_NOT_RELEASING``)
+ *   * blkdev_trig_deactivate() calls this function for each block device linked
+ *     to an LED that is being deactivated (disassociated from the trigger).
+ *     (@unlink_mode == ``BLKDEV_TRIG_NOT_RELEASING``).
+ *   * blkdev_trig_btb_release() calls this function for each LED linked to a
+ *     block device that has been removed from the system.  (@unlink_mode ==
+ *     ``BLKDEV_TRIG_RELEASING).
+ *
+ * Context:	Process context.  Caller must hold @blkdev_trig_mutex.
+ */
+static void blkdev_trig_unlink(struct blkdev_trig_led *led,
+			       struct blkdev_trig_bdev *btb,
+			       enum blkdev_trig_unlink_mode unlink_mode)
+{
+	--blkdev_trig_link_count;
+
+	if (blkdev_trig_link_count == 0)
+		WARN_ON(!cancel_delayed_work_sync(&blkdev_trig_work));
+
+	xa_erase(&btb->linked_leds, led->index);
+	xa_erase(&led->linked_btbs, btb->index);
+
+	/* Remove /sys/class/leds/<led>/linked_devices/<bdev> symlink */
+	sysfs_remove_link_from_group(&led->led_cdev->dev->kobj,
+				     blkdev_trig_linked_devs.name,
+				     dev_name(&btb->bdev->bd_device));
+
+	/*
+	 * If the BTB is being released, the driver core has already removed the
+	 * device's attribute groups, and the BTB will be freed automatically,
+	 * so only do these steps if the BTB is not being released.
+	 */
+	if (unlink_mode == BLKDEV_TRIG_NOT_RELEASING) {
+
+		/* Remove /sys/class/block/<bdev>/linked_leds/<led> symlink */
+		sysfs_remove_link_from_group(bdev_kobj(btb->bdev),
+					     blkdev_trig_linked_leds.name,
+					     led->led_cdev->name);
+		blkdev_trig_put_btb(btb);
+	}
+}
+
+/**
+ * blkdev_trig_put_btb() - Remove and free a BTB, if it is no longer needed.
+ * @btb:	The BTB
+ *
+ * Does nothing if the BTB (block device) is still linked to at least one LED.
+ *
+ * If the BTB is no longer linked to any LEDs, removes the block device's
+ * ``linked_leds`` directory (attribute group), removes the BTB from the
+ * block device's resource list, and frees the BTB.
+ *
+ * Called from blkdev_trig_unlink() (and in the link_dev_by_path_store() error
+ * path).
+ *
+ * Context:	Process context.  Caller must hold @blkdev_trig_mutex.
+ */
+static void blkdev_trig_put_btb(struct blkdev_trig_bdev *btb)
+{
+	struct block_device *bdev = btb->bdev;
+	int err;
+
+	if (xa_empty(&btb->linked_leds)) {
+
+		sysfs_remove_group(bdev_kobj(bdev), &blkdev_trig_linked_leds);
+		err = devres_destroy(&bdev->bd_device, blkdev_trig_btb_release,
+				     NULL, NULL);
+		WARN_ON(err);
+	}
+}
+
+/**
+ * blkdev_trig_deactivate() - Called when an LED is disassociated from the
+ *			      trigger.
+ * @led_cdev:	The LED
+ *
+ * Calls blkdev_trig_unlink() for each block device linked to the LED, removes
+ * the LED from the @blkdevtrig_all_leds list, and frees the @blkdev_trig_led.
+ *
+ * Context:	Process context.  Takes and releases @blkdev_trig_mutex.
+ */
+static void blkdev_trig_deactivate(struct led_classdev *led_cdev)
+{
+	struct blkdev_trig_led *led = led_get_trigger_data(led_cdev);
+	struct blkdev_trig_bdev *btb;
+	unsigned long index;
+
+	mutex_lock(&blkdev_trig_mutex);
+
+	xa_for_each (&led->linked_btbs, index, btb)
+		blkdev_trig_unlink(led, btb, BLKDEV_TRIG_NOT_RELEASING);
+
+	hlist_del(&led->all_leds_node);
+	kfree(led);
+
+	mutex_unlock(&blkdev_trig_mutex);
+}
+
+/**
+ * blkdev_trig_btb_release() - BTB device resource release function.
+ * @dev:	The block device
+ * @res:	The BTB
+ *
+ * Called by the driver core when a block device with a BTB is removed from
+ * the system.  Calls blkdev_trig_unlink() for each LED linked to the block
+ * device.
+ *
+ * Context:	Process context.  Takes and releases @blkdev_trig_mutex.
+ */
+static void blkdev_trig_btb_release(struct device *dev, void *res)
+{
+	struct blkdev_trig_bdev *btb = res;
+	struct blkdev_trig_led *led;
+	unsigned long index;
+
+	mutex_lock(&blkdev_trig_mutex);
+
+	xa_for_each (&btb->linked_leds, index, led)
+		blkdev_trig_unlink(led, btb, BLKDEV_TRIG_RELEASING);
+
+	mutex_unlock(&blkdev_trig_mutex);
+}
+
+/**
+ * blkdev_trig_check() - Check linked devices for activity and blink LEDs.
+ * @work:	Delayed work (@blkdev_trig_work)
+ *
+ * Called periodically (as delayed work) to check linked block devices for
+ * activity and blink LEDs.
+ *
+ *   * Iterates through all LEDs associated with the trigger.
+ *   * If an LED is due to be checked, iterates through the block devices (BTBs)
+ *     linked to the LED.
+ *   * If a block device has not already been checked during this pass, calls
+ *     blkdev_trig_update_btb() to update the BTB's activity counters and
+ *     timestamps.
+ *   * If the LED has not already been blinked during this pass, calls
+ *     blkdev_trig_blink() to blink it if the correct type of activity has
+ *     occurred since the LED was last checked.
+ *
+ * When finished, schedules itself to run again when the next LED is due to be
+ * checked.
+ *
+ * Context:	Process context.  Takes and releases @blkdev_trig_mutex.
+ */
+static void blkdev_trig_check(struct work_struct *work)
+{
+	struct blkdev_trig_led *led;
+	struct blkdev_trig_bdev *btb;
+	unsigned long index, delay, now, led_check, led_delay;
+	bool blinked;
+
+	if (!mutex_trylock(&blkdev_trig_mutex)) {
+		delay = msecs_to_jiffies(BLKDEV_TRIG_CHECK_RETRY);
+		goto exit_reschedule;
+	}
+
+	now = jiffies;
+	delay = ULONG_MAX;
+
+	hlist_for_each_entry (led, &blkdev_trig_all_leds, all_leds_node) {
+
+		led_check = led->last_checked + led->check_jiffies;
+
+		if (time_before_eq(led_check, now)) {
+
+			blinked = false;
+
+			xa_for_each (&led->linked_btbs, index, btb) {
+
+				if (btb->last_checked != now)
+					blkdev_trig_update_btb(btb, now);
+				if (!blinked)
+					blinked = blkdev_trig_blink(led, btb);
+			}
+
+			led->last_checked = now;
+			led_delay = led->check_jiffies;
+
+		} else {
+			led_delay = led_check - now;
+		}
+
+		if (led_delay < delay)
+			delay = led_delay;
+	}
+
+	mutex_unlock(&blkdev_trig_mutex);
+
+exit_reschedule:
+	WARN_ON_ONCE(delay == ULONG_MAX);
+	WARN_ON_ONCE(!schedule_delayed_work(&blkdev_trig_work, delay));
+}
+
+/**
+ * blkdev_trig_blink() - Blink an LED, if the correct type of activity has
+ *			 occurred on the block device.
+ * @led:	The LED
+ * @btb:	The block device
+ *
+ * Context:	Process context.  Caller must hold @blkdev_trig_mutex.
+ * Return:	``true`` if the LED is blinked, ``false`` if not.
+ */
+static bool blkdev_trig_blink(const struct blkdev_trig_led *led,
+			      const struct blkdev_trig_bdev *btb)
+{
+	unsigned long delay_on, delay_off;
+	enum stat_group i;
+	unsigned long mode, mask;
+
+	mode = READ_ONCE(led->mode);
+
+	for (i = STAT_READ, mask = 1; i <= STAT_FLUSH; ++i, mask <<= 1) {
+
+		if (!(mode & mask))
+			continue;
+
+		if (time_before_eq(btb->last_activity[i], led->last_checked))
+			continue;
+
+		delay_on = READ_ONCE(led->blink_msec);
+		delay_off = 1;	/* 0 leaves LED turned on */
+
+		led_blink_set_oneshot(led->led_cdev, &delay_on, &delay_off, 0);
+		return true;
+	}
+
+	return false;
+}
+
+/**
+ * blink_time_show() - ``blink_time`` device attribute show function.
+ * @dev:	The LED device
+ * @attr:	The ``blink_time`` attribute (@dev_attr_blink_time)
+ * @buf:	Output buffer
+ *
+ * Writes the current value of the LED's @blink_msec to @buf.
+ *
+ * Context:	Process context.
+ * Return:	The number of characters written to @buf.
+ */
+static ssize_t blink_time_show(struct device *dev,
+			       struct device_attribute *attr, char *buf)
+{
+	const struct blkdev_trig_led *led = led_trigger_get_drvdata(dev);
+
+	return sprintf(buf, "%u\n", READ_ONCE(led->blink_msec));
+}
+
+/**
+ * blink_time_store() - ``blink_time`` device attribute store function.
+ * @dev:	The LED device
+ * @attr:	The ``blink_time`` attribute (@dev_attr_blink_time)
+ * @buf:	The new value (as written to the sysfs attribute)
+ * @count:	The number of characters in @buf
+ *
+ * Sets the LED's @blink_msec (the duration in milliseconds of one blink).
+ *
+ * Context:	Process context.
+ * Return:	@count on success, ``-errno`` on error.
+ */
+static ssize_t blink_time_store(struct device *dev,
+				struct device_attribute *attr,
+				const char *buf, size_t count)
+{
+	struct blkdev_trig_led *led = led_trigger_get_drvdata(dev);
+	unsigned int value;
+	int err;
+
+	err = kstrtouint(buf, 0, &value);
+	if (err)
+		return err;
+
+	if (value < BLKDEV_TRIG_BLINK_MIN || value > BLKDEV_TRIG_BLINK_MAX)
+		return -ERANGE;
+
+	WRITE_ONCE(led->blink_msec, value);
+	return count;
+}
+
+/**
+ * check_interval_show() - ``check_interval`` device attribute show function.
+ * @dev:	The LED device
+ * @attr:	The ``check_interval`` attribute (@dev_attr_check_interval)
+ * @buf:	Output buffer
+ *
+ * Writes the current value of the LED's @check_jiffies (converted to
+ * milliseconds) to @buf.
+ *
+ * Context:	Process context.
+ * Return:	The number of characters written to @buf.
+ */
+static ssize_t check_interval_show(struct device *dev,
+				   struct device_attribute *attr, char *buf)
+{
+	struct blkdev_trig_led *led = led_trigger_get_drvdata(dev);
+
+	return sprintf(buf, "%u\n",
+		       jiffies_to_msecs(READ_ONCE(led->check_jiffies)));
+}
+
+/**
+ * check_interval_store() - ``check_interval`` device attribute store function
+ * @dev:	The LED device
+ * @attr:	The ``check_interval`` attribute (@dev_attr_check_interval)
+ * @buf:	The new value (as written to the sysfs attribute)
+ * @count:	The number of characters in @buf
+ *
+ * Sets the LED's @check_jiffies (after converting from milliseconds).
+ *
+ * Context:	Process context.
+ * Return:	@count on success, ``-errno`` on error.
+ */
+static ssize_t check_interval_store(struct device *dev,
+				    struct device_attribute *attr,
+				    const char *buf, size_t count)
+{
+	struct blkdev_trig_led *led = led_trigger_get_drvdata(dev);
+	unsigned int value;
+	int err;
+
+	err = kstrtouint(buf, 0, &value);
+	if (err)
+		return err;
+
+	if (value < BLKDEV_TRIG_CHECK_MIN || value > BLKDEV_TRIG_CHECK_MAX)
+		return -ERANGE;
+
+	WRITE_ONCE(led->check_jiffies, msecs_to_jiffies(value));
+
+	return count;
+}
+
+/**
+ * blkdev_trig_mode_show() - Helper for boolean attribute show functions.
+ * @led:	The LED
+ * @buf:	Output buffer
+ * @bit:	Which bit to show
+ *
+ * Context:	Process context.
+ * Return:	The number of characters written to @buf.
+ */
+static int blkdev_trig_mode_show(const struct blkdev_trig_led *led, char *buf,
+				 enum stat_group bit)
+{
+	return sprintf(buf, READ_ONCE(led->mode) & (1 << bit) ? "Y\n" : "N\n");
+}
+
+/**
+ * blkdev_trig_mode_store() - Helper for boolean attribute store functions.
+ * @led:	The LED
+ * @buf:	The new value (as written to the sysfs attribute)
+ * @count:	The number of characters in @buf
+ * @bit:	Which bit to set
+ *
+ * Context:	Process context.
+ * Return:	@count on success, ``-errno`` on error.
+ */
+static int blkdev_trig_mode_store(struct blkdev_trig_led *led,
+				  const char *buf, size_t count,
+				  enum stat_group bit)
+{
+	bool set;
+	int err;
+
+	err = kstrtobool(buf, &set);
+	if (err)
+		return err;
+
+	if (set)
+		set_bit(bit, &led->mode);
+	else
+		clear_bit(bit, &led->mode);
+
+	return count;
+}
+
+/**
+ * blink_on_read_show() - ``blink_on_read`` device attribute show function.
+ * @dev:	The LED device
+ * @attr:	The ``blink_on_read`` attribute (@dev_attr_blink_on_read)
+ * @buf:	Output buffer
+ *
+ * Writes the current value of the LED's @mode read bit to @buf.
+ *
+ * Context:	Process context.
+ * Return:	The number of characters written to @buf.
+ */
+static ssize_t blink_on_read_show(struct device *dev,
+				  struct device_attribute *attr, char *buf)
+{
+	return blkdev_trig_mode_show(led_trigger_get_drvdata(dev),
+				     buf, STAT_READ);
+}
+
+/**
+ * blink_on_read_store() - ``blink_on_read`` device attribute store function.
+ * @dev:	The LED device
+ * @attr:	The ``blink_on_read`` attribute (@dev_attr_blink_on_read)
+ * @buf:	The new value (as written to the sysfs attribute)
+ * @count:	The number of characters in @buf
+ *
+ * Sets or clears the LED's @mode read bit.
+ *
+ * Context:	Process context.
+ * Return:	@count on success, ``-errno`` on error.
+ */
+static ssize_t blink_on_read_store(struct device *dev,
+				   struct device_attribute *attr,
+				   const char *buf, size_t count)
+{
+	return blkdev_trig_mode_store(led_trigger_get_drvdata(dev),
+				      buf, count, STAT_READ);
+}
+
+/**
+ * blink_on_write_show() - ``blink_on_write`` device attribute show function.
+ * @dev:	The LED device
+ * @attr:	The ``blink_on_write`` attribute (@dev_attr_blink_on_write)
+ * @buf:	Output buffer
+ *
+ * Writes the current value of the LED's @mode write bit to @buf.
+ *
+ * Context:	Process context.
+ * Return:	The number of characters written to @buf.
+ */
+static ssize_t blink_on_write_show(struct device *dev,
+				   struct device_attribute *attr, char *buf)
+{
+	return blkdev_trig_mode_show(led_trigger_get_drvdata(dev),
+				     buf, STAT_WRITE);
+}
+
+/**
+ * blink_on_write_store() - ``blink_on_write`` device attribute store function.
+ * @dev:	The LED device
+ * @attr:	The ``blink_on_write`` attribute (@dev_attr_blink_on_write)
+ * @buf:	The new value (as written to the sysfs attribute)
+ * @count:	The number of characters in @buf
+ *
+ * Sets or clears the LED's @mode write bit.
+ *
+ * Context:	Process context.
+ * Return:	@count on success, ``-errno`` on error.
+ */
+static ssize_t blink_on_write_store(struct device *dev,
+				    struct device_attribute *attr,
+				    const char *buf, size_t count)
+{
+	return blkdev_trig_mode_store(led_trigger_get_drvdata(dev),
+				      buf, count, STAT_WRITE);
+}
+
+/**
+ * blink_on_flush_show() - ``blink_on_flush`` device attribute show function.
+ * @dev:	The LED device
+ * @attr:	The ``blink_on_flush`` attribute (@dev_attr_blink_on_flush)
+ * @buf:	Output buffer
+ *
+ * Writes the current value of the LED's @mode flush bit to @buf.
+ *
+ * Context:	Process context.
+ * Return:	The number of characters written to @buf.
+ */
+static ssize_t blink_on_flush_show(struct device *dev,
+				   struct device_attribute *attr, char *buf)
+{
+	return blkdev_trig_mode_show(led_trigger_get_drvdata(dev),
+				     buf, STAT_FLUSH);
+}
+
+/**
+ * blink_on_flush_store() - ``blink_on_flush`` device attribute store function.
+ * @dev:	The LED device
+ * @attr:	The ``blink_on_flush`` attribute (@dev_attr_blink_on_flush)
+ * @buf:	The new value (as written to the sysfs attribute)
+ * @count:	The number of characters in @buf
+ *
+ * Sets or clears the LED's @mode flush bit.
+ *
+ * Context:	Process context.
+ * Return:	@count on success, ``-errno`` on error.
+ */
+static ssize_t blink_on_flush_store(struct device *dev,
+				    struct device_attribute *attr,
+				    const char *buf, size_t count)
+{
+	return blkdev_trig_mode_store(led_trigger_get_drvdata(dev),
+				      buf, count, STAT_FLUSH);
+}
+
+/**
+ * blink_on_discard_show() - ``blink_on_discard`` device attribute show
+ *			     function.
+ * @dev:	The LED device
+ * @attr:	The ``blink_on_discard`` attribute (@dev_attr_blink_on_discard)
+ * @buf:	Output buffer
+ *
+ * Writes the current value of the LED's @mode discard bit to @buf.
+ *
+ * Context:	Process context.
+ * Return:	The number of characters written to @buf.
+ */
+static ssize_t blink_on_discard_show(struct device *dev,
+				     struct device_attribute *attr, char *buf)
+{
+	return blkdev_trig_mode_show(led_trigger_get_drvdata(dev),
+				     buf, STAT_DISCARD);
+}
+
+/**
+ * blink_on_discard_store() - ``blink_on_discard`` device attribute store
+ *			      function.
+ * @dev:	The LED device
+ * @attr:	The ``blink_on_discard`` attribute (@dev_attr_blink_on_discard)
+ * @buf:	The new value (as written to the sysfs attribute)
+ * @count:	The number of characters in @buf
+ *
+ * Sets or clears the LED's @mode discard bit.
+ *
+ * Context:	Process context.
+ * Return:	@count on success, ``-errno`` on error.
+ */
+static ssize_t blink_on_discard_store(struct device *dev,
+				      struct device_attribute *attr,
+				      const char *buf, size_t count)
+{
+	return blkdev_trig_mode_store(led_trigger_get_drvdata(dev),
+				      buf, count, STAT_DISCARD);
+}
+
+/* Device attributes */
+static DEVICE_ATTR_WO(link_dev_by_path);
+static DEVICE_ATTR_WO(unlink_dev_by_path);
+static DEVICE_ATTR_RW(blink_time);
+static DEVICE_ATTR_RW(check_interval);
+static DEVICE_ATTR_RW(blink_on_read);
+static DEVICE_ATTR_RW(blink_on_write);
+static DEVICE_ATTR_RW(blink_on_flush);
+static DEVICE_ATTR_RW(blink_on_discard);
+
+/* Device attributes in LED directory (/sys/class/leds/<led>/...) */
+static struct attribute *blkdev_trig_attrs[] = {
+	&dev_attr_link_dev_by_path.attr,
+	&dev_attr_unlink_dev_by_path.attr,
+	&dev_attr_blink_time.attr,
+	&dev_attr_check_interval.attr,
+	&dev_attr_blink_on_read.attr,
+	&dev_attr_blink_on_write.attr,
+	&dev_attr_blink_on_flush.attr,
+	&dev_attr_blink_on_discard.attr,
+	NULL
+};
+
+/* Unnamed attribute group == no subdirectory */
+static const struct attribute_group blkdev_trig_attr_group = {
+	.attrs	= blkdev_trig_attrs,
+};
+
+/* Attribute groups for the trigger */
+static const struct attribute_group *blkdev_trig_attr_groups[] = {
+	&blkdev_trig_attr_group,   /* /sys/class/leds/<led>/... */
+	&blkdev_trig_linked_devs,  /* /sys/class/leds/<led>/linked_devices/ */
+	NULL
+};
+
+/* Trigger registration data */
+static struct led_trigger blkdev_trig_trigger = {
+	.name		= "blkdev",
+	.activate	= blkdev_trig_activate,
+	.deactivate	= blkdev_trig_deactivate,
+	.groups		= blkdev_trig_attr_groups,
+};
+
+/**
+ * blkdev_trig_init() - Block device LED trigger initialization.
+ *
+ * Registers the LED trigger.
+ *
+ * Return:	0 on success, ``-errno`` on failure.
+ */
+static int __init blkdev_trig_init(void)
+{
+	return led_trigger_register(&blkdev_trig_trigger);
+}
+module_init(blkdev_trig_init);
+
+/**
+ * blkdev_trig_exit() - Block device LED trigger module exit.
+ *
+ * Unregisters the LED trigger.
+ */
+static void __exit blkdev_trig_exit(void)
+{
+	led_trigger_unregister(&blkdev_trig_trigger);
+}
+module_exit(blkdev_trig_exit);
+
+MODULE_DESCRIPTION("Block device LED trigger");
+MODULE_AUTHOR("Ian Pilcher <arequipeno@gmail.com>");
+MODULE_LICENSE("GPL v2");
-- 
2.37.3.485.gbe1a02a17e


From d55439dcf98a3d4268dbd459ba30e4574fe2cfc0 Mon Sep 17 00:00:00 2001
From: Philip Yang <Philip.Yang@amd.com>
Date: Fri, 22 Jul 2022 15:07:00 -0400
Subject: [PATCH 08/41] drm/amdgpu: Allow TTM to evict svm bo from same process

To support SVM range VRAM overcommitment, TTM should be able to evict
svm bo of same process to system memory, to get space to alloc new svm
bo.

Signed-off-by: Philip Yang <Philip.Yang@amd.com>
Reviewed-by: Felix Kuehling <Felix.Kuehling@amd.com>
Signed-off-by: Alex Deucher <alexander.deucher@amd.com>
---
 drivers/gpu/drm/amd/amdgpu/amdgpu_amdkfd_fence.c | 9 ++++++---
 1 file changed, 6 insertions(+), 3 deletions(-)

diff --git a/drivers/gpu/drm/amd/amdgpu/amdgpu_amdkfd_fence.c b/drivers/gpu/drm/amd/amdgpu/amdgpu_amdkfd_fence.c
index 1d0dbff87..469785d33 100644
--- a/drivers/gpu/drm/amd/amdgpu/amdgpu_amdkfd_fence.c
+++ b/drivers/gpu/drm/amd/amdgpu/amdgpu_amdkfd_fence.c
@@ -159,11 +159,14 @@ static void amdkfd_fence_release(struct dma_fence *f)
 }
 
 /**
- * amdkfd_fence_check_mm - Check if @mm is same as that of the fence @f
- *  if same return TRUE else return FALSE.
+ * amdkfd_fence_check_mm - Check whether to prevent eviction of @f by @mm
  *
  * @f: [IN] fence
  * @mm: [IN] mm that needs to be verified
+ *
+ * Check if @mm is same as that of the fence @f, if same return TRUE else
+ * return FALSE.
+ * For svm bo, which support vram overcommitment, always return FALSE.
  */
 bool amdkfd_fence_check_mm(struct dma_fence *f, struct mm_struct *mm)
 {
@@ -171,7 +174,7 @@ bool amdkfd_fence_check_mm(struct dma_fence *f, struct mm_struct *mm)
 
 	if (!fence)
 		return false;
-	else if (fence->mm == mm)
+	else if (fence->mm == mm  && !fence->svm_bo)
 		return true;
 
 	return false;
-- 
2.37.3.485.gbe1a02a17e


From f88dcac3ab8967aa30e8160a15ac3cd7a45dff5b Mon Sep 17 00:00:00 2001
From: "Fabio M. De Francesco" <fmdefrancesco@gmail.com>
Date: Sun, 17 Jul 2022 10:36:13 +0200
Subject: [PATCH 09/41] f2fs: Delete f2fs_copy_page() and replace with
 memcpy_page()
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit

f2fs_copy_page() is a wrapper around two kmap() + one memcpy() from/to
the mapped pages. It unnecessarily duplicates a kernel API and it makes
use of kmap(), which is being deprecated in favor of kmap_local_page().

Two main problems with kmap(): (1) It comes with an overhead as mapping
space is restricted and protected by a global lock for synchronization and
(2) it also requires global TLB invalidation when the kmap’s pool wraps
and it might block when the mapping space is fully utilized until a slot
becomes available.

With kmap_local_page() the mappings are per thread, CPU local, can take
page faults, and can be called from any context (including interrupts).
It is faster than kmap() in kernels with HIGHMEM enabled. Therefore, its
use in __clone_blkaddrs() is safe and should be preferred.

Delete f2fs_copy_page() and use a plain memcpy_page() in the only one
site calling the removed function. memcpy_page() avoids open coding two
kmap_local_page() + one memcpy() between the two kernel virtual addresses.

Suggested-by: Christoph Hellwig <hch@infradead.org>
Suggested-by: Ira Weiny <ira.weiny@intel.com>
Signed-off-by: Fabio M. De Francesco <fmdefrancesco@gmail.com>
Reviewed-by: Christoph Hellwig <hch@lst.de>
Signed-off-by: Jaegeuk Kim <jaegeuk@kernel.org>
---
 fs/f2fs/f2fs.h | 10 ----------
 fs/f2fs/file.c |  2 +-
 2 files changed, 1 insertion(+), 11 deletions(-)

diff --git a/fs/f2fs/f2fs.h b/fs/f2fs/f2fs.h
index 7006fa7dd..357c4b955 100644
--- a/fs/f2fs/f2fs.h
+++ b/fs/f2fs/f2fs.h
@@ -2697,16 +2697,6 @@ static inline struct page *f2fs_pagecache_get_page(
 	return pagecache_get_page(mapping, index, fgp_flags, gfp_mask);
 }
 
-static inline void f2fs_copy_page(struct page *src, struct page *dst)
-{
-	char *src_kaddr = kmap(src);
-	char *dst_kaddr = kmap(dst);
-
-	memcpy(dst_kaddr, src_kaddr, PAGE_SIZE);
-	kunmap(dst);
-	kunmap(src);
-}
-
 static inline void f2fs_put_page(struct page *page, int unlock)
 {
 	if (!page)
diff --git a/fs/f2fs/file.c b/fs/f2fs/file.c
index ecd833ba3..dd2d291d1 100644
--- a/fs/f2fs/file.c
+++ b/fs/f2fs/file.c
@@ -1278,7 +1278,7 @@ static int __clone_blkaddrs(struct inode *src_inode, struct inode *dst_inode,
 				f2fs_put_page(psrc, 1);
 				return PTR_ERR(pdst);
 			}
-			f2fs_copy_page(psrc, pdst);
+			memcpy_page(pdst, 0, psrc, 0, PAGE_SIZE);
 			set_page_dirty(pdst);
 			f2fs_put_page(pdst, 1);
 			f2fs_put_page(psrc, 1);
-- 
2.37.3.485.gbe1a02a17e


From 07add4bbe62c2a8f4810c670b2fa987623c73698 Mon Sep 17 00:00:00 2001
From: Borislav Petkov <bp@suse.de>
Date: Sun, 14 Aug 2022 12:37:49 +0200
Subject: [PATCH 10/41] x86/microcode/AMD: Attempt applying on every logical
 thread
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit

Currently, the patch application logic checks whether patch application
is needed on each CPU. Therefore, on SMT designs where the microcode
engine is shared between the two threads, the application happens only
on one of them.

However, there are microcode patches which do per-thread modification,
see Link tag below.

Therefore, drop the revision check and try applying on each thread. This
is what the BIOS does too so this method is very much tested.

Reported-by:  Ștefan Talpalaru <stefantalpalaru@yahoo.com>
Tested-by:  Ștefan Talpalaru <stefantalpalaru@yahoo.com>
Signed-off-by: Borislav Petkov <bp@suse.de>
Link: https://bugzilla.kernel.org/show_bug.cgi?id=216211
---
 arch/x86/kernel/cpu/microcode/amd.c | 39 +++++++----------------------
 1 file changed, 9 insertions(+), 30 deletions(-)

diff --git a/arch/x86/kernel/cpu/microcode/amd.c b/arch/x86/kernel/cpu/microcode/amd.c
index 8b2fcdfa6..a575dbb4d 100644
--- a/arch/x86/kernel/cpu/microcode/amd.c
+++ b/arch/x86/kernel/cpu/microcode/amd.c
@@ -420,8 +420,8 @@ apply_microcode_early_amd(u32 cpuid_1_eax, void *ucode, size_t size, bool save_p
 	struct cont_desc desc = { 0 };
 	u8 (*patch)[PATCH_MAX_SIZE];
 	struct microcode_amd *mc;
-	u32 rev, dummy, *new_rev;
 	bool ret = false;
+	u32 *new_rev;
 
 #ifdef CONFIG_X86_32
 	new_rev = (u32 *)__pa_nodebug(&ucode_new_rev);
@@ -439,10 +439,6 @@ apply_microcode_early_amd(u32 cpuid_1_eax, void *ucode, size_t size, bool save_p
 	if (!mc)
 		return ret;
 
-	native_rdmsr(MSR_AMD64_PATCH_LEVEL, rev, dummy);
-	if (rev >= mc->hdr.patch_id)
-		return ret;
-
 	if (!__apply_microcode_amd(mc)) {
 		*new_rev = mc->hdr.patch_id;
 		ret      = true;
@@ -516,7 +512,7 @@ void load_ucode_amd_ap(unsigned int cpuid_1_eax)
 {
 	struct microcode_amd *mc;
 	struct cpio_data cp;
-	u32 *new_rev, rev, dummy;
+	u32 *new_rev;
 
 	if (IS_ENABLED(CONFIG_X86_32)) {
 		mc	= (struct microcode_amd *)__pa_nodebug(amd_ucode_patch);
@@ -526,10 +522,8 @@ void load_ucode_amd_ap(unsigned int cpuid_1_eax)
 		new_rev = &ucode_new_rev;
 	}
 
-	native_rdmsr(MSR_AMD64_PATCH_LEVEL, rev, dummy);
-
 	/* Check whether we have saved a new patch already: */
-	if (*new_rev && rev < mc->hdr.patch_id) {
+	if (*new_rev) {
 		if (!__apply_microcode_amd(mc)) {
 			*new_rev = mc->hdr.patch_id;
 			return;
@@ -571,23 +565,17 @@ int __init save_microcode_in_initrd_amd(unsigned int cpuid_1_eax)
 
 void reload_ucode_amd(void)
 {
-	struct microcode_amd *mc;
-	u32 rev, dummy __always_unused;
-
-	mc = (struct microcode_amd *)amd_ucode_patch;
+	struct microcode_amd *mc = (struct microcode_amd *)amd_ucode_patch;
 
-	rdmsr(MSR_AMD64_PATCH_LEVEL, rev, dummy);
-
-	if (rev < mc->hdr.patch_id) {
-		if (!__apply_microcode_amd(mc)) {
-			ucode_new_rev = mc->hdr.patch_id;
-			pr_info("reload patch_level=0x%08x\n", ucode_new_rev);
-		}
+	if (!__apply_microcode_amd(mc)) {
+		ucode_new_rev = mc->hdr.patch_id;
+		pr_info("reload patch_level=0x%08x\n", ucode_new_rev);
 	}
 }
 static u16 __find_equiv_id(unsigned int cpu)
 {
 	struct ucode_cpu_info *uci = ucode_cpu_info + cpu;
+
 	return find_equiv_id(&equiv_table, uci->cpu_sig.sig);
 }
 
@@ -678,7 +666,7 @@ static enum ucode_state apply_microcode_amd(int cpu)
 	struct ucode_cpu_info *uci;
 	struct ucode_patch *p;
 	enum ucode_state ret;
-	u32 rev, dummy __always_unused;
+	u32 rev;
 
 	BUG_ON(raw_smp_processor_id() != cpu);
 
@@ -691,14 +679,6 @@ static enum ucode_state apply_microcode_amd(int cpu)
 	mc_amd  = p->data;
 	uci->mc = p->data;
 
-	rdmsr(MSR_AMD64_PATCH_LEVEL, rev, dummy);
-
-	/* need to apply patch? */
-	if (rev >= mc_amd->hdr.patch_id) {
-		ret = UCODE_OK;
-		goto out;
-	}
-
 	if (__apply_microcode_amd(mc_amd)) {
 		pr_err("CPU%d: update failed for patch_level=0x%08x\n",
 			cpu, mc_amd->hdr.patch_id);
@@ -710,7 +690,6 @@ static enum ucode_state apply_microcode_amd(int cpu)
 
 	pr_info("CPU%d: new patch_level=0x%08x\n", cpu, rev);
 
-out:
 	uci->cpu_sig.rev = rev;
 	c->microcode	 = rev;
 
-- 
2.37.3.485.gbe1a02a17e


From 258ff598a4876490bf5cb83b3b177aae51ad1a67 Mon Sep 17 00:00:00 2001
From: Josh Poimboeuf <jpoimboe@kernel.org>
Date: Thu, 18 Aug 2022 08:53:42 -0700
Subject: [PATCH 11/41] x86/kvm: Simplify FOP_SETCC()

SETCC_ALIGN and FOP_ALIGN are both 16.  Remove the special casing for
FOP_SETCC() and just make it a normal fastop.

Signed-off-by: Josh Poimboeuf <jpoimboe@kernel.org>
---
 arch/x86/kvm/emulate.c | 23 ++++-------------------
 1 file changed, 4 insertions(+), 19 deletions(-)

diff --git a/arch/x86/kvm/emulate.c b/arch/x86/kvm/emulate.c
index b1904f5ec..40b34758a 100644
--- a/arch/x86/kvm/emulate.c
+++ b/arch/x86/kvm/emulate.c
@@ -444,27 +444,12 @@ static int fastop(struct x86_emulate_ctxt *ctxt, fastop_t fop);
 	FOP_END
 
 /* Special case for SETcc - 1 instruction per cc */
-
-/*
- * Depending on .config the SETcc functions look like:
- *
- * ENDBR			[4 bytes; CONFIG_X86_KERNEL_IBT]
- * SETcc %al			[3 bytes]
- * RET | JMP __x86_return_thunk	[1,5 bytes; CONFIG_RETHUNK]
- * INT3				[1 byte; CONFIG_SLS]
- */
-#define SETCC_ALIGN	16
-
 #define FOP_SETCC(op) \
-	".align " __stringify(SETCC_ALIGN) " \n\t" \
-	".type " #op ", @function \n\t" \
-	#op ": \n\t" \
-	ASM_ENDBR \
+	FOP_FUNC(op) \
 	#op " %al \n\t" \
-	__FOP_RET(#op) \
-	".skip " __stringify(SETCC_ALIGN) " - (.-" #op "), 0xcc \n\t"
+	FOP_RET(op)
 
-__FOP_START(setcc, SETCC_ALIGN)
+FOP_START(setcc)
 FOP_SETCC(seto)
 FOP_SETCC(setno)
 FOP_SETCC(setc)
@@ -1075,7 +1060,7 @@ static int em_bsr_c(struct x86_emulate_ctxt *ctxt)
 static __always_inline u8 test_cc(unsigned int condition, unsigned long flags)
 {
 	u8 rc;
-	void (*fop)(void) = (void *)em_setcc + SETCC_ALIGN * (condition & 0xf);
+	void (*fop)(void) = (void *)em_setcc + FASTOP_SIZE * (condition & 0xf);
 
 	flags = (flags & EFLAGS_MASK) | X86_EFLAGS_IF;
 	asm("push %[flags]; popf; " CALL_NOSPEC
-- 
2.37.3.485.gbe1a02a17e


From 837bbf220206742bfc5414187ac3402fcf3d5075 Mon Sep 17 00:00:00 2001
From: Josh Poimboeuf <jpoimboe@kernel.org>
Date: Thu, 18 Aug 2022 09:26:57 -0700
Subject: [PATCH 12/41] objtool: Remove "ANNOTATE_NOENDBR on ENDBR" warning

This warning isn't very useful: why would you put ANNOTATE_NOENDBR on
ENDBR, and if you did, what's the harm?

And thus far it's only found one non-bug, where the
'__end_entry_SYSENTER_compat' label happens to land on the ENDBR from
entry_SYSCALL_compat:

  vmlinux.o: warning: objtool: entry_SYSCALL_compat+0x0: ANNOTATE_NOENDBR on ENDBR

.. which is fine.  Just remove the warning.

Reported-by: kernel test robot <lkp@intel.com>
Signed-off-by: Josh Poimboeuf <jpoimboe@kernel.org>
---
 tools/objtool/check.c | 3 ---
 1 file changed, 3 deletions(-)

diff --git a/tools/objtool/check.c b/tools/objtool/check.c
index 5d87e0b0d..beec8cfdb 100644
--- a/tools/objtool/check.c
+++ b/tools/objtool/check.c
@@ -2104,9 +2104,6 @@ static int read_noendbr_hints(struct objtool_file *file)
 			return -1;
 		}
 
-		if (insn->type == INSN_ENDBR)
-			WARN_FUNC("ANNOTATE_NOENDBR on ENDBR", insn->sec, insn->offset);
-
 		insn->noendbr = 1;
 	}
 
-- 
2.37.3.485.gbe1a02a17e


From 64c30eb36e6c0d4fba2e4ccdf454098e922b59bb Mon Sep 17 00:00:00 2001
From: Yu Kuai <yukuai3@huawei.com>
Date: Wed, 3 Aug 2022 20:15:04 +0800
Subject: [PATCH 13/41] sbitmap: fix possible io hung due to lost wakeup

There are two problems can lead to lost wakeup:

1) invalid wakeup on the wrong waitqueue:

For example, 2 * wake_batch tags are put, while only wake_batch threads
are woken:

__sbq_wake_up
 atomic_cmpxchg -> reset wait_cnt
			__sbq_wake_up -> decrease wait_cnt
			...
			__sbq_wake_up -> wait_cnt is decreased to 0 again
			 atomic_cmpxchg
			 sbq_index_atomic_inc -> increase wake_index
			 wake_up_nr -> wake up and waitqueue might be empty
 sbq_index_atomic_inc -> increase again, one waitqueue is skipped
 wake_up_nr -> invalid wake up because old wakequeue might be empty

To fix the problem, increasing 'wake_index' before resetting 'wait_cnt'.

2) 'wait_cnt' can be decreased while waitqueue is empty

As pointed out by Jan Kara, following race is possible:

CPU1				CPU2
__sbq_wake_up			 __sbq_wake_up
 sbq_wake_ptr()			 sbq_wake_ptr() -> the same
 wait_cnt = atomic_dec_return()
 /* decreased to 0 */
 sbq_index_atomic_inc()
 /* move to next waitqueue */
 atomic_set()
 /* reset wait_cnt */
 wake_up_nr()
 /* wake up on the old waitqueue */
				 wait_cnt = atomic_dec_return()
				 /*
				  * decrease wait_cnt in the old
				  * waitqueue, while it can be
				  * empty.
				  */

Fix the problem by waking up before updating 'wake_index' and
'wait_cnt'.

With this patch, noted that 'wait_cnt' is still decreased in the old
empty waitqueue, however, the wakeup is redirected to a active waitqueue,
and the extra decrement on the old empty waitqueue is not handled.

Fixes: 88459642cba4 ("blk-mq: abstract tag allocation out into sbitmap library")
Signed-off-by: Yu Kuai <yukuai3@huawei.com>
Reviewed-by: Jan Kara <jack@suse.cz>
---
 lib/sbitmap.c | 55 ++++++++++++++++++++++++++++++---------------------
 1 file changed, 33 insertions(+), 22 deletions(-)

diff --git a/lib/sbitmap.c b/lib/sbitmap.c
index 29eb04842..1f3114787 100644
--- a/lib/sbitmap.c
+++ b/lib/sbitmap.c
@@ -611,32 +611,43 @@ static bool __sbq_wake_up(struct sbitmap_queue *sbq)
 		return false;
 
 	wait_cnt = atomic_dec_return(&ws->wait_cnt);
-	if (wait_cnt <= 0) {
-		int ret;
+	/*
+	 * For concurrent callers of this, callers should call this function
+	 * again to wakeup a new batch on a different 'ws'.
+	 */
+	if (wait_cnt < 0 || !waitqueue_active(&ws->wait))
+		return true;
 
-		wake_batch = READ_ONCE(sbq->wake_batch);
+	if (wait_cnt > 0)
+		return false;
 
-		/*
-		 * Pairs with the memory barrier in sbitmap_queue_resize() to
-		 * ensure that we see the batch size update before the wait
-		 * count is reset.
-		 */
-		smp_mb__before_atomic();
+	wake_batch = READ_ONCE(sbq->wake_batch);
 
-		/*
-		 * For concurrent callers of this, the one that failed the
-		 * atomic_cmpxhcg() race should call this function again
-		 * to wakeup a new batch on a different 'ws'.
-		 */
-		ret = atomic_cmpxchg(&ws->wait_cnt, wait_cnt, wake_batch);
-		if (ret == wait_cnt) {
-			sbq_index_atomic_inc(&sbq->wake_index);
-			wake_up_nr(&ws->wait, wake_batch);
-			return false;
-		}
+	/*
+	 * Wake up first in case that concurrent callers decrease wait_cnt
+	 * while waitqueue is empty.
+	 */
+	wake_up_nr(&ws->wait, wake_batch);
 
-		return true;
-	}
+	/*
+	 * Pairs with the memory barrier in sbitmap_queue_resize() to
+	 * ensure that we see the batch size update before the wait
+	 * count is reset.
+	 *
+	 * Also pairs with the implicit barrier between decrementing wait_cnt
+	 * and checking for waitqueue_active() to make sure waitqueue_active()
+	 * sees result of the wakeup if atomic_dec_return() has seen the result
+	 * of atomic_set().
+	 */
+	smp_mb__before_atomic();
+
+	/*
+	 * Increase wake_index before updating wait_cnt, otherwise concurrent
+	 * callers can see valid wait_cnt in old waitqueue, which can cause
+	 * invalid wakeup on the old waitqueue.
+	 */
+	sbq_index_atomic_inc(&sbq->wake_index);
+	atomic_set(&ws->wait_cnt, wake_batch);
 
 	return false;
 }
-- 
2.37.3.485.gbe1a02a17e


From 12d8dc82606a270de0be8b7dff4edd603eaf10d5 Mon Sep 17 00:00:00 2001
From: Liu Song <liusong@linux.alibaba.com>
Date: Fri, 26 Aug 2022 11:14:13 +0800
Subject: [PATCH 14/41] sbitmap: remove unnecessary code in
 __sbitmap_queue_get_batch

If "nr + nr_tags <= map_depth", then the value of nr_tags will not be
greater than map_depth, so no additional comparison is required.

Signed-off-by: Liu Song <liusong@linux.alibaba.com>
Link: https://lore.kernel.org/r/1661483653-27326-1-git-send-email-liusong@linux.alibaba.com
Signed-off-by: Jens Axboe <axboe@kernel.dk>
---
 lib/sbitmap.c | 5 ++---
 1 file changed, 2 insertions(+), 3 deletions(-)

diff --git a/lib/sbitmap.c b/lib/sbitmap.c
index 1f3114787..a39b1a877 100644
--- a/lib/sbitmap.c
+++ b/lib/sbitmap.c
@@ -533,10 +533,9 @@ unsigned long __sbitmap_queue_get_batch(struct sbitmap_queue *sbq, int nr_tags,
 		nr = find_first_zero_bit(&map->word, map_depth);
 		if (nr + nr_tags <= map_depth) {
 			atomic_long_t *ptr = (atomic_long_t *) &map->word;
-			int map_tags = min_t(int, nr_tags, map_depth);
 			unsigned long val, ret;
 
-			get_mask = ((1UL << map_tags) - 1) << nr;
+			get_mask = ((1UL << nr_tags) - 1) << nr;
 			do {
 				val = READ_ONCE(map->word);
 				if ((val & ~get_mask) != val)
@@ -547,7 +546,7 @@ unsigned long __sbitmap_queue_get_batch(struct sbitmap_queue *sbq, int nr_tags,
 			if (get_mask) {
 				*offset = nr + (index << sb->shift);
 				update_alloc_hint_after_get(sb, depth, hint,
-							*offset + map_tags - 1);
+							*offset + nr_tags - 1);
 				return get_mask;
 			}
 		}
-- 
2.37.3.485.gbe1a02a17e


From 52bd758b26790257be26ae175367192b6c7dbb98 Mon Sep 17 00:00:00 2001
From: Jan Kara <jack@suse.cz>
Date: Thu, 8 Sep 2022 15:09:37 +0200
Subject: [PATCH 15/41] sbitmap: Avoid leaving waitqueue in invalid state in
 __sbq_wake_up()

When __sbq_wake_up() decrements wait_cnt to 0 but races with someone
else waking the waiter on the waitqueue (so the waitqueue becomes
empty), it exits without reseting wait_cnt to wake_batch number. Once
wait_cnt is 0, nobody will ever reset the wait_cnt or wake the new
waiters resulting in possible deadlocks or busyloops. Fix the problem by
making sure we reset wait_cnt even if we didn't wake up anybody in the
end.

Fixes: 040b83fcecfb ("sbitmap: fix possible io hung due to lost wakeup")
Reported-by: Keith Busch <kbusch@kernel.org>
Signed-off-by: Jan Kara <jack@suse.cz>
---
 lib/sbitmap.c | 18 +++++++++++++++---
 1 file changed, 15 insertions(+), 3 deletions(-)

diff --git a/lib/sbitmap.c b/lib/sbitmap.c
index a39b1a877..47cd8fb89 100644
--- a/lib/sbitmap.c
+++ b/lib/sbitmap.c
@@ -604,6 +604,7 @@ static bool __sbq_wake_up(struct sbitmap_queue *sbq)
 	struct sbq_wait_state *ws;
 	unsigned int wake_batch;
 	int wait_cnt;
+	bool ret;
 
 	ws = sbq_wake_ptr(sbq);
 	if (!ws)
@@ -614,12 +615,23 @@ static bool __sbq_wake_up(struct sbitmap_queue *sbq)
 	 * For concurrent callers of this, callers should call this function
 	 * again to wakeup a new batch on a different 'ws'.
 	 */
-	if (wait_cnt < 0 || !waitqueue_active(&ws->wait))
+	if (wait_cnt < 0)
 		return true;
 
+	/*
+	 * If we decremented queue without waiters, retry to avoid lost
+	 * wakeups.
+	 */
 	if (wait_cnt > 0)
-		return false;
+		return !waitqueue_active(&ws->wait);
 
+	/*
+	 * When wait_cnt == 0, we have to be particularly careful as we are
+	 * responsible to reset wait_cnt regardless whether we've actually
+	 * woken up anybody. But in case we didn't wakeup anybody, we still
+	 * need to retry.
+	 */
+	ret = !waitqueue_active(&ws->wait);
 	wake_batch = READ_ONCE(sbq->wake_batch);
 
 	/*
@@ -648,7 +660,7 @@ static bool __sbq_wake_up(struct sbitmap_queue *sbq)
 	sbq_index_atomic_inc(&sbq->wake_index);
 	atomic_set(&ws->wait_cnt, wake_batch);
 
-	return false;
+	return ret;
 }
 
 void sbitmap_queue_wake_up(struct sbitmap_queue *sbq)
-- 
2.37.3.485.gbe1a02a17e


From ad7255b7f1abae39dbc8a4d1357250411a8d0d8d Mon Sep 17 00:00:00 2001
From: Uros Bizjak <ubizjak@gmail.com>
Date: Thu, 8 Sep 2022 17:12:00 +0200
Subject: [PATCH 16/41] sbitmap: Use atomic_long_try_cmpxchg in
 __sbitmap_queue_get_batch

Use atomic_long_try_cmpxchg instead of
atomic_long_cmpxchg (*ptr, old, new) == old in __sbitmap_queue_get_batch.
x86 CMPXCHG instruction returns success in ZF flag, so this change
saves a compare after cmpxchg (and related move instruction in front
of cmpxchg).

Also, atomic_long_cmpxchg implicitly assigns old *ptr value to "old"
when cmpxchg fails, enabling further code simplifications, e.g.
an extra memory read can be avoided in the loop.

No functional change intended.

Cc: Jens Axboe <axboe@kernel.dk>
Signed-off-by: Uros Bizjak <ubizjak@gmail.com>
Link: https://lore.kernel.org/r/20220908151200.9993-1-ubizjak@gmail.com
Signed-off-by: Jens Axboe <axboe@kernel.dk>
---
 lib/sbitmap.c | 10 +++++-----
 1 file changed, 5 insertions(+), 5 deletions(-)

diff --git a/lib/sbitmap.c b/lib/sbitmap.c
index 47cd8fb89..cbfd2e677 100644
--- a/lib/sbitmap.c
+++ b/lib/sbitmap.c
@@ -533,16 +533,16 @@ unsigned long __sbitmap_queue_get_batch(struct sbitmap_queue *sbq, int nr_tags,
 		nr = find_first_zero_bit(&map->word, map_depth);
 		if (nr + nr_tags <= map_depth) {
 			atomic_long_t *ptr = (atomic_long_t *) &map->word;
-			unsigned long val, ret;
+			unsigned long val;
 
 			get_mask = ((1UL << nr_tags) - 1) << nr;
+			val = READ_ONCE(map->word);
 			do {
-				val = READ_ONCE(map->word);
 				if ((val & ~get_mask) != val)
 					goto next;
-				ret = atomic_long_cmpxchg(ptr, val, get_mask | val);
-			} while (ret != val);
-			get_mask = (get_mask & ~ret) >> nr;
+			} while (!atomic_long_try_cmpxchg(ptr, &val,
+							  get_mask | val));
+			get_mask = (get_mask & ~val) >> nr;
 			if (get_mask) {
 				*offset = nr + (index << sb->shift);
 				update_alloc_hint_after_get(sb, depth, hint,
-- 
2.37.3.485.gbe1a02a17e


From 2b5a6eb06ee915a03f3bef218e1bb822ab632222 Mon Sep 17 00:00:00 2001
From: Keith Busch <kbusch@kernel.org>
Date: Fri, 9 Sep 2022 11:40:22 -0700
Subject: [PATCH 17/41] sbitmap: fix batched wait_cnt accounting

Batched completions can clear multiple bits, but we're only decrementing
the wait_cnt by one each time. This can cause waiters to never be woken,
stalling IO. Use the batched count instead.

Link: https://bugzilla.kernel.org/show_bug.cgi?id=215679
Signed-off-by: Keith Busch <kbusch@kernel.org>
---
 block/blk-mq-tag.c      |  2 +-
 include/linux/sbitmap.h |  3 ++-
 lib/sbitmap.c           | 37 +++++++++++++++++++++++--------------
 3 files changed, 26 insertions(+), 16 deletions(-)

diff --git a/block/blk-mq-tag.c b/block/blk-mq-tag.c
index 2dcd738c6..7aea93047 100644
--- a/block/blk-mq-tag.c
+++ b/block/blk-mq-tag.c
@@ -200,7 +200,7 @@ unsigned int blk_mq_get_tag(struct blk_mq_alloc_data *data)
 		 * other allocations on previous queue won't be starved.
 		 */
 		if (bt != bt_prev)
-			sbitmap_queue_wake_up(bt_prev);
+			sbitmap_queue_wake_up(bt_prev, 1);
 
 		ws = bt_wait_ptr(bt, data->hctx);
 	} while (1);
diff --git a/include/linux/sbitmap.h b/include/linux/sbitmap.h
index 8f5a86e21..4d2d5205a 100644
--- a/include/linux/sbitmap.h
+++ b/include/linux/sbitmap.h
@@ -575,8 +575,9 @@ void sbitmap_queue_wake_all(struct sbitmap_queue *sbq);
  * sbitmap_queue_wake_up() - Wake up some of waiters in one waitqueue
  * on a &struct sbitmap_queue.
  * @sbq: Bitmap queue to wake up.
+ * @nr: Number of bits cleared.
  */
-void sbitmap_queue_wake_up(struct sbitmap_queue *sbq);
+void sbitmap_queue_wake_up(struct sbitmap_queue *sbq, int nr);
 
 /**
  * sbitmap_queue_show() - Dump &struct sbitmap_queue information to a &struct
diff --git a/lib/sbitmap.c b/lib/sbitmap.c
index cbfd2e677..624fa7f11 100644
--- a/lib/sbitmap.c
+++ b/lib/sbitmap.c
@@ -599,24 +599,31 @@ static struct sbq_wait_state *sbq_wake_ptr(struct sbitmap_queue *sbq)
 	return NULL;
 }
 
-static bool __sbq_wake_up(struct sbitmap_queue *sbq)
+static bool __sbq_wake_up(struct sbitmap_queue *sbq, int *nr)
 {
 	struct sbq_wait_state *ws;
 	unsigned int wake_batch;
-	int wait_cnt;
+	int wait_cnt, cur, sub;
 	bool ret;
 
+	if (*nr <= 0)
+		return false;
+
 	ws = sbq_wake_ptr(sbq);
 	if (!ws)
 		return false;
 
-	wait_cnt = atomic_dec_return(&ws->wait_cnt);
-	/*
-	 * For concurrent callers of this, callers should call this function
-	 * again to wakeup a new batch on a different 'ws'.
-	 */
-	if (wait_cnt < 0)
-		return true;
+	cur = atomic_read(&ws->wait_cnt);
+	do {
+		/*
+		 * For concurrent callers of this, callers should call this
+		 * function again to wakeup a new batch on a different 'ws'.
+		 */
+		if (cur == 0)
+			return true;
+		sub = min(*nr, cur);
+		wait_cnt = cur - sub;
+	} while (!atomic_try_cmpxchg(&ws->wait_cnt, &cur, wait_cnt));
 
 	/*
 	 * If we decremented queue without waiters, retry to avoid lost
@@ -625,6 +632,8 @@ static bool __sbq_wake_up(struct sbitmap_queue *sbq)
 	if (wait_cnt > 0)
 		return !waitqueue_active(&ws->wait);
 
+	*nr -= sub;
+
 	/*
 	 * When wait_cnt == 0, we have to be particularly careful as we are
 	 * responsible to reset wait_cnt regardless whether we've actually
@@ -660,12 +669,12 @@ static bool __sbq_wake_up(struct sbitmap_queue *sbq)
 	sbq_index_atomic_inc(&sbq->wake_index);
 	atomic_set(&ws->wait_cnt, wake_batch);
 
-	return ret;
+	return ret || *nr;
 }
 
-void sbitmap_queue_wake_up(struct sbitmap_queue *sbq)
+void sbitmap_queue_wake_up(struct sbitmap_queue *sbq, int nr)
 {
-	while (__sbq_wake_up(sbq))
+	while (__sbq_wake_up(sbq, &nr))
 		;
 }
 EXPORT_SYMBOL_GPL(sbitmap_queue_wake_up);
@@ -705,7 +714,7 @@ void sbitmap_queue_clear_batch(struct sbitmap_queue *sbq, int offset,
 		atomic_long_andnot(mask, (atomic_long_t *) addr);
 
 	smp_mb__after_atomic();
-	sbitmap_queue_wake_up(sbq);
+	sbitmap_queue_wake_up(sbq, nr_tags);
 	sbitmap_update_cpu_hint(&sbq->sb, raw_smp_processor_id(),
 					tags[nr_tags - 1] - offset);
 }
@@ -733,7 +742,7 @@ void sbitmap_queue_clear(struct sbitmap_queue *sbq, unsigned int nr,
 	 * waiter. See the comment on waitqueue_active().
 	 */
 	smp_mb__after_atomic();
-	sbitmap_queue_wake_up(sbq);
+	sbitmap_queue_wake_up(sbq, 1);
 	sbitmap_update_cpu_hint(&sbq->sb, cpu, nr);
 }
 EXPORT_SYMBOL_GPL(sbitmap_queue_clear);
-- 
2.37.3.485.gbe1a02a17e


From 65993125cf832db4be5a14bd08141474cd0a30e8 Mon Sep 17 00:00:00 2001
From: Yu Kuai <yukuai3@huawei.com>
Date: Mon, 19 Sep 2022 15:09:14 +0800
Subject: [PATCH 18/41] wbt: don't show valid wbt_lat_usec in sysfs while wbt
 is disabled
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit

Currently, if wbt is initialized and then disabled by
wbt_disable_default(), sysfs will still show valid wbt_lat_usec, which
will confuse users that wbt is still enabled.

This patch shows wbt_lat_usec as zero and forbid to set it while wbt
is disabled.

Signed-off-by: Yu Kuai <yukuai3@huawei.com>
Reported-and-tested-by: Holger Hoffstätte <holger@applied-asynchrony.com>
---
 block/blk-sysfs.c | 9 ++++++++-
 block/blk-wbt.c   | 7 +++++++
 block/blk-wbt.h   | 5 +++++
 3 files changed, 20 insertions(+), 1 deletion(-)

diff --git a/block/blk-sysfs.c b/block/blk-sysfs.c
index 9b905e944..51572c6a1 100644
--- a/block/blk-sysfs.c
+++ b/block/blk-sysfs.c
@@ -462,10 +462,14 @@ static ssize_t queue_io_timeout_store(struct request_queue *q, const char *page,
 
 static ssize_t queue_wb_lat_show(struct request_queue *q, char *page)
 {
+	u64 lat;
+
 	if (!wbt_rq_qos(q))
 		return -EINVAL;
 
-	return sprintf(page, "%llu\n", div_u64(wbt_get_min_lat(q), 1000));
+	lat = wbt_disabled(q) ? 0 : div_u64(wbt_get_min_lat(q), 1000);
+
+	return sprintf(page, "%llu\n", lat);
 }
 
 static ssize_t queue_wb_lat_store(struct request_queue *q, const char *page,
@@ -488,6 +492,9 @@ static ssize_t queue_wb_lat_store(struct request_queue *q, const char *page,
 			return ret;
 	}
 
+	if (wbt_disabled(q))
+		return -EINVAL;
+
 	if (val == -1)
 		val = wbt_default_latency_nsec(q);
 	else if (val >= 0)
diff --git a/block/blk-wbt.c b/block/blk-wbt.c
index ae6ea0b54..4c9b3b7af 100644
--- a/block/blk-wbt.c
+++ b/block/blk-wbt.c
@@ -422,6 +422,13 @@ static void wbt_update_limits(struct rq_wb *rwb)
 	rwb_wake_all(rwb);
 }
 
+bool wbt_disabled(struct request_queue *q)
+{
+	struct rq_qos *rqos = wbt_rq_qos(q);
+
+	return !rqos || RQWB(rqos)->enable_state == WBT_STATE_OFF_DEFAULT;
+}
+
 u64 wbt_get_min_lat(struct request_queue *q)
 {
 	struct rq_qos *rqos = wbt_rq_qos(q);
diff --git a/block/blk-wbt.h b/block/blk-wbt.h
index 7e44eccc6..e42465ddc 100644
--- a/block/blk-wbt.h
+++ b/block/blk-wbt.h
@@ -94,6 +94,7 @@ void wbt_enable_default(struct request_queue *);
 
 u64 wbt_get_min_lat(struct request_queue *q);
 void wbt_set_min_lat(struct request_queue *q, u64 val);
+bool wbt_disabled(struct request_queue *);
 
 void wbt_set_write_cache(struct request_queue *, bool);
 
@@ -125,6 +126,10 @@ static inline u64 wbt_default_latency_nsec(struct request_queue *q)
 {
 	return 0;
 }
+static inline bool wbt_disabled(struct request_queue *q)
+{
+	return true;
+}
 
 #endif /* CONFIG_BLK_WBT */
 
-- 
2.37.3.485.gbe1a02a17e


From 7baf928311b95ad8cb63c9ce63e45744b3a7ff68 Mon Sep 17 00:00:00 2001
From: Yu Kuai <yukuai3@huawei.com>
Date: Mon, 19 Sep 2022 15:09:15 +0800
Subject: [PATCH 19/41] block: add a helper to check elevator name

The helper will be used in later patch to make sure wbt is not enabled
if default io scheduler is bfq.

Signed-off-by: Yu Kuai <yukuai3@huawei.com>
---
 block/elevator.h | 5 +++++
 1 file changed, 5 insertions(+)

diff --git a/block/elevator.h b/block/elevator.h
index 16cd8bded..3ee0c727d 100644
--- a/block/elevator.h
+++ b/block/elevator.h
@@ -104,6 +104,11 @@ struct elevator_queue
 	DECLARE_HASHTABLE(hash, ELV_HASH_BITS);
 };
 
+static inline bool check_elevator_name(struct elevator_queue *elevator,
+				       const char *name)
+{
+	return elevator && !strcmp(elevator->type->elevator_name, name);
+}
 /*
  * block elevator interface
  */
-- 
2.37.3.485.gbe1a02a17e


From 52f7545b235fa783d78e868c0f2538972bc2e233 Mon Sep 17 00:00:00 2001
From: Yu Kuai <yukuai3@huawei.com>
Date: Mon, 19 Sep 2022 15:09:16 +0800
Subject: [PATCH 20/41] blk-wbt: don't enable throttling if default elevator is
 bfq

Commit b5dc5d4d1f4f ("block,bfq: Disable writeback throttling") tries to
disable wbt for bfq, it's done by calling wbt_disable_default() in
bfq_init_queue(). However, wbt is still enabled if default elevator is
bfq:

device_add_disk
 elevator_init_mq
  bfq_init_queue
   wbt_disable_default -> done nothing

 blk_register_queue
  wbt_enable_default -> wbt is enabled

Fix the problem by checking elevator name if wbt_enable_default() is
called from blk_register_queue().

Signed-off-by: Yu Kuai <yukuai3@huawei.com>
---
 block/bfq-iosched.c | 2 +-
 block/blk-sysfs.c   | 2 +-
 block/blk-wbt.c     | 6 +++++-
 block/blk-wbt.h     | 5 +++--
 4 files changed, 10 insertions(+), 5 deletions(-)

diff --git a/block/bfq-iosched.c b/block/bfq-iosched.c
index e6d7e6b01..7e1443853 100644
--- a/block/bfq-iosched.c
+++ b/block/bfq-iosched.c
@@ -7047,7 +7047,7 @@ static void bfq_exit_queue(struct elevator_queue *e)
 #endif
 
 	blk_stat_disable_accounting(bfqd->queue);
-	wbt_enable_default(bfqd->queue);
+	wbt_enable_default(bfqd->queue, false);
 
 	kfree(bfqd);
 }
diff --git a/block/blk-sysfs.c b/block/blk-sysfs.c
index 51572c6a1..9180e75fb 100644
--- a/block/blk-sysfs.c
+++ b/block/blk-sysfs.c
@@ -861,7 +861,7 @@ int blk_register_queue(struct gendisk *disk)
 		goto put_dev;
 
 	blk_queue_flag_set(QUEUE_FLAG_REGISTERED, q);
-	wbt_enable_default(q);
+	wbt_enable_default(q, true);
 	blk_throtl_register_queue(q);
 
 	/* Now everything is ready and send out KOBJ_ADD uevent */
diff --git a/block/blk-wbt.c b/block/blk-wbt.c
index 4c9b3b7af..5e3c7b0b0 100644
--- a/block/blk-wbt.c
+++ b/block/blk-wbt.c
@@ -27,6 +27,7 @@
 
 #include "blk-wbt.h"
 #include "blk-rq-qos.h"
+#include "elevator.h"
 
 #define CREATE_TRACE_POINTS
 #include <trace/events/wbt.h>
@@ -643,10 +644,13 @@ void wbt_set_write_cache(struct request_queue *q, bool write_cache_on)
 /*
  * Enable wbt if defaults are configured that way
  */
-void wbt_enable_default(struct request_queue *q)
+void wbt_enable_default(struct request_queue *q, bool check_elevator)
 {
 	struct rq_qos *rqos = wbt_rq_qos(q);
 
+	if (check_elevator && check_elevator_name(q->elevator, "bfq"))
+		return;
+
 	/* Throttling already enabled? */
 	if (rqos) {
 		if (RQWB(rqos)->enable_state == WBT_STATE_OFF_DEFAULT)
diff --git a/block/blk-wbt.h b/block/blk-wbt.h
index e42465ddc..eb028feba 100644
--- a/block/blk-wbt.h
+++ b/block/blk-wbt.h
@@ -90,7 +90,7 @@ static inline unsigned int wbt_inflight(struct rq_wb *rwb)
 
 int wbt_init(struct request_queue *);
 void wbt_disable_default(struct request_queue *);
-void wbt_enable_default(struct request_queue *);
+void wbt_enable_default(struct request_queue *, bool);
 
 u64 wbt_get_min_lat(struct request_queue *q);
 void wbt_set_min_lat(struct request_queue *q, u64 val);
@@ -109,7 +109,8 @@ static inline int wbt_init(struct request_queue *q)
 static inline void wbt_disable_default(struct request_queue *q)
 {
 }
-static inline void wbt_enable_default(struct request_queue *q)
+static inline void wbt_enable_default(struct request_queue *q,
+				      bool check_elevator)
 {
 }
 static inline void wbt_set_write_cache(struct request_queue *q, bool wc)
-- 
2.37.3.485.gbe1a02a17e


From 808de12ca1bafa6b8889ccca91df9ae81ebfd3ce Mon Sep 17 00:00:00 2001
From: Hugh Dickins <hughd@google.com>
Date: Sun, 18 Sep 2022 14:10:51 -0700
Subject: [PATCH 21/41] sbitmap: fix lockup while swapping

Commit 4acb83417cad ("sbitmap: fix batched wait_cnt accounting")
is a big improvement: without it, I had to revert to before commit
040b83fcecfb ("sbitmap: fix possible io hung due to lost wakeup")
to avoid the high system time and freezes which that had introduced.

Now okay on the NVME laptop, but 4acb83417cad is a disaster for heavy
swapping (kernel builds in low memory) on another: soon locking up in
sbitmap_queue_wake_up() (into which __sbq_wake_up() is inlined), cycling
around with waitqueue_active() but wait_cnt 0 .  Here is a backtrace,
showing the common pattern of outer sbitmap_queue_wake_up() interrupted
before setting wait_cnt 0 back to wake_batch (in some cases other CPUs
are idle, in other cases they're spinning for a lock in dd_bio_merge()):

sbitmap_queue_wake_up < sbitmap_queue_clear < blk_mq_put_tag <
__blk_mq_free_request < blk_mq_free_request < __blk_mq_end_request <
scsi_end_request < scsi_io_completion < scsi_finish_command <
scsi_complete < blk_complete_reqs < blk_done_softirq < __do_softirq <
__irq_exit_rcu < irq_exit_rcu < common_interrupt < asm_common_interrupt <
_raw_spin_unlock_irqrestore < __wake_up_common_lock < __wake_up <
sbitmap_queue_wake_up < sbitmap_queue_clear < blk_mq_put_tag <
__blk_mq_free_request < blk_mq_free_request < dd_bio_merge <
blk_mq_sched_bio_merge < blk_mq_attempt_bio_merge < blk_mq_submit_bio <
__submit_bio < submit_bio_noacct_nocheck < submit_bio_noacct <
submit_bio < __swap_writepage < swap_writepage < pageout <
shrink_folio_list < evict_folios < lru_gen_shrink_lruvec <
shrink_lruvec < shrink_node < do_try_to_free_pages < try_to_free_pages <
__alloc_pages_slowpath < __alloc_pages < folio_alloc < vma_alloc_folio <
do_anonymous_page < __handle_mm_fault < handle_mm_fault <
do_user_addr_fault < exc_page_fault < asm_exc_page_fault

I have almost no grasp of all the possible sbitmap races, and their
consequences: but using the same !waitqueue_active() check as used
elsewhere, fixes the lockup and shows no adverse consequence for me.

Fixes: 4acb83417cad ("sbitmap: fix batched wait_cnt accounting")
Signed-off-by: Hugh Dickins <hughd@google.com>
---
 lib/sbitmap.c | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/lib/sbitmap.c b/lib/sbitmap.c
index 624fa7f11..58f6c000b 100644
--- a/lib/sbitmap.c
+++ b/lib/sbitmap.c
@@ -620,7 +620,7 @@ static bool __sbq_wake_up(struct sbitmap_queue *sbq, int *nr)
 		 * function again to wakeup a new batch on a different 'ws'.
 		 */
 		if (cur == 0)
-			return true;
+			return !waitqueue_active(&ws->wait);
 		sub = min(*nr, cur);
 		wait_cnt = cur - sub;
 	} while (!atomic_try_cmpxchg(&ws->wait_cnt, &cur, wait_cnt));
-- 
2.37.3.485.gbe1a02a17e


From d8778377efdcd131eaacefc5ba66af8346e672c8 Mon Sep 17 00:00:00 2001
From: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date: Tue, 20 Sep 2022 19:06:33 +0200
Subject: [PATCH 22/41] lib/vdso: use "grep -E" instead of "egrep"

The latest version of grep claims the egrep is now obsolete so the build
now contains warnings that look like:
	egrep: warning: egrep is obsolescent; using grep -E
fix this up by moving the vdso Makefile to use "grep -E" instead.

Cc: Andy Lutomirski <luto@kernel.org>
Cc: Thomas Gleixner <tglx@linutronix.de>
Cc: Vincenzo Frascino <vincenzo.frascino@arm.com>
Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
---
 lib/vdso/Makefile | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/lib/vdso/Makefile b/lib/vdso/Makefile
index c415a685d..e814061d6 100644
--- a/lib/vdso/Makefile
+++ b/lib/vdso/Makefile
@@ -17,6 +17,6 @@ $(error ARCH_REL_TYPE_ABS is not set)
 endif
 
 quiet_cmd_vdso_check = VDSOCHK $@
-      cmd_vdso_check = if $(OBJDUMP) -R $@ | egrep -h "$(ARCH_REL_TYPE_ABS)"; \
+      cmd_vdso_check = if $(OBJDUMP) -R $@ | grep -E -h "$(ARCH_REL_TYPE_ABS)"; \
 		       then (echo >&2 "$@: dynamic relocations are not supported"; \
 			     rm -f $@; /bin/false); fi
-- 
2.37.3.485.gbe1a02a17e


From 97891eedb82908f8ac21453144672a2babc004bb Mon Sep 17 00:00:00 2001
From: Piotr Gorski <lucjan.lucjanov@gmail.com>
Date: Fri, 23 Sep 2022 20:24:35 +0200
Subject: [PATCH 23/41] Revert "blk-wbt: don't enable throttling if default
 elevator is bfq"

This reverts commit 4c1c37e236d0d9c1323415ce381b535102dbb450.

Signed-off-by: Piotr Gorski <lucjan.lucjanov@gmail.com>
---
 block/bfq-iosched.c | 2 +-
 block/blk-sysfs.c   | 2 +-
 block/blk-wbt.c     | 6 +-----
 block/blk-wbt.h     | 5 ++---
 4 files changed, 5 insertions(+), 10 deletions(-)

diff --git a/block/bfq-iosched.c b/block/bfq-iosched.c
index 7e1443853..e6d7e6b01 100644
--- a/block/bfq-iosched.c
+++ b/block/bfq-iosched.c
@@ -7047,7 +7047,7 @@ static void bfq_exit_queue(struct elevator_queue *e)
 #endif
 
 	blk_stat_disable_accounting(bfqd->queue);
-	wbt_enable_default(bfqd->queue, false);
+	wbt_enable_default(bfqd->queue);
 
 	kfree(bfqd);
 }
diff --git a/block/blk-sysfs.c b/block/blk-sysfs.c
index 9180e75fb..51572c6a1 100644
--- a/block/blk-sysfs.c
+++ b/block/blk-sysfs.c
@@ -861,7 +861,7 @@ int blk_register_queue(struct gendisk *disk)
 		goto put_dev;
 
 	blk_queue_flag_set(QUEUE_FLAG_REGISTERED, q);
-	wbt_enable_default(q, true);
+	wbt_enable_default(q);
 	blk_throtl_register_queue(q);
 
 	/* Now everything is ready and send out KOBJ_ADD uevent */
diff --git a/block/blk-wbt.c b/block/blk-wbt.c
index 5e3c7b0b0..4c9b3b7af 100644
--- a/block/blk-wbt.c
+++ b/block/blk-wbt.c
@@ -27,7 +27,6 @@
 
 #include "blk-wbt.h"
 #include "blk-rq-qos.h"
-#include "elevator.h"
 
 #define CREATE_TRACE_POINTS
 #include <trace/events/wbt.h>
@@ -644,13 +643,10 @@ void wbt_set_write_cache(struct request_queue *q, bool write_cache_on)
 /*
  * Enable wbt if defaults are configured that way
  */
-void wbt_enable_default(struct request_queue *q, bool check_elevator)
+void wbt_enable_default(struct request_queue *q)
 {
 	struct rq_qos *rqos = wbt_rq_qos(q);
 
-	if (check_elevator && check_elevator_name(q->elevator, "bfq"))
-		return;
-
 	/* Throttling already enabled? */
 	if (rqos) {
 		if (RQWB(rqos)->enable_state == WBT_STATE_OFF_DEFAULT)
diff --git a/block/blk-wbt.h b/block/blk-wbt.h
index eb028feba..e42465ddc 100644
--- a/block/blk-wbt.h
+++ b/block/blk-wbt.h
@@ -90,7 +90,7 @@ static inline unsigned int wbt_inflight(struct rq_wb *rwb)
 
 int wbt_init(struct request_queue *);
 void wbt_disable_default(struct request_queue *);
-void wbt_enable_default(struct request_queue *, bool);
+void wbt_enable_default(struct request_queue *);
 
 u64 wbt_get_min_lat(struct request_queue *q);
 void wbt_set_min_lat(struct request_queue *q, u64 val);
@@ -109,8 +109,7 @@ static inline int wbt_init(struct request_queue *q)
 static inline void wbt_disable_default(struct request_queue *q)
 {
 }
-static inline void wbt_enable_default(struct request_queue *q,
-				      bool check_elevator)
+static inline void wbt_enable_default(struct request_queue *q)
 {
 }
 static inline void wbt_set_write_cache(struct request_queue *q, bool wc)
-- 
2.37.3.485.gbe1a02a17e


From a74e397250e4de21f102d37aed91654ce0322927 Mon Sep 17 00:00:00 2001
From: Piotr Gorski <lucjan.lucjanov@gmail.com>
Date: Fri, 23 Sep 2022 20:24:36 +0200
Subject: [PATCH 24/41] Revert "block: add a helper to check elevator name"

This reverts commit f795cf092492728d0fc377aff10c362a78ece4cc.

Signed-off-by: Piotr Gorski <lucjan.lucjanov@gmail.com>
---
 block/elevator.h | 5 -----
 1 file changed, 5 deletions(-)

diff --git a/block/elevator.h b/block/elevator.h
index 3ee0c727d..16cd8bded 100644
--- a/block/elevator.h
+++ b/block/elevator.h
@@ -104,11 +104,6 @@ struct elevator_queue
 	DECLARE_HASHTABLE(hash, ELV_HASH_BITS);
 };
 
-static inline bool check_elevator_name(struct elevator_queue *elevator,
-				       const char *name)
-{
-	return elevator && !strcmp(elevator->type->elevator_name, name);
-}
 /*
  * block elevator interface
  */
-- 
2.37.3.485.gbe1a02a17e


From 376a4b9768cac1efc19d15de7c8c0ee319043d55 Mon Sep 17 00:00:00 2001
From: Piotr Gorski <lucjan.lucjanov@gmail.com>
Date: Fri, 23 Sep 2022 20:24:37 +0200
Subject: [PATCH 25/41] Revert "wbt: don't show valid wbt_lat_usec in sysfs
 while wbt is disabled"

This reverts commit 979c7c1dba286c62b16753b9a63299c5ab574764.

Signed-off-by: Piotr Gorski <lucjan.lucjanov@gmail.com>
---
 block/blk-sysfs.c | 9 +--------
 block/blk-wbt.c   | 7 -------
 block/blk-wbt.h   | 5 -----
 3 files changed, 1 insertion(+), 20 deletions(-)

diff --git a/block/blk-sysfs.c b/block/blk-sysfs.c
index 51572c6a1..9b905e944 100644
--- a/block/blk-sysfs.c
+++ b/block/blk-sysfs.c
@@ -462,14 +462,10 @@ static ssize_t queue_io_timeout_store(struct request_queue *q, const char *page,
 
 static ssize_t queue_wb_lat_show(struct request_queue *q, char *page)
 {
-	u64 lat;
-
 	if (!wbt_rq_qos(q))
 		return -EINVAL;
 
-	lat = wbt_disabled(q) ? 0 : div_u64(wbt_get_min_lat(q), 1000);
-
-	return sprintf(page, "%llu\n", lat);
+	return sprintf(page, "%llu\n", div_u64(wbt_get_min_lat(q), 1000));
 }
 
 static ssize_t queue_wb_lat_store(struct request_queue *q, const char *page,
@@ -492,9 +488,6 @@ static ssize_t queue_wb_lat_store(struct request_queue *q, const char *page,
 			return ret;
 	}
 
-	if (wbt_disabled(q))
-		return -EINVAL;
-
 	if (val == -1)
 		val = wbt_default_latency_nsec(q);
 	else if (val >= 0)
diff --git a/block/blk-wbt.c b/block/blk-wbt.c
index 4c9b3b7af..ae6ea0b54 100644
--- a/block/blk-wbt.c
+++ b/block/blk-wbt.c
@@ -422,13 +422,6 @@ static void wbt_update_limits(struct rq_wb *rwb)
 	rwb_wake_all(rwb);
 }
 
-bool wbt_disabled(struct request_queue *q)
-{
-	struct rq_qos *rqos = wbt_rq_qos(q);
-
-	return !rqos || RQWB(rqos)->enable_state == WBT_STATE_OFF_DEFAULT;
-}
-
 u64 wbt_get_min_lat(struct request_queue *q)
 {
 	struct rq_qos *rqos = wbt_rq_qos(q);
diff --git a/block/blk-wbt.h b/block/blk-wbt.h
index e42465ddc..7e44eccc6 100644
--- a/block/blk-wbt.h
+++ b/block/blk-wbt.h
@@ -94,7 +94,6 @@ void wbt_enable_default(struct request_queue *);
 
 u64 wbt_get_min_lat(struct request_queue *q);
 void wbt_set_min_lat(struct request_queue *q, u64 val);
-bool wbt_disabled(struct request_queue *);
 
 void wbt_set_write_cache(struct request_queue *, bool);
 
@@ -126,10 +125,6 @@ static inline u64 wbt_default_latency_nsec(struct request_queue *q)
 {
 	return 0;
 }
-static inline bool wbt_disabled(struct request_queue *q)
-{
-	return true;
-}
 
 #endif /* CONFIG_BLK_WBT */
 
-- 
2.37.3.485.gbe1a02a17e


From 9d741e5d8a0aa5b11fa28201bfb9037d59d072e7 Mon Sep 17 00:00:00 2001
From: Yu Kuai <yukuai3@huawei.com>
Date: Mon, 19 Sep 2022 15:09:14 +0800
Subject: [PATCH 26/41] wbt: don't show valid wbt_lat_usec in sysfs while wbt
 is disabled
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit

Currently, if wbt is initialized and then disabled by
wbt_disable_default(), sysfs will still show valid wbt_lat_usec, which
will confuse users that wbt is still enabled.

This patch shows wbt_lat_usec as zero and forbid to set it while wbt
is disabled.

Signed-off-by: Yu Kuai <yukuai3@huawei.com>
Reported-and-tested-by: Holger Hoffstätte <holger@applied-asynchrony.com>
---
 block/blk-sysfs.c | 9 ++++++++-
 block/blk-wbt.c   | 7 +++++++
 block/blk-wbt.h   | 5 +++++
 3 files changed, 20 insertions(+), 1 deletion(-)

diff --git a/block/blk-sysfs.c b/block/blk-sysfs.c
index 9b905e944..51572c6a1 100644
--- a/block/blk-sysfs.c
+++ b/block/blk-sysfs.c
@@ -462,10 +462,14 @@ static ssize_t queue_io_timeout_store(struct request_queue *q, const char *page,
 
 static ssize_t queue_wb_lat_show(struct request_queue *q, char *page)
 {
+	u64 lat;
+
 	if (!wbt_rq_qos(q))
 		return -EINVAL;
 
-	return sprintf(page, "%llu\n", div_u64(wbt_get_min_lat(q), 1000));
+	lat = wbt_disabled(q) ? 0 : div_u64(wbt_get_min_lat(q), 1000);
+
+	return sprintf(page, "%llu\n", lat);
 }
 
 static ssize_t queue_wb_lat_store(struct request_queue *q, const char *page,
@@ -488,6 +492,9 @@ static ssize_t queue_wb_lat_store(struct request_queue *q, const char *page,
 			return ret;
 	}
 
+	if (wbt_disabled(q))
+		return -EINVAL;
+
 	if (val == -1)
 		val = wbt_default_latency_nsec(q);
 	else if (val >= 0)
diff --git a/block/blk-wbt.c b/block/blk-wbt.c
index ae6ea0b54..4c9b3b7af 100644
--- a/block/blk-wbt.c
+++ b/block/blk-wbt.c
@@ -422,6 +422,13 @@ static void wbt_update_limits(struct rq_wb *rwb)
 	rwb_wake_all(rwb);
 }
 
+bool wbt_disabled(struct request_queue *q)
+{
+	struct rq_qos *rqos = wbt_rq_qos(q);
+
+	return !rqos || RQWB(rqos)->enable_state == WBT_STATE_OFF_DEFAULT;
+}
+
 u64 wbt_get_min_lat(struct request_queue *q)
 {
 	struct rq_qos *rqos = wbt_rq_qos(q);
diff --git a/block/blk-wbt.h b/block/blk-wbt.h
index 7e44eccc6..e42465ddc 100644
--- a/block/blk-wbt.h
+++ b/block/blk-wbt.h
@@ -94,6 +94,7 @@ void wbt_enable_default(struct request_queue *);
 
 u64 wbt_get_min_lat(struct request_queue *q);
 void wbt_set_min_lat(struct request_queue *q, u64 val);
+bool wbt_disabled(struct request_queue *);
 
 void wbt_set_write_cache(struct request_queue *, bool);
 
@@ -125,6 +126,10 @@ static inline u64 wbt_default_latency_nsec(struct request_queue *q)
 {
 	return 0;
 }
+static inline bool wbt_disabled(struct request_queue *q)
+{
+	return true;
+}
 
 #endif /* CONFIG_BLK_WBT */
 
-- 
2.37.3.485.gbe1a02a17e


From 955cf8a9a66f09049e0cd6c0780906ffe69d8af9 Mon Sep 17 00:00:00 2001
From: Yu Kuai <yukuai3@huawei.com>
Date: Mon, 19 Sep 2022 15:09:15 +0800
Subject: [PATCH 27/41] block: add a helper to check elevator name

The helper will be used in later patch to make sure wbt is not enabled
if default io scheduler is bfq.

Signed-off-by: Yu Kuai <yukuai3@huawei.com>
---
 block/elevator.h | 5 +++++
 1 file changed, 5 insertions(+)

diff --git a/block/elevator.h b/block/elevator.h
index 16cd8bded..3ee0c727d 100644
--- a/block/elevator.h
+++ b/block/elevator.h
@@ -104,6 +104,11 @@ struct elevator_queue
 	DECLARE_HASHTABLE(hash, ELV_HASH_BITS);
 };
 
+static inline bool check_elevator_name(struct elevator_queue *elevator,
+				       const char *name)
+{
+	return elevator && !strcmp(elevator->type->elevator_name, name);
+}
 /*
  * block elevator interface
  */
-- 
2.37.3.485.gbe1a02a17e


From 39f43dfb1da10534b33b47879ccb2d0deefbd8f4 Mon Sep 17 00:00:00 2001
From: Yu Kuai <yukuai3@huawei.com>
Date: Mon, 19 Sep 2022 15:09:16 +0800
Subject: [PATCH 28/41] blk-wbt: don't enable throttling if default elevator is
 bfq

Commit b5dc5d4d1f4f ("block,bfq: Disable writeback throttling") tries to
disable wbt for bfq, it's done by calling wbt_disable_default() in
bfq_init_queue(). However, wbt is still enabled if default elevator is
bfq:

device_add_disk
 elevator_init_mq
  bfq_init_queue
   wbt_disable_default -> done nothing

 blk_register_queue
  wbt_enable_default -> wbt is enabled

Fix the problem by checking elevator name if wbt_enable_default() is
called from blk_register_queue().

Signed-off-by: Yu Kuai <yukuai3@huawei.com>
---
 block/bfq-iosched.c | 2 +-
 block/blk-sysfs.c   | 2 +-
 block/blk-wbt.c     | 6 +++++-
 block/blk-wbt.h     | 5 +++--
 4 files changed, 10 insertions(+), 5 deletions(-)

diff --git a/block/bfq-iosched.c b/block/bfq-iosched.c
index e6d7e6b01..7e1443853 100644
--- a/block/bfq-iosched.c
+++ b/block/bfq-iosched.c
@@ -7047,7 +7047,7 @@ static void bfq_exit_queue(struct elevator_queue *e)
 #endif
 
 	blk_stat_disable_accounting(bfqd->queue);
-	wbt_enable_default(bfqd->queue);
+	wbt_enable_default(bfqd->queue, false);
 
 	kfree(bfqd);
 }
diff --git a/block/blk-sysfs.c b/block/blk-sysfs.c
index 51572c6a1..9180e75fb 100644
--- a/block/blk-sysfs.c
+++ b/block/blk-sysfs.c
@@ -861,7 +861,7 @@ int blk_register_queue(struct gendisk *disk)
 		goto put_dev;
 
 	blk_queue_flag_set(QUEUE_FLAG_REGISTERED, q);
-	wbt_enable_default(q);
+	wbt_enable_default(q, true);
 	blk_throtl_register_queue(q);
 
 	/* Now everything is ready and send out KOBJ_ADD uevent */
diff --git a/block/blk-wbt.c b/block/blk-wbt.c
index 4c9b3b7af..5e3c7b0b0 100644
--- a/block/blk-wbt.c
+++ b/block/blk-wbt.c
@@ -27,6 +27,7 @@
 
 #include "blk-wbt.h"
 #include "blk-rq-qos.h"
+#include "elevator.h"
 
 #define CREATE_TRACE_POINTS
 #include <trace/events/wbt.h>
@@ -643,10 +644,13 @@ void wbt_set_write_cache(struct request_queue *q, bool write_cache_on)
 /*
  * Enable wbt if defaults are configured that way
  */
-void wbt_enable_default(struct request_queue *q)
+void wbt_enable_default(struct request_queue *q, bool check_elevator)
 {
 	struct rq_qos *rqos = wbt_rq_qos(q);
 
+	if (check_elevator && check_elevator_name(q->elevator, "bfq"))
+		return;
+
 	/* Throttling already enabled? */
 	if (rqos) {
 		if (RQWB(rqos)->enable_state == WBT_STATE_OFF_DEFAULT)
diff --git a/block/blk-wbt.h b/block/blk-wbt.h
index e42465ddc..eb028feba 100644
--- a/block/blk-wbt.h
+++ b/block/blk-wbt.h
@@ -90,7 +90,7 @@ static inline unsigned int wbt_inflight(struct rq_wb *rwb)
 
 int wbt_init(struct request_queue *);
 void wbt_disable_default(struct request_queue *);
-void wbt_enable_default(struct request_queue *);
+void wbt_enable_default(struct request_queue *, bool);
 
 u64 wbt_get_min_lat(struct request_queue *q);
 void wbt_set_min_lat(struct request_queue *q, u64 val);
@@ -109,7 +109,8 @@ static inline int wbt_init(struct request_queue *q)
 static inline void wbt_disable_default(struct request_queue *q)
 {
 }
-static inline void wbt_enable_default(struct request_queue *q)
+static inline void wbt_enable_default(struct request_queue *q,
+				      bool check_elevator)
 {
 }
 static inline void wbt_set_write_cache(struct request_queue *q, bool wc)
-- 
2.37.3.485.gbe1a02a17e


From d7cac8779131206a53a2e525c505f086fab6dfdd Mon Sep 17 00:00:00 2001
From: Piotr Gorski <lucjan.lucjanov@gmail.com>
Date: Sat, 24 Sep 2022 15:14:23 +0200
Subject: [PATCH 29/41] Revert "blk-wbt: don't enable throttling if default
 elevator is bfq"

This reverts commit 4f83e07e8afa93169c675b8f8613a19759530ed9.

Signed-off-by: Piotr Gorski <lucjan.lucjanov@gmail.com>
---
 block/bfq-iosched.c | 2 +-
 block/blk-sysfs.c   | 2 +-
 block/blk-wbt.c     | 6 +-----
 block/blk-wbt.h     | 5 ++---
 4 files changed, 5 insertions(+), 10 deletions(-)

diff --git a/block/bfq-iosched.c b/block/bfq-iosched.c
index 7e1443853..e6d7e6b01 100644
--- a/block/bfq-iosched.c
+++ b/block/bfq-iosched.c
@@ -7047,7 +7047,7 @@ static void bfq_exit_queue(struct elevator_queue *e)
 #endif
 
 	blk_stat_disable_accounting(bfqd->queue);
-	wbt_enable_default(bfqd->queue, false);
+	wbt_enable_default(bfqd->queue);
 
 	kfree(bfqd);
 }
diff --git a/block/blk-sysfs.c b/block/blk-sysfs.c
index 9180e75fb..51572c6a1 100644
--- a/block/blk-sysfs.c
+++ b/block/blk-sysfs.c
@@ -861,7 +861,7 @@ int blk_register_queue(struct gendisk *disk)
 		goto put_dev;
 
 	blk_queue_flag_set(QUEUE_FLAG_REGISTERED, q);
-	wbt_enable_default(q, true);
+	wbt_enable_default(q);
 	blk_throtl_register_queue(q);
 
 	/* Now everything is ready and send out KOBJ_ADD uevent */
diff --git a/block/blk-wbt.c b/block/blk-wbt.c
index 5e3c7b0b0..4c9b3b7af 100644
--- a/block/blk-wbt.c
+++ b/block/blk-wbt.c
@@ -27,7 +27,6 @@
 
 #include "blk-wbt.h"
 #include "blk-rq-qos.h"
-#include "elevator.h"
 
 #define CREATE_TRACE_POINTS
 #include <trace/events/wbt.h>
@@ -644,13 +643,10 @@ void wbt_set_write_cache(struct request_queue *q, bool write_cache_on)
 /*
  * Enable wbt if defaults are configured that way
  */
-void wbt_enable_default(struct request_queue *q, bool check_elevator)
+void wbt_enable_default(struct request_queue *q)
 {
 	struct rq_qos *rqos = wbt_rq_qos(q);
 
-	if (check_elevator && check_elevator_name(q->elevator, "bfq"))
-		return;
-
 	/* Throttling already enabled? */
 	if (rqos) {
 		if (RQWB(rqos)->enable_state == WBT_STATE_OFF_DEFAULT)
diff --git a/block/blk-wbt.h b/block/blk-wbt.h
index eb028feba..e42465ddc 100644
--- a/block/blk-wbt.h
+++ b/block/blk-wbt.h
@@ -90,7 +90,7 @@ static inline unsigned int wbt_inflight(struct rq_wb *rwb)
 
 int wbt_init(struct request_queue *);
 void wbt_disable_default(struct request_queue *);
-void wbt_enable_default(struct request_queue *, bool);
+void wbt_enable_default(struct request_queue *);
 
 u64 wbt_get_min_lat(struct request_queue *q);
 void wbt_set_min_lat(struct request_queue *q, u64 val);
@@ -109,8 +109,7 @@ static inline int wbt_init(struct request_queue *q)
 static inline void wbt_disable_default(struct request_queue *q)
 {
 }
-static inline void wbt_enable_default(struct request_queue *q,
-				      bool check_elevator)
+static inline void wbt_enable_default(struct request_queue *q)
 {
 }
 static inline void wbt_set_write_cache(struct request_queue *q, bool wc)
-- 
2.37.3.485.gbe1a02a17e


From 39432afe617af44f6f5960b4181cf18e61fe3fae Mon Sep 17 00:00:00 2001
From: Piotr Gorski <lucjan.lucjanov@gmail.com>
Date: Sat, 24 Sep 2022 15:14:25 +0200
Subject: [PATCH 30/41] Revert "block: add a helper to check elevator name"

This reverts commit e0b59e256d3a4528824d18fe46a8eb026633fa0e.

Signed-off-by: Piotr Gorski <lucjan.lucjanov@gmail.com>
---
 block/elevator.h | 5 -----
 1 file changed, 5 deletions(-)

diff --git a/block/elevator.h b/block/elevator.h
index 3ee0c727d..16cd8bded 100644
--- a/block/elevator.h
+++ b/block/elevator.h
@@ -104,11 +104,6 @@ struct elevator_queue
 	DECLARE_HASHTABLE(hash, ELV_HASH_BITS);
 };
 
-static inline bool check_elevator_name(struct elevator_queue *elevator,
-				       const char *name)
-{
-	return elevator && !strcmp(elevator->type->elevator_name, name);
-}
 /*
  * block elevator interface
  */
-- 
2.37.3.485.gbe1a02a17e


From 16ebf450dcd21a5b491141c3d5ab12df5d23cf2c Mon Sep 17 00:00:00 2001
From: Piotr Gorski <lucjan.lucjanov@gmail.com>
Date: Sat, 24 Sep 2022 15:14:26 +0200
Subject: [PATCH 31/41] Revert "wbt: don't show valid wbt_lat_usec in sysfs
 while wbt is disabled"

This reverts commit f588a19894f8d6472cbffb3435094944a5ade9fc.

Signed-off-by: Piotr Gorski <lucjan.lucjanov@gmail.com>
---
 block/blk-sysfs.c | 9 +--------
 block/blk-wbt.c   | 7 -------
 block/blk-wbt.h   | 5 -----
 3 files changed, 1 insertion(+), 20 deletions(-)

diff --git a/block/blk-sysfs.c b/block/blk-sysfs.c
index 51572c6a1..9b905e944 100644
--- a/block/blk-sysfs.c
+++ b/block/blk-sysfs.c
@@ -462,14 +462,10 @@ static ssize_t queue_io_timeout_store(struct request_queue *q, const char *page,
 
 static ssize_t queue_wb_lat_show(struct request_queue *q, char *page)
 {
-	u64 lat;
-
 	if (!wbt_rq_qos(q))
 		return -EINVAL;
 
-	lat = wbt_disabled(q) ? 0 : div_u64(wbt_get_min_lat(q), 1000);
-
-	return sprintf(page, "%llu\n", lat);
+	return sprintf(page, "%llu\n", div_u64(wbt_get_min_lat(q), 1000));
 }
 
 static ssize_t queue_wb_lat_store(struct request_queue *q, const char *page,
@@ -492,9 +488,6 @@ static ssize_t queue_wb_lat_store(struct request_queue *q, const char *page,
 			return ret;
 	}
 
-	if (wbt_disabled(q))
-		return -EINVAL;
-
 	if (val == -1)
 		val = wbt_default_latency_nsec(q);
 	else if (val >= 0)
diff --git a/block/blk-wbt.c b/block/blk-wbt.c
index 4c9b3b7af..ae6ea0b54 100644
--- a/block/blk-wbt.c
+++ b/block/blk-wbt.c
@@ -422,13 +422,6 @@ static void wbt_update_limits(struct rq_wb *rwb)
 	rwb_wake_all(rwb);
 }
 
-bool wbt_disabled(struct request_queue *q)
-{
-	struct rq_qos *rqos = wbt_rq_qos(q);
-
-	return !rqos || RQWB(rqos)->enable_state == WBT_STATE_OFF_DEFAULT;
-}
-
 u64 wbt_get_min_lat(struct request_queue *q)
 {
 	struct rq_qos *rqos = wbt_rq_qos(q);
diff --git a/block/blk-wbt.h b/block/blk-wbt.h
index e42465ddc..7e44eccc6 100644
--- a/block/blk-wbt.h
+++ b/block/blk-wbt.h
@@ -94,7 +94,6 @@ void wbt_enable_default(struct request_queue *);
 
 u64 wbt_get_min_lat(struct request_queue *q);
 void wbt_set_min_lat(struct request_queue *q, u64 val);
-bool wbt_disabled(struct request_queue *);
 
 void wbt_set_write_cache(struct request_queue *, bool);
 
@@ -126,10 +125,6 @@ static inline u64 wbt_default_latency_nsec(struct request_queue *q)
 {
 	return 0;
 }
-static inline bool wbt_disabled(struct request_queue *q)
-{
-	return true;
-}
 
 #endif /* CONFIG_BLK_WBT */
 
-- 
2.37.3.485.gbe1a02a17e


From c3bc1bb9e1a78992c9f2ac3c7d7835c677eb0e98 Mon Sep 17 00:00:00 2001
From: Yu Kuai <yukuai3@huawei.com>
Date: Thu, 22 Sep 2022 19:35:54 +0800
Subject: [PATCH 32/41] wbt: don't show valid wbt_lat_usec in sysfs while wbt
 is disabled
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit

Currently, if wbt is initialized and then disabled by
wbt_disable_default(), sysfs will still show valid wbt_lat_usec, which
will confuse users that wbt is still enabled.

This patch shows wbt_lat_usec as zero and forbid to set it while wbt
is disabled.

Signed-off-by: Yu Kuai <yukuai3@huawei.com>
Reported-and-tested-by: Holger Hoffstätte <holger@applied-asynchrony.com>
---
 block/blk-sysfs.c | 9 ++++++++-
 block/blk-wbt.c   | 7 +++++++
 block/blk-wbt.h   | 5 +++++
 3 files changed, 20 insertions(+), 1 deletion(-)

diff --git a/block/blk-sysfs.c b/block/blk-sysfs.c
index 9b905e944..51572c6a1 100644
--- a/block/blk-sysfs.c
+++ b/block/blk-sysfs.c
@@ -462,10 +462,14 @@ static ssize_t queue_io_timeout_store(struct request_queue *q, const char *page,
 
 static ssize_t queue_wb_lat_show(struct request_queue *q, char *page)
 {
+	u64 lat;
+
 	if (!wbt_rq_qos(q))
 		return -EINVAL;
 
-	return sprintf(page, "%llu\n", div_u64(wbt_get_min_lat(q), 1000));
+	lat = wbt_disabled(q) ? 0 : div_u64(wbt_get_min_lat(q), 1000);
+
+	return sprintf(page, "%llu\n", lat);
 }
 
 static ssize_t queue_wb_lat_store(struct request_queue *q, const char *page,
@@ -488,6 +492,9 @@ static ssize_t queue_wb_lat_store(struct request_queue *q, const char *page,
 			return ret;
 	}
 
+	if (wbt_disabled(q))
+		return -EINVAL;
+
 	if (val == -1)
 		val = wbt_default_latency_nsec(q);
 	else if (val >= 0)
diff --git a/block/blk-wbt.c b/block/blk-wbt.c
index ae6ea0b54..4c9b3b7af 100644
--- a/block/blk-wbt.c
+++ b/block/blk-wbt.c
@@ -422,6 +422,13 @@ static void wbt_update_limits(struct rq_wb *rwb)
 	rwb_wake_all(rwb);
 }
 
+bool wbt_disabled(struct request_queue *q)
+{
+	struct rq_qos *rqos = wbt_rq_qos(q);
+
+	return !rqos || RQWB(rqos)->enable_state == WBT_STATE_OFF_DEFAULT;
+}
+
 u64 wbt_get_min_lat(struct request_queue *q)
 {
 	struct rq_qos *rqos = wbt_rq_qos(q);
diff --git a/block/blk-wbt.h b/block/blk-wbt.h
index 7e44eccc6..e42465ddc 100644
--- a/block/blk-wbt.h
+++ b/block/blk-wbt.h
@@ -94,6 +94,7 @@ void wbt_enable_default(struct request_queue *);
 
 u64 wbt_get_min_lat(struct request_queue *q);
 void wbt_set_min_lat(struct request_queue *q, u64 val);
+bool wbt_disabled(struct request_queue *);
 
 void wbt_set_write_cache(struct request_queue *, bool);
 
@@ -125,6 +126,10 @@ static inline u64 wbt_default_latency_nsec(struct request_queue *q)
 {
 	return 0;
 }
+static inline bool wbt_disabled(struct request_queue *q)
+{
+	return true;
+}
 
 #endif /* CONFIG_BLK_WBT */
 
-- 
2.37.3.485.gbe1a02a17e


From e534beecc83989cd73322bd1d11f4b40daca3832 Mon Sep 17 00:00:00 2001
From: Yu Kuai <yukuai3@huawei.com>
Date: Thu, 22 Sep 2022 19:35:55 +0800
Subject: [PATCH 33/41] elevator: add new field flags in struct elevator_queue

There are only one flag to indicate that elevator is registered currently,
prepare to add a flag to disable wbt if default elevator is bfq.

Signed-off-by: Yu Kuai <yukuai3@huawei.com>
---
 block/elevator.c | 6 ++----
 block/elevator.h | 4 +++-
 2 files changed, 5 insertions(+), 5 deletions(-)

diff --git a/block/elevator.c b/block/elevator.c
index c31976589..7cb61820c 100644
--- a/block/elevator.c
+++ b/block/elevator.c
@@ -512,7 +512,7 @@ int elv_register_queue(struct request_queue *q, bool uevent)
 		if (uevent)
 			kobject_uevent(&e->kobj, KOBJ_ADD);
 
-		e->registered = 1;
+		set_bit(ELEVATOR_FLAG_REGISTERED, &e->flags);
 	}
 	return error;
 }
@@ -523,13 +523,11 @@ void elv_unregister_queue(struct request_queue *q)
 
 	lockdep_assert_held(&q->sysfs_lock);
 
-	if (e && e->registered) {
+	if (e && test_and_clear_bit(ELEVATOR_FLAG_REGISTERED, &e->flags)) {
 		struct elevator_queue *e = q->elevator;
 
 		kobject_uevent(&e->kobj, KOBJ_REMOVE);
 		kobject_del(&e->kobj);
-
-		e->registered = 0;
 	}
 }
 
diff --git a/block/elevator.h b/block/elevator.h
index 16cd8bded..0b8240792 100644
--- a/block/elevator.h
+++ b/block/elevator.h
@@ -100,10 +100,12 @@ struct elevator_queue
 	void *elevator_data;
 	struct kobject kobj;
 	struct mutex sysfs_lock;
-	unsigned int registered:1;
+	unsigned long flags;
 	DECLARE_HASHTABLE(hash, ELV_HASH_BITS);
 };
 
+#define ELEVATOR_FLAG_REGISTERED 0
+
 /*
  * block elevator interface
  */
-- 
2.37.3.485.gbe1a02a17e


From 4146a3e9783fd29078be51ea10f4c73722fd4837 Mon Sep 17 00:00:00 2001
From: Yu Kuai <yukuai3@huawei.com>
Date: Thu, 22 Sep 2022 19:35:56 +0800
Subject: [PATCH 34/41] block, bfq: don't disable wbt if
 CONFIG_BFQ_GROUP_IOSCHED is disabled

wbt and bfq should work just fine if CONFIG_BFQ_GROUP_IOSCHED is disabled.

Signed-off-by: Yu Kuai <yukuai3@huawei.com>
---
 block/bfq-iosched.c | 4 +++-
 1 file changed, 3 insertions(+), 1 deletion(-)

diff --git a/block/bfq-iosched.c b/block/bfq-iosched.c
index e6d7e6b01..442363680 100644
--- a/block/bfq-iosched.c
+++ b/block/bfq-iosched.c
@@ -7039,6 +7039,7 @@ static void bfq_exit_queue(struct elevator_queue *e)
 
 #ifdef CONFIG_BFQ_GROUP_IOSCHED
 	blkcg_deactivate_policy(bfqd->queue, &blkcg_policy_bfq);
+	wbt_enable_default(bfqd->queue);
 #else
 	spin_lock_irq(&bfqd->lock);
 	bfq_put_async_queues(bfqd, bfqd->root_group);
@@ -7047,7 +7048,6 @@ static void bfq_exit_queue(struct elevator_queue *e)
 #endif
 
 	blk_stat_disable_accounting(bfqd->queue);
-	wbt_enable_default(bfqd->queue);
 
 	kfree(bfqd);
 }
@@ -7192,7 +7192,9 @@ static int bfq_init_queue(struct request_queue *q, struct elevator_type *e)
 	/* We dispatch from request queue wide instead of hw queue */
 	blk_queue_flag_set(QUEUE_FLAG_SQ_SCHED, q);
 
+#ifdef CONFIG_BFQ_GROUP_IOSCHED
 	wbt_disable_default(q);
+#endif
 	blk_stat_enable_accounting(q);
 
 	return 0;
-- 
2.37.3.485.gbe1a02a17e


From be33aefe605150be45b532684adae127ab8f8d61 Mon Sep 17 00:00:00 2001
From: Yu Kuai <yukuai3@huawei.com>
Date: Thu, 22 Sep 2022 19:35:57 +0800
Subject: [PATCH 35/41] blk-wbt: don't enable throttling if default elevator is
 bfq

Commit b5dc5d4d1f4f ("block,bfq: Disable writeback throttling") tries to
disable wbt for bfq, it's done by calling wbt_disable_default() in
bfq_init_queue(). However, wbt is still enabled if default elevator is
bfq:

device_add_disk
 elevator_init_mq
  bfq_init_queue
   wbt_disable_default -> done nothing

 blk_register_queue
  wbt_enable_default -> wbt is enabled

Fix the problem by adding a new flag ELEVATOR_FLAG_DISBALE_WBT, bfq
will set the flag in bfq_init_queue, and following wbt_enable_default()
won't enable wbt while the flag is set.

Signed-off-by: Yu Kuai <yukuai3@huawei.com>
---
 block/bfq-iosched.c | 2 ++
 block/blk-wbt.c     | 8 +++++++-
 block/elevator.h    | 3 ++-
 3 files changed, 11 insertions(+), 2 deletions(-)

diff --git a/block/bfq-iosched.c b/block/bfq-iosched.c
index 442363680..d02a6f4ad 100644
--- a/block/bfq-iosched.c
+++ b/block/bfq-iosched.c
@@ -7039,6 +7039,7 @@ static void bfq_exit_queue(struct elevator_queue *e)
 
 #ifdef CONFIG_BFQ_GROUP_IOSCHED
 	blkcg_deactivate_policy(bfqd->queue, &blkcg_policy_bfq);
+	clear_bit(ELEVATOR_FLAG_DISABLE_WBT, &e->flags);
 	wbt_enable_default(bfqd->queue);
 #else
 	spin_lock_irq(&bfqd->lock);
@@ -7193,6 +7194,7 @@ static int bfq_init_queue(struct request_queue *q, struct elevator_type *e)
 	blk_queue_flag_set(QUEUE_FLAG_SQ_SCHED, q);
 
 #ifdef CONFIG_BFQ_GROUP_IOSCHED
+	set_bit(ELEVATOR_FLAG_DISABLE_WBT, &eq->flags);
 	wbt_disable_default(q);
 #endif
 	blk_stat_enable_accounting(q);
diff --git a/block/blk-wbt.c b/block/blk-wbt.c
index 4c9b3b7af..acf56f223 100644
--- a/block/blk-wbt.c
+++ b/block/blk-wbt.c
@@ -27,6 +27,7 @@
 
 #include "blk-wbt.h"
 #include "blk-rq-qos.h"
+#include "elevator.h"
 
 #define CREATE_TRACE_POINTS
 #include <trace/events/wbt.h>
@@ -645,9 +646,14 @@ void wbt_set_write_cache(struct request_queue *q, bool write_cache_on)
  */
 void wbt_enable_default(struct request_queue *q)
 {
-	struct rq_qos *rqos = wbt_rq_qos(q);
+	struct rq_qos *rqos;
+
+	if (q->elevator &&
+	    test_bit(ELEVATOR_FLAG_DISABLE_WBT, &q->elevator->flags))
+		return;
 
 	/* Throttling already enabled? */
+	rqos = wbt_rq_qos(q);
 	if (rqos) {
 		if (RQWB(rqos)->enable_state == WBT_STATE_OFF_DEFAULT)
 			RQWB(rqos)->enable_state = WBT_STATE_ON_DEFAULT;
diff --git a/block/elevator.h b/block/elevator.h
index 0b8240792..57b23dab7 100644
--- a/block/elevator.h
+++ b/block/elevator.h
@@ -104,7 +104,8 @@ struct elevator_queue
 	DECLARE_HASHTABLE(hash, ELV_HASH_BITS);
 };
 
-#define ELEVATOR_FLAG_REGISTERED 0
+#define ELEVATOR_FLAG_REGISTERED	0
+#define ELEVATOR_FLAG_DISABLE_WBT	1
 
 /*
  * block elevator interface
-- 
2.37.3.485.gbe1a02a17e


From 43d55f68606cd74a11e72895cf733f2f6d8e43c9 Mon Sep 17 00:00:00 2001
From: Yu Kuai <yukuai3@huawei.com>
Date: Thu, 22 Sep 2022 19:35:58 +0800
Subject: [PATCH 36/41] elevator: remove redundant code in
 elv_unregister_queue()

"elevator_queue *e" is already declared and initialized in the beginning
of elv_unregister_queue().

Signed-off-by: Yu Kuai <yukuai3@huawei.com>
Reviewed-by: Eric Biggers <ebiggers@google.com>
Reviewed-by: Christoph Hellwig <hch@lst.de>
---
 block/elevator.c | 2 --
 1 file changed, 2 deletions(-)

diff --git a/block/elevator.c b/block/elevator.c
index 7cb61820c..0a72d6fbb 100644
--- a/block/elevator.c
+++ b/block/elevator.c
@@ -524,8 +524,6 @@ void elv_unregister_queue(struct request_queue *q)
 	lockdep_assert_held(&q->sysfs_lock);
 
 	if (e && test_and_clear_bit(ELEVATOR_FLAG_REGISTERED, &e->flags)) {
-		struct elevator_queue *e = q->elevator;
-
 		kobject_uevent(&e->kobj, KOBJ_REMOVE);
 		kobject_del(&e->kobj);
 	}
-- 
2.37.3.485.gbe1a02a17e


From 6f1a3416d4fa4bcf9cec7eee2ef17e67395114d2 Mon Sep 17 00:00:00 2001
From: Dave Hansen <dave.hansen@intel.com>
Date: Thu, 22 Sep 2022 11:47:45 -0700
Subject: [PATCH 37/41] ACPI: processor idle: Practically limit "Dummy wait"
 workaround to old Intel systems

Old, circa 2002 chipsets have a bug: they don't go idle when they are
supposed to.  So, a workaround was added to slow the CPU down and
ensure that the CPU waits a bit for the chipset to actually go idle.
This workaround is ancient and has been in place in some form since
the original kernel ACPI implementation.

But, this workaround is very painful on modern systems.  The "inl()"
can take thousands of cycles (see Link: for some more detailed
numbers and some fun kernel archaeology).

First and foremost, modern systems should not be using this code.
Typical Intel systems have not used it in over a decade because it is
horribly inferior to MWAIT-based idle.

Despite this, people do seem to be tripping over this workaround on
AMD system today.

Limit the "dummy wait" workaround to Intel systems.  Keep Modern AMD
systems from tripping over the workaround.  Remotely modern Intel
systems use intel_idle instead of this code and will, in practice,
remain unaffected by the dummy wait.

Reported-by: K Prateek Nayak <kprateek.nayak@amd.com>
Suggested-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Signed-off-by: Dave Hansen <dave.hansen@linux.intel.com>
Reviewed-by: Mario Limonciello <mario.limonciello@amd.com>
Tested-by: K Prateek Nayak <kprateek.nayak@amd.com>
Link: https://lore.kernel.org/all/20220921063638.2489-1-kprateek.nayak@amd.com/
Link: https://lkml.kernel.org/r/20220922184745.3252932-1-dave.hansen@intel.com
---
 drivers/acpi/processor_idle.c | 23 ++++++++++++++++++++---
 1 file changed, 20 insertions(+), 3 deletions(-)

diff --git a/drivers/acpi/processor_idle.c b/drivers/acpi/processor_idle.c
index 13200969c..5168b6624 100644
--- a/drivers/acpi/processor_idle.c
+++ b/drivers/acpi/processor_idle.c
@@ -530,10 +530,27 @@ static void wait_for_freeze(void)
 	/* No delay is needed if we are in guest */
 	if (boot_cpu_has(X86_FEATURE_HYPERVISOR))
 		return;
+	/*
+	 * Modern (>=Nehalem) Intel systems use ACPI via intel_idle,
+	 * not this code.  Assume that any Intel systems using this
+	 * are ancient and may need the dummy wait.  This also assumes
+	 * that the motivating chipset issue was Intel-only.
+	 */
+	if (boot_cpu_data.x86_vendor != X86_VENDOR_INTEL)
+		return;
 #endif
-	/* Dummy wait op - must do something useless after P_LVL2 read
-	   because chipsets cannot guarantee that STPCLK# signal
-	   gets asserted in time to freeze execution properly. */
+	/*
+	 * Dummy wait op - must do something useless after P_LVL2 read
+	 * because chipsets cannot guarantee that STPCLK# signal gets
+	 * asserted in time to freeze execution properly
+	 *
+	 * This workaround has been in place since the original ACPI
+	 * implementation was merged, circa 2002.
+	 *
+	 * If a profile is pointing to this instruction, please first
+	 * consider moving your system to a more modern idle
+	 * mechanism.
+	 */
 	inl(acpi_gbl_FADT.xpm_timer_block.address);
 }
 
-- 
2.37.3.485.gbe1a02a17e


From 02285ccb1a4d460f3dcc4abf1650113483679748 Mon Sep 17 00:00:00 2001
From: Piotr Gorski <lucjan.lucjanov@gmail.com>
Date: Mon, 26 Sep 2022 20:34:50 +0200
Subject: [PATCH 38/41] Revert "leds: trigger: Add block device LED trigger"

This reverts commit 81db7ffbdd93f9793584737b84e7b9b5826faa9d.

Signed-off-by: Piotr Gorski <lucjan.lucjanov@gmail.com>
---
 drivers/leds/trigger/Kconfig          |    9 -
 drivers/leds/trigger/Makefile         |    1 -
 drivers/leds/trigger/ledtrig-blkdev.c | 1139 -------------------------
 3 files changed, 1149 deletions(-)
 delete mode 100644 drivers/leds/trigger/ledtrig-blkdev.c

diff --git a/drivers/leds/trigger/Kconfig b/drivers/leds/trigger/Kconfig
index bda249068..dc6816d36 100644
--- a/drivers/leds/trigger/Kconfig
+++ b/drivers/leds/trigger/Kconfig
@@ -154,13 +154,4 @@ config LEDS_TRIGGER_TTY
 
 	  When build as a module this driver will be called ledtrig-tty.
 
-config LEDS_TRIGGER_BLKDEV
-	tristate "LED Trigger for block devices"
-	depends on BLOCK
-	help
-	  The blkdev LED trigger allows LEDs to be controlled by block device
-	  activity (reads and writes).
-
-	  See Documentation/leds/ledtrig-blkdev.rst.
-
 endif # LEDS_TRIGGERS
diff --git a/drivers/leds/trigger/Makefile b/drivers/leds/trigger/Makefile
index d53bab5d9..25c4db97c 100644
--- a/drivers/leds/trigger/Makefile
+++ b/drivers/leds/trigger/Makefile
@@ -16,4 +16,3 @@ obj-$(CONFIG_LEDS_TRIGGER_NETDEV)	+= ledtrig-netdev.o
 obj-$(CONFIG_LEDS_TRIGGER_PATTERN)	+= ledtrig-pattern.o
 obj-$(CONFIG_LEDS_TRIGGER_AUDIO)	+= ledtrig-audio.o
 obj-$(CONFIG_LEDS_TRIGGER_TTY)		+= ledtrig-tty.o
-obj-$(CONFIG_LEDS_TRIGGER_BLKDEV)	+= ledtrig-blkdev.o
diff --git a/drivers/leds/trigger/ledtrig-blkdev.c b/drivers/leds/trigger/ledtrig-blkdev.c
deleted file mode 100644
index 999c48a7a..000000000
--- a/drivers/leds/trigger/ledtrig-blkdev.c
+++ /dev/null
@@ -1,1139 +0,0 @@
-// SPDX-License-Identifier: GPL-2.0-only
-
-/*
- *	Block device LED trigger
- *
- *	Copyright 2021-2022 Ian Pilcher <arequipeno@gmail.com>
- */
-
-#include <linux/blkdev.h>
-#include <linux/leds.h>
-#include <linux/module.h>
-#include <linux/part_stat.h>
-#include <linux/xarray.h>
-
-/* Default, minimum & maximum blink duration (milliseconds) */
-#define BLKDEV_TRIG_BLINK_DEF	75
-#define BLKDEV_TRIG_BLINK_MIN	10
-#define BLKDEV_TRIG_BLINK_MAX	86400000  /* 24 hours */
-
-/* Default, minimum & maximum activity check interval (milliseconds) */
-#define BLKDEV_TRIG_CHECK_DEF	100
-#define BLKDEV_TRIG_CHECK_MIN	25
-#define BLKDEV_TRIG_CHECK_MAX	86400000
-
-/*
- * If blkdev_trig_check() can't lock the mutex, how long to wait before trying
- * again (milliseconds)
- */
-#define BLKDEV_TRIG_CHECK_RETRY	5
-
-/* Mode for blkdev_get_by_path() & blkdev_put() */
-#define BLKDEV_TRIG_FMODE	0
-
-/* When unlinking a block device from an LED, is the blkdev being released? */
-enum blkdev_trig_unlink_mode {
-	BLKDEV_TRIG_RELEASING,
-	BLKDEV_TRIG_NOT_RELEASING
-};
-
-/* Every block device linked to at least one LED gets a "BTB" */
-struct blkdev_trig_bdev {
-	unsigned long		last_checked;
-	unsigned long		last_activity[NR_STAT_GROUPS];
-	unsigned long		ios[NR_STAT_GROUPS];
-	unsigned long		index;
-	struct block_device	*bdev;
-	struct xarray		linked_leds;
-};
-
-/* Every LED associated with the blkdev trigger gets one of these */
-struct blkdev_trig_led {
-	unsigned long		last_checked;
-	unsigned long		index;
-	unsigned long		mode;  /* must be ulong for atomic bit ops */
-	struct led_classdev	*led_cdev;
-	unsigned int		blink_msec;
-	unsigned int		check_jiffies;
-	struct xarray		linked_btbs;
-	struct hlist_node	all_leds_node;
-};
-
-/* Forward declarations to make this file compile in a more readable order */
-static void blkdev_trig_check(struct work_struct *work);
-static struct blkdev_trig_bdev *blkdev_trig_get_btb(const char *buf,
-						    size_t size);
-static struct block_device *blkdev_trig_get_bdev(const char *buf, size_t size,
-						 fmode_t mode);
-static int blkdev_trig_link(struct blkdev_trig_led *led,
-			    struct blkdev_trig_bdev *btb);
-static void blkdev_trig_put_btb(struct blkdev_trig_bdev *btb);
-static void blkdev_trig_btb_release(struct device *dev, void *res);
-static void blkdev_trig_unlink(struct blkdev_trig_led *led,
-			       struct blkdev_trig_bdev *btb,
-			       enum blkdev_trig_unlink_mode unlink_mode);
-static void blkdev_trig_update_btb(struct blkdev_trig_bdev *btb,
-				   unsigned long now);
-static bool blkdev_trig_blink(const struct blkdev_trig_led *led,
-			      const struct blkdev_trig_bdev *btb);
-static void blkdev_trig_sched_led(const struct blkdev_trig_led *led);
-
-/* Index for next BTB or LED */
-static unsigned long blkdev_trig_next_index;
-
-/* Protects everything except sysfs attributes */
-static DEFINE_MUTEX(blkdev_trig_mutex);
-
-/* All LEDs associated with the trigger */
-static HLIST_HEAD(blkdev_trig_all_leds);
-
-/* Delayed work to periodically check for activity & blink LEDs */
-static DECLARE_DELAYED_WORK(blkdev_trig_work, blkdev_trig_check);
-
-/* When is the delayed work scheduled to run next (jiffies) */
-static unsigned long blkdev_trig_next_check;
-
-/* Total number of device-to-LED associations (links) */
-static unsigned int blkdev_trig_link_count;
-
-/* Empty attribute list, for next 2 declarations */
-static struct attribute *blkdev_trig_attrs_empty[] = { NULL };
-
-/* linked_leds sysfs directory for block devs linked to 1 or more LEDs */
-static const struct attribute_group blkdev_trig_linked_leds = {
-	.name	= "linked_leds",
-	.attrs	= blkdev_trig_attrs_empty,
-};
-
-/* linked_devices sysfs directory for each LED associated with the trigger */
-static const struct attribute_group blkdev_trig_linked_devs = {
-	.name	= "linked_devices",
-	.attrs	= blkdev_trig_attrs_empty,
-};
-
-/**
- * blkdev_trig_activate() - Called when an LED is associated with the trigger.
- * @led_cdev:	The LED
- *
- * Allocates & initializes the @blkdev_trig_led structure, adds it to the
- * @blkdev_trig_all_leds list, and sets the LED's trigger data.
- *
- * Context:	Process context.  Takes and releases @blkdev_trig_mutex.
- * Return:	``0`` on success, ``-errno`` on error.
- */
-static int blkdev_trig_activate(struct led_classdev *led_cdev)
-{
-	struct blkdev_trig_led *led;
-	int err;
-
-	led = kzalloc(sizeof(*led), GFP_KERNEL);
-	if (led == NULL)
-		return -ENOMEM;
-
-	err = mutex_lock_interruptible(&blkdev_trig_mutex);
-	if (err)
-		goto exit_free;
-
-	if (blkdev_trig_next_index == ULONG_MAX) {
-		err = -EOVERFLOW;
-		goto exit_unlock;
-	}
-
-	led->index = blkdev_trig_next_index++;
-	led->last_checked = jiffies;
-	led->mode = -1;  /* set all bits */
-	led->led_cdev = led_cdev;
-	led->blink_msec = BLKDEV_TRIG_BLINK_DEF;
-	led->check_jiffies = msecs_to_jiffies(BLKDEV_TRIG_CHECK_DEF);
-	xa_init(&led->linked_btbs);
-
-	hlist_add_head(&led->all_leds_node, &blkdev_trig_all_leds);
-	led_set_trigger_data(led_cdev, led);
-
-exit_unlock:
-	mutex_unlock(&blkdev_trig_mutex);
-exit_free:
-	if (err)
-		kfree(led);
-	return err;
-}
-
-/**
- * link_dev_by_path_store() - ``link_dev_by_path`` device attribute store
- *			      function.
- * @dev:	The LED device
- * @attr:	The ``link_dev_by_path`` attribute (@dev_attr_link_dev_by_path)
- * @buf:	The value written to the attribute, which should be the path to
- *		the special file that represents the block device to be linked
- *		to the LED (e.g. /dev/sda)
- * @count:	The number of characters in @buf
- *
- * Calls blkdev_trig_get_btb() to find or create the BTB for the block device,
- * checks that the device isn't already linked to this LED, and calls
- * blkdev_trig_link() to create the link.
- *
- * Context:	Process context.  Takes and releases @blkdev_trig_mutex.
- * Return:	@count on success, ``-errno`` on error.
- */
-static ssize_t link_dev_by_path_store(struct device *dev,
-				      struct device_attribute *attr,
-				      const char *buf, size_t count)
-{
-	struct blkdev_trig_led *led = led_trigger_get_drvdata(dev);
-	struct blkdev_trig_bdev *btb;
-	int err;
-
-	err = mutex_lock_interruptible(&blkdev_trig_mutex);
-	if (err)
-		return err;
-
-	btb = blkdev_trig_get_btb(buf, count);
-	if (IS_ERR(btb)) {
-		err = PTR_ERR(btb);
-		goto exit_unlock;
-	}
-
-	if (xa_load(&btb->linked_leds, led->index) != NULL) {
-		err = -EEXIST;
-		goto exit_put_btb;
-	}
-
-	err = blkdev_trig_link(led, btb);
-
-exit_put_btb:
-	if (err)
-		blkdev_trig_put_btb(btb);
-exit_unlock:
-	mutex_unlock(&blkdev_trig_mutex);
-	return err ? : count;
-}
-
-/**
- * blkdev_trig_get_btb() - Find or create the BTB for a block device.
- * @buf:	The value written to the ``link_dev_by_path`` attribute, which
- *		should be the path to a special file that represents a block
- *		device
- * @count:	The number of characters in @buf
- *
- * Calls blkdev_trig_get_bdev() to get the block device represented by the path
- * in @buf.  If the device already has a BTB (because it is already linked to
- * an LED), simply returns the existing BTB.
- *
- * Otherwise, allocates a new BTB (as a device resource), creates the block
- * device's ``linked_leds`` directory (attribute group), calls
- * blkdev_trig_update_btb() to set the BTB's activity counters, and adds the
- * BTB resource to the block device.
- *
- * Context:	Process context.  Caller must hold @blkdev_trig_mutex.
- * Return:	Pointer to the BTB, error pointer on error.
- */
-static struct blkdev_trig_bdev *blkdev_trig_get_btb(const char *buf,
-						    size_t count)
-{
-	struct block_device *bdev;
-	struct blkdev_trig_bdev *btb;
-	int err;
-
-	bdev = blkdev_trig_get_bdev(buf, count, BLKDEV_TRIG_FMODE);
-	if (IS_ERR(bdev))
-		return ERR_CAST(bdev);
-
-	btb = devres_find(&bdev->bd_device, blkdev_trig_btb_release,
-			  NULL, NULL);
-	if (btb != NULL) {
-		err = 0;
-		goto exit_put_bdev;
-	}
-
-	if (blkdev_trig_next_index == ULONG_MAX) {
-		err = -EOVERFLOW;
-		goto exit_put_bdev;
-	}
-
-	btb = devres_alloc(blkdev_trig_btb_release, sizeof(*btb), GFP_KERNEL);
-	if (btb == NULL) {
-		err = -ENOMEM;
-		goto exit_put_bdev;
-	}
-
-	err = sysfs_create_group(bdev_kobj(bdev), &blkdev_trig_linked_leds);
-	if (err)
-		goto exit_free_btb;
-
-	btb->index = blkdev_trig_next_index++;
-	btb->bdev = bdev;
-	xa_init(&btb->linked_leds);
-	blkdev_trig_update_btb(btb, jiffies);
-
-	devres_add(&bdev->bd_device, btb);
-
-exit_free_btb:
-	if (err)
-		devres_free(btb);
-exit_put_bdev:
-	blkdev_put(bdev, BLKDEV_TRIG_FMODE);
-	return err ? ERR_PTR(err) : btb;
-}
-
-/**
- * blkdev_trig_get_bdev() - Get a block device by path.
- * @buf:	The value written to the ``link_dev_by_path`` or
- *		``unlink_dev_by_path`` attribute, which should be the path to a
- *		special file that represents a block device
- * @count:	The number of characters in @buf (not including its terminating
- *		null)
- *
- * Copies @buf to a writable buffer, trims the trailing newline (if any), and
- * calls blkdev_get_by_path() to resolve the block device.
- *
- * The caller must call blkdev_put() when finished with the device.
- *
- * Context:	Process context.
- * Return:	The block device, or an error pointer.
- */
-static struct block_device *blkdev_trig_get_bdev(const char *buf, size_t count,
-						 fmode_t mode)
-{
-	struct block_device *bdev;
-	char *path;
-
-	path = kmemdup(buf, count + 1, GFP_KERNEL);  /* +1 to include null */
-	if (path == NULL)
-		return ERR_PTR(-ENOMEM);
-
-	if (path[count - 1] == '\n')
-		path[count - 1] = 0;
-
-	bdev = blkdev_get_by_path(path, mode, THIS_MODULE);
-	kfree(path);
-	return bdev;
-}
-
-/**
- * blkdev_trig_update_btb() - Update a BTB's activity counters.
- * @btb:	The BTB
- *
- * Checks each of the BTB's block device's I/O counters.  If the counter has
- * changed since the last check, updates the counter and its timestamp in the
- * BTB.
- *
- * Context:	Process context.  Caller must hold @blkdev_trig_mutex.
- */
-static void blkdev_trig_update_btb(struct blkdev_trig_bdev *btb,
-				   unsigned long now)
-{
-	unsigned long new_ios;
-	enum stat_group i;
-
-	for (i = STAT_READ; i <= STAT_FLUSH; ++i) {
-
-		new_ios = part_stat_read(btb->bdev, ios[i]);
-
-		if (new_ios != btb->ios[i]) {
-			btb->ios[i] = new_ios;
-			btb->last_activity[i] = now;
-		}
-	}
-
-	btb->last_checked = now;
-}
-
-/**
- * blkdev_trig_link() - "Link" a block device to an LED.
- * @led:	The LED
- * @btb:	The block device
- *
- * Called from link_dev_by_path_store() to create the link between an LED and a
- * block device.
- *
- *   * Adds block device symlink to LED's ``linked_devices`` directory.
- *   * Adds LED symlink to block devices's ``linked_leds`` directory.
- *   * Adds the BTB to the LED's @linked_btbs and adds the LED to the BTB's
- *     @linked_leds.
- *   * If this is the first block device linked to this LED, calls
- *     blkdev_trig_new_sched() to (if needed) schedule or reschedule the delayed
- *     work which periodically checks for block device activity and blinks LEDs.
- *
- * Context:	Process context.  Caller must hold @blkdev_trig_mutex.
- * Return:	0 on success, ``-errno`` on error.
- */
-static int blkdev_trig_link(struct blkdev_trig_led *led,
-			    struct blkdev_trig_bdev *btb)
-{
-	bool led_first_link;
-	int err;
-
-	led_first_link = xa_empty(&led->linked_btbs);
-
-	err = xa_insert(&btb->linked_leds, led->index, led, GFP_KERNEL);
-	if (err)
-		return err;
-
-	err = xa_insert(&led->linked_btbs, btb->index, btb, GFP_KERNEL);
-	if (err)
-		goto error_erase_led;
-
-	/* Create /sys/class/block/<bdev>/linked_leds/<led> symlink */
-	err = sysfs_add_link_to_group(bdev_kobj(btb->bdev),
-				      blkdev_trig_linked_leds.name,
-				      &led->led_cdev->dev->kobj,
-				      led->led_cdev->name);
-	if (err)
-		goto error_erase_btb;
-
-	/* Create /sys/class/leds/<led>/linked_devices/<bdev> symlink */
-	err = sysfs_add_link_to_group(&led->led_cdev->dev->kobj,
-				      blkdev_trig_linked_devs.name,
-				      bdev_kobj(btb->bdev),
-				      dev_name(&btb->bdev->bd_device));
-	if (err)
-		goto error_remove_symlink;
-
-	/*
-	 * If this isn't the first block device linked to this LED, then the
-	 * delayed work schedule already reflects this LED.
-	 */
-	if (led_first_link)
-		blkdev_trig_sched_led(led);
-
-	++blkdev_trig_link_count;
-
-	return 0;
-
-error_remove_symlink:
-	sysfs_remove_link_from_group(bdev_kobj(btb->bdev),
-				     blkdev_trig_linked_leds.name,
-				     led->led_cdev->name);
-error_erase_btb:
-	xa_erase(&led->linked_btbs, btb->index);
-error_erase_led:
-	xa_erase(&btb->linked_leds, led->index);
-	return err;
-}
-
-/**
- * blkdev_trig_sched_led() - Set the schedule of the delayed work when a new
- *			     LED is added to the schedule.
- * @led:	The LED
- *
- * Called from blkdev_trig_link() to set or adjust the schedule of the delayed
- * work which periodically checks block devices for activity and blinks LEDs,
- * if necessary.
- *
- *   * If no other links exist, the delayed work is scheduled.
- *   * If the delayed work is already scheduled to run soon enough to
- *     accommodate the newly linked LED's @check_jiffies, no change is made to
- *     the delayed work's schedule.
- *   * If the delayed work is already scheduled, but it isn't scheduled to
- *     run soon enough, the schedule is modified.
- *
- * Context:	Process context.  Caller must hold @blkdev_trig_mutex.
- */
-static void blkdev_trig_sched_led(const struct blkdev_trig_led *led)
-{
-	unsigned long delay = READ_ONCE(led->check_jiffies);
-	unsigned long check_by = jiffies + delay;
-
-	if (blkdev_trig_link_count == 0) {
-		WARN_ON(!schedule_delayed_work(&blkdev_trig_work, delay));
-		blkdev_trig_next_check = check_by;
-		return;
-	}
-
-	if (time_after_eq(check_by, blkdev_trig_next_check))
-		return;
-
-	WARN_ON(!mod_delayed_work(system_wq, &blkdev_trig_work, delay));
-	blkdev_trig_next_check = check_by;
-}
-
-/**
- * unlink_dev_by_path_store() - ``unlink_dev_by_path`` device attribute store
- *				function.
- * @dev:	The LED device
- * @attr:	The ``unlink_dev_by_path`` attribute
- *		(@dev_attr_unlink_dev_by_path)
- * @buf:	The value written to the attribute, which should be the path to
- *		the special file that represents the block device to be unlinked
- *		from the LED (e.g. /dev/sda)
- * @count:	The number of characters in @buf
- *
- * Block device name is written to the attribute to "unlink" the block device
- * from the LED.  I.e. the LED will no longer blink to show activity on that
- * block device.
- *
- * Calls blkdev_trig_get_bdev() to get the block device represented by the path
- * in @buf.  If the device has a BTB, searches the BTB's list of LEDs for a
- * link to this LED and (if found) calls blkdev_trig_unlink() to destroy the
- * link.
- *
- * Context:	Process context.  Takes and releases @blkdev_trig_mutex.
- * Return:	@count on success, ``-errno`` on error.
- */
-static ssize_t unlink_dev_by_path_store(struct device *dev,
-					struct device_attribute *attr,
-					const char *buf, size_t count)
-{
-	struct blkdev_trig_led *led = led_trigger_get_drvdata(dev);
-	struct block_device *bdev;
-	struct blkdev_trig_bdev *btb;
-	int err;
-
-	bdev = blkdev_trig_get_bdev(buf, count, BLKDEV_TRIG_FMODE);
-	if (IS_ERR(bdev))
-		return PTR_ERR(bdev);
-
-	err = mutex_lock_interruptible(&blkdev_trig_mutex);
-	if (err)
-		goto exit_put_bdev;
-
-	btb = devres_find(&bdev->bd_device, blkdev_trig_btb_release,
-			  NULL, NULL);
-	if (btb == NULL) {
-		err = -EUNATCH;  /* bdev isn't linked to any LED */
-		goto exit_unlock;
-	}
-
-	if (xa_load(&btb->linked_leds, led->index) == NULL) {
-		err = -EUNATCH;  /* bdev isn't linked to this LED */
-		goto exit_unlock;
-	}
-
-	blkdev_trig_unlink(led, btb, BLKDEV_TRIG_NOT_RELEASING);
-
-exit_unlock:
-	mutex_unlock(&blkdev_trig_mutex);
-exit_put_bdev:
-	blkdev_put(bdev, BLKDEV_TRIG_FMODE);
-	return err ? : count;
-}
-
-/**
- * blkdev_trig_unlink() - "Unlink" a block device from an LED.
- * @led:		The LED
- * @btb:		The block device
- * @unlink_mode:	Indicates whether the BTB is being released (because
- *			the block device has been removed)
- *
- * Removes the link between an LED and a block device.
- *
- *   * Removes the BTB from the LED's @linked_btbs and removes the LED from
- *     the BTB's @linked_leds.
- *   * Removes the block device symlink from the LED's ``linked_devices``
- *     directory.
- *
- * If the block device is **not** being released:
- *
- *   * Removes the LED symlink from the block device's ``linked_leds``
- *     directory.
- *   * Calls blkdev_trig_put_btb() to clean up the BTB, if required.
- *
- * If the removed link was the only one (i.e. there are no existing block
- * device/LED links after its removal), cancels the periodic delayed work
- * which checks for device activity.
- *
- * This function is called from multiple locations.
- *
- *   * unlink_dev_by_path_store() calls this function when a block device is
- *     unlinked from an LED via the ``unlink_dev_by_path`` sysfs attribute.
- *     (@unlink_mode == ``BLKDEV_TRIG_NOT_RELEASING``)
- *   * blkdev_trig_deactivate() calls this function for each block device linked
- *     to an LED that is being deactivated (disassociated from the trigger).
- *     (@unlink_mode == ``BLKDEV_TRIG_NOT_RELEASING``).
- *   * blkdev_trig_btb_release() calls this function for each LED linked to a
- *     block device that has been removed from the system.  (@unlink_mode ==
- *     ``BLKDEV_TRIG_RELEASING).
- *
- * Context:	Process context.  Caller must hold @blkdev_trig_mutex.
- */
-static void blkdev_trig_unlink(struct blkdev_trig_led *led,
-			       struct blkdev_trig_bdev *btb,
-			       enum blkdev_trig_unlink_mode unlink_mode)
-{
-	--blkdev_trig_link_count;
-
-	if (blkdev_trig_link_count == 0)
-		WARN_ON(!cancel_delayed_work_sync(&blkdev_trig_work));
-
-	xa_erase(&btb->linked_leds, led->index);
-	xa_erase(&led->linked_btbs, btb->index);
-
-	/* Remove /sys/class/leds/<led>/linked_devices/<bdev> symlink */
-	sysfs_remove_link_from_group(&led->led_cdev->dev->kobj,
-				     blkdev_trig_linked_devs.name,
-				     dev_name(&btb->bdev->bd_device));
-
-	/*
-	 * If the BTB is being released, the driver core has already removed the
-	 * device's attribute groups, and the BTB will be freed automatically,
-	 * so only do these steps if the BTB is not being released.
-	 */
-	if (unlink_mode == BLKDEV_TRIG_NOT_RELEASING) {
-
-		/* Remove /sys/class/block/<bdev>/linked_leds/<led> symlink */
-		sysfs_remove_link_from_group(bdev_kobj(btb->bdev),
-					     blkdev_trig_linked_leds.name,
-					     led->led_cdev->name);
-		blkdev_trig_put_btb(btb);
-	}
-}
-
-/**
- * blkdev_trig_put_btb() - Remove and free a BTB, if it is no longer needed.
- * @btb:	The BTB
- *
- * Does nothing if the BTB (block device) is still linked to at least one LED.
- *
- * If the BTB is no longer linked to any LEDs, removes the block device's
- * ``linked_leds`` directory (attribute group), removes the BTB from the
- * block device's resource list, and frees the BTB.
- *
- * Called from blkdev_trig_unlink() (and in the link_dev_by_path_store() error
- * path).
- *
- * Context:	Process context.  Caller must hold @blkdev_trig_mutex.
- */
-static void blkdev_trig_put_btb(struct blkdev_trig_bdev *btb)
-{
-	struct block_device *bdev = btb->bdev;
-	int err;
-
-	if (xa_empty(&btb->linked_leds)) {
-
-		sysfs_remove_group(bdev_kobj(bdev), &blkdev_trig_linked_leds);
-		err = devres_destroy(&bdev->bd_device, blkdev_trig_btb_release,
-				     NULL, NULL);
-		WARN_ON(err);
-	}
-}
-
-/**
- * blkdev_trig_deactivate() - Called when an LED is disassociated from the
- *			      trigger.
- * @led_cdev:	The LED
- *
- * Calls blkdev_trig_unlink() for each block device linked to the LED, removes
- * the LED from the @blkdevtrig_all_leds list, and frees the @blkdev_trig_led.
- *
- * Context:	Process context.  Takes and releases @blkdev_trig_mutex.
- */
-static void blkdev_trig_deactivate(struct led_classdev *led_cdev)
-{
-	struct blkdev_trig_led *led = led_get_trigger_data(led_cdev);
-	struct blkdev_trig_bdev *btb;
-	unsigned long index;
-
-	mutex_lock(&blkdev_trig_mutex);
-
-	xa_for_each (&led->linked_btbs, index, btb)
-		blkdev_trig_unlink(led, btb, BLKDEV_TRIG_NOT_RELEASING);
-
-	hlist_del(&led->all_leds_node);
-	kfree(led);
-
-	mutex_unlock(&blkdev_trig_mutex);
-}
-
-/**
- * blkdev_trig_btb_release() - BTB device resource release function.
- * @dev:	The block device
- * @res:	The BTB
- *
- * Called by the driver core when a block device with a BTB is removed from
- * the system.  Calls blkdev_trig_unlink() for each LED linked to the block
- * device.
- *
- * Context:	Process context.  Takes and releases @blkdev_trig_mutex.
- */
-static void blkdev_trig_btb_release(struct device *dev, void *res)
-{
-	struct blkdev_trig_bdev *btb = res;
-	struct blkdev_trig_led *led;
-	unsigned long index;
-
-	mutex_lock(&blkdev_trig_mutex);
-
-	xa_for_each (&btb->linked_leds, index, led)
-		blkdev_trig_unlink(led, btb, BLKDEV_TRIG_RELEASING);
-
-	mutex_unlock(&blkdev_trig_mutex);
-}
-
-/**
- * blkdev_trig_check() - Check linked devices for activity and blink LEDs.
- * @work:	Delayed work (@blkdev_trig_work)
- *
- * Called periodically (as delayed work) to check linked block devices for
- * activity and blink LEDs.
- *
- *   * Iterates through all LEDs associated with the trigger.
- *   * If an LED is due to be checked, iterates through the block devices (BTBs)
- *     linked to the LED.
- *   * If a block device has not already been checked during this pass, calls
- *     blkdev_trig_update_btb() to update the BTB's activity counters and
- *     timestamps.
- *   * If the LED has not already been blinked during this pass, calls
- *     blkdev_trig_blink() to blink it if the correct type of activity has
- *     occurred since the LED was last checked.
- *
- * When finished, schedules itself to run again when the next LED is due to be
- * checked.
- *
- * Context:	Process context.  Takes and releases @blkdev_trig_mutex.
- */
-static void blkdev_trig_check(struct work_struct *work)
-{
-	struct blkdev_trig_led *led;
-	struct blkdev_trig_bdev *btb;
-	unsigned long index, delay, now, led_check, led_delay;
-	bool blinked;
-
-	if (!mutex_trylock(&blkdev_trig_mutex)) {
-		delay = msecs_to_jiffies(BLKDEV_TRIG_CHECK_RETRY);
-		goto exit_reschedule;
-	}
-
-	now = jiffies;
-	delay = ULONG_MAX;
-
-	hlist_for_each_entry (led, &blkdev_trig_all_leds, all_leds_node) {
-
-		led_check = led->last_checked + led->check_jiffies;
-
-		if (time_before_eq(led_check, now)) {
-
-			blinked = false;
-
-			xa_for_each (&led->linked_btbs, index, btb) {
-
-				if (btb->last_checked != now)
-					blkdev_trig_update_btb(btb, now);
-				if (!blinked)
-					blinked = blkdev_trig_blink(led, btb);
-			}
-
-			led->last_checked = now;
-			led_delay = led->check_jiffies;
-
-		} else {
-			led_delay = led_check - now;
-		}
-
-		if (led_delay < delay)
-			delay = led_delay;
-	}
-
-	mutex_unlock(&blkdev_trig_mutex);
-
-exit_reschedule:
-	WARN_ON_ONCE(delay == ULONG_MAX);
-	WARN_ON_ONCE(!schedule_delayed_work(&blkdev_trig_work, delay));
-}
-
-/**
- * blkdev_trig_blink() - Blink an LED, if the correct type of activity has
- *			 occurred on the block device.
- * @led:	The LED
- * @btb:	The block device
- *
- * Context:	Process context.  Caller must hold @blkdev_trig_mutex.
- * Return:	``true`` if the LED is blinked, ``false`` if not.
- */
-static bool blkdev_trig_blink(const struct blkdev_trig_led *led,
-			      const struct blkdev_trig_bdev *btb)
-{
-	unsigned long delay_on, delay_off;
-	enum stat_group i;
-	unsigned long mode, mask;
-
-	mode = READ_ONCE(led->mode);
-
-	for (i = STAT_READ, mask = 1; i <= STAT_FLUSH; ++i, mask <<= 1) {
-
-		if (!(mode & mask))
-			continue;
-
-		if (time_before_eq(btb->last_activity[i], led->last_checked))
-			continue;
-
-		delay_on = READ_ONCE(led->blink_msec);
-		delay_off = 1;	/* 0 leaves LED turned on */
-
-		led_blink_set_oneshot(led->led_cdev, &delay_on, &delay_off, 0);
-		return true;
-	}
-
-	return false;
-}
-
-/**
- * blink_time_show() - ``blink_time`` device attribute show function.
- * @dev:	The LED device
- * @attr:	The ``blink_time`` attribute (@dev_attr_blink_time)
- * @buf:	Output buffer
- *
- * Writes the current value of the LED's @blink_msec to @buf.
- *
- * Context:	Process context.
- * Return:	The number of characters written to @buf.
- */
-static ssize_t blink_time_show(struct device *dev,
-			       struct device_attribute *attr, char *buf)
-{
-	const struct blkdev_trig_led *led = led_trigger_get_drvdata(dev);
-
-	return sprintf(buf, "%u\n", READ_ONCE(led->blink_msec));
-}
-
-/**
- * blink_time_store() - ``blink_time`` device attribute store function.
- * @dev:	The LED device
- * @attr:	The ``blink_time`` attribute (@dev_attr_blink_time)
- * @buf:	The new value (as written to the sysfs attribute)
- * @count:	The number of characters in @buf
- *
- * Sets the LED's @blink_msec (the duration in milliseconds of one blink).
- *
- * Context:	Process context.
- * Return:	@count on success, ``-errno`` on error.
- */
-static ssize_t blink_time_store(struct device *dev,
-				struct device_attribute *attr,
-				const char *buf, size_t count)
-{
-	struct blkdev_trig_led *led = led_trigger_get_drvdata(dev);
-	unsigned int value;
-	int err;
-
-	err = kstrtouint(buf, 0, &value);
-	if (err)
-		return err;
-
-	if (value < BLKDEV_TRIG_BLINK_MIN || value > BLKDEV_TRIG_BLINK_MAX)
-		return -ERANGE;
-
-	WRITE_ONCE(led->blink_msec, value);
-	return count;
-}
-
-/**
- * check_interval_show() - ``check_interval`` device attribute show function.
- * @dev:	The LED device
- * @attr:	The ``check_interval`` attribute (@dev_attr_check_interval)
- * @buf:	Output buffer
- *
- * Writes the current value of the LED's @check_jiffies (converted to
- * milliseconds) to @buf.
- *
- * Context:	Process context.
- * Return:	The number of characters written to @buf.
- */
-static ssize_t check_interval_show(struct device *dev,
-				   struct device_attribute *attr, char *buf)
-{
-	struct blkdev_trig_led *led = led_trigger_get_drvdata(dev);
-
-	return sprintf(buf, "%u\n",
-		       jiffies_to_msecs(READ_ONCE(led->check_jiffies)));
-}
-
-/**
- * check_interval_store() - ``check_interval`` device attribute store function
- * @dev:	The LED device
- * @attr:	The ``check_interval`` attribute (@dev_attr_check_interval)
- * @buf:	The new value (as written to the sysfs attribute)
- * @count:	The number of characters in @buf
- *
- * Sets the LED's @check_jiffies (after converting from milliseconds).
- *
- * Context:	Process context.
- * Return:	@count on success, ``-errno`` on error.
- */
-static ssize_t check_interval_store(struct device *dev,
-				    struct device_attribute *attr,
-				    const char *buf, size_t count)
-{
-	struct blkdev_trig_led *led = led_trigger_get_drvdata(dev);
-	unsigned int value;
-	int err;
-
-	err = kstrtouint(buf, 0, &value);
-	if (err)
-		return err;
-
-	if (value < BLKDEV_TRIG_CHECK_MIN || value > BLKDEV_TRIG_CHECK_MAX)
-		return -ERANGE;
-
-	WRITE_ONCE(led->check_jiffies, msecs_to_jiffies(value));
-
-	return count;
-}
-
-/**
- * blkdev_trig_mode_show() - Helper for boolean attribute show functions.
- * @led:	The LED
- * @buf:	Output buffer
- * @bit:	Which bit to show
- *
- * Context:	Process context.
- * Return:	The number of characters written to @buf.
- */
-static int blkdev_trig_mode_show(const struct blkdev_trig_led *led, char *buf,
-				 enum stat_group bit)
-{
-	return sprintf(buf, READ_ONCE(led->mode) & (1 << bit) ? "Y\n" : "N\n");
-}
-
-/**
- * blkdev_trig_mode_store() - Helper for boolean attribute store functions.
- * @led:	The LED
- * @buf:	The new value (as written to the sysfs attribute)
- * @count:	The number of characters in @buf
- * @bit:	Which bit to set
- *
- * Context:	Process context.
- * Return:	@count on success, ``-errno`` on error.
- */
-static int blkdev_trig_mode_store(struct blkdev_trig_led *led,
-				  const char *buf, size_t count,
-				  enum stat_group bit)
-{
-	bool set;
-	int err;
-
-	err = kstrtobool(buf, &set);
-	if (err)
-		return err;
-
-	if (set)
-		set_bit(bit, &led->mode);
-	else
-		clear_bit(bit, &led->mode);
-
-	return count;
-}
-
-/**
- * blink_on_read_show() - ``blink_on_read`` device attribute show function.
- * @dev:	The LED device
- * @attr:	The ``blink_on_read`` attribute (@dev_attr_blink_on_read)
- * @buf:	Output buffer
- *
- * Writes the current value of the LED's @mode read bit to @buf.
- *
- * Context:	Process context.
- * Return:	The number of characters written to @buf.
- */
-static ssize_t blink_on_read_show(struct device *dev,
-				  struct device_attribute *attr, char *buf)
-{
-	return blkdev_trig_mode_show(led_trigger_get_drvdata(dev),
-				     buf, STAT_READ);
-}
-
-/**
- * blink_on_read_store() - ``blink_on_read`` device attribute store function.
- * @dev:	The LED device
- * @attr:	The ``blink_on_read`` attribute (@dev_attr_blink_on_read)
- * @buf:	The new value (as written to the sysfs attribute)
- * @count:	The number of characters in @buf
- *
- * Sets or clears the LED's @mode read bit.
- *
- * Context:	Process context.
- * Return:	@count on success, ``-errno`` on error.
- */
-static ssize_t blink_on_read_store(struct device *dev,
-				   struct device_attribute *attr,
-				   const char *buf, size_t count)
-{
-	return blkdev_trig_mode_store(led_trigger_get_drvdata(dev),
-				      buf, count, STAT_READ);
-}
-
-/**
- * blink_on_write_show() - ``blink_on_write`` device attribute show function.
- * @dev:	The LED device
- * @attr:	The ``blink_on_write`` attribute (@dev_attr_blink_on_write)
- * @buf:	Output buffer
- *
- * Writes the current value of the LED's @mode write bit to @buf.
- *
- * Context:	Process context.
- * Return:	The number of characters written to @buf.
- */
-static ssize_t blink_on_write_show(struct device *dev,
-				   struct device_attribute *attr, char *buf)
-{
-	return blkdev_trig_mode_show(led_trigger_get_drvdata(dev),
-				     buf, STAT_WRITE);
-}
-
-/**
- * blink_on_write_store() - ``blink_on_write`` device attribute store function.
- * @dev:	The LED device
- * @attr:	The ``blink_on_write`` attribute (@dev_attr_blink_on_write)
- * @buf:	The new value (as written to the sysfs attribute)
- * @count:	The number of characters in @buf
- *
- * Sets or clears the LED's @mode write bit.
- *
- * Context:	Process context.
- * Return:	@count on success, ``-errno`` on error.
- */
-static ssize_t blink_on_write_store(struct device *dev,
-				    struct device_attribute *attr,
-				    const char *buf, size_t count)
-{
-	return blkdev_trig_mode_store(led_trigger_get_drvdata(dev),
-				      buf, count, STAT_WRITE);
-}
-
-/**
- * blink_on_flush_show() - ``blink_on_flush`` device attribute show function.
- * @dev:	The LED device
- * @attr:	The ``blink_on_flush`` attribute (@dev_attr_blink_on_flush)
- * @buf:	Output buffer
- *
- * Writes the current value of the LED's @mode flush bit to @buf.
- *
- * Context:	Process context.
- * Return:	The number of characters written to @buf.
- */
-static ssize_t blink_on_flush_show(struct device *dev,
-				   struct device_attribute *attr, char *buf)
-{
-	return blkdev_trig_mode_show(led_trigger_get_drvdata(dev),
-				     buf, STAT_FLUSH);
-}
-
-/**
- * blink_on_flush_store() - ``blink_on_flush`` device attribute store function.
- * @dev:	The LED device
- * @attr:	The ``blink_on_flush`` attribute (@dev_attr_blink_on_flush)
- * @buf:	The new value (as written to the sysfs attribute)
- * @count:	The number of characters in @buf
- *
- * Sets or clears the LED's @mode flush bit.
- *
- * Context:	Process context.
- * Return:	@count on success, ``-errno`` on error.
- */
-static ssize_t blink_on_flush_store(struct device *dev,
-				    struct device_attribute *attr,
-				    const char *buf, size_t count)
-{
-	return blkdev_trig_mode_store(led_trigger_get_drvdata(dev),
-				      buf, count, STAT_FLUSH);
-}
-
-/**
- * blink_on_discard_show() - ``blink_on_discard`` device attribute show
- *			     function.
- * @dev:	The LED device
- * @attr:	The ``blink_on_discard`` attribute (@dev_attr_blink_on_discard)
- * @buf:	Output buffer
- *
- * Writes the current value of the LED's @mode discard bit to @buf.
- *
- * Context:	Process context.
- * Return:	The number of characters written to @buf.
- */
-static ssize_t blink_on_discard_show(struct device *dev,
-				     struct device_attribute *attr, char *buf)
-{
-	return blkdev_trig_mode_show(led_trigger_get_drvdata(dev),
-				     buf, STAT_DISCARD);
-}
-
-/**
- * blink_on_discard_store() - ``blink_on_discard`` device attribute store
- *			      function.
- * @dev:	The LED device
- * @attr:	The ``blink_on_discard`` attribute (@dev_attr_blink_on_discard)
- * @buf:	The new value (as written to the sysfs attribute)
- * @count:	The number of characters in @buf
- *
- * Sets or clears the LED's @mode discard bit.
- *
- * Context:	Process context.
- * Return:	@count on success, ``-errno`` on error.
- */
-static ssize_t blink_on_discard_store(struct device *dev,
-				      struct device_attribute *attr,
-				      const char *buf, size_t count)
-{
-	return blkdev_trig_mode_store(led_trigger_get_drvdata(dev),
-				      buf, count, STAT_DISCARD);
-}
-
-/* Device attributes */
-static DEVICE_ATTR_WO(link_dev_by_path);
-static DEVICE_ATTR_WO(unlink_dev_by_path);
-static DEVICE_ATTR_RW(blink_time);
-static DEVICE_ATTR_RW(check_interval);
-static DEVICE_ATTR_RW(blink_on_read);
-static DEVICE_ATTR_RW(blink_on_write);
-static DEVICE_ATTR_RW(blink_on_flush);
-static DEVICE_ATTR_RW(blink_on_discard);
-
-/* Device attributes in LED directory (/sys/class/leds/<led>/...) */
-static struct attribute *blkdev_trig_attrs[] = {
-	&dev_attr_link_dev_by_path.attr,
-	&dev_attr_unlink_dev_by_path.attr,
-	&dev_attr_blink_time.attr,
-	&dev_attr_check_interval.attr,
-	&dev_attr_blink_on_read.attr,
-	&dev_attr_blink_on_write.attr,
-	&dev_attr_blink_on_flush.attr,
-	&dev_attr_blink_on_discard.attr,
-	NULL
-};
-
-/* Unnamed attribute group == no subdirectory */
-static const struct attribute_group blkdev_trig_attr_group = {
-	.attrs	= blkdev_trig_attrs,
-};
-
-/* Attribute groups for the trigger */
-static const struct attribute_group *blkdev_trig_attr_groups[] = {
-	&blkdev_trig_attr_group,   /* /sys/class/leds/<led>/... */
-	&blkdev_trig_linked_devs,  /* /sys/class/leds/<led>/linked_devices/ */
-	NULL
-};
-
-/* Trigger registration data */
-static struct led_trigger blkdev_trig_trigger = {
-	.name		= "blkdev",
-	.activate	= blkdev_trig_activate,
-	.deactivate	= blkdev_trig_deactivate,
-	.groups		= blkdev_trig_attr_groups,
-};
-
-/**
- * blkdev_trig_init() - Block device LED trigger initialization.
- *
- * Registers the LED trigger.
- *
- * Return:	0 on success, ``-errno`` on failure.
- */
-static int __init blkdev_trig_init(void)
-{
-	return led_trigger_register(&blkdev_trig_trigger);
-}
-module_init(blkdev_trig_init);
-
-/**
- * blkdev_trig_exit() - Block device LED trigger module exit.
- *
- * Unregisters the LED trigger.
- */
-static void __exit blkdev_trig_exit(void)
-{
-	led_trigger_unregister(&blkdev_trig_trigger);
-}
-module_exit(blkdev_trig_exit);
-
-MODULE_DESCRIPTION("Block device LED trigger");
-MODULE_AUTHOR("Ian Pilcher <arequipeno@gmail.com>");
-MODULE_LICENSE("GPL v2");
-- 
2.37.3.485.gbe1a02a17e


From 87c29784fb07e0f6e8b784f522ec7f9acf8eb40f Mon Sep 17 00:00:00 2001
From: Piotr Gorski <lucjan.lucjanov@gmail.com>
Date: Mon, 26 Sep 2022 20:34:51 +0200
Subject: [PATCH 39/41] Revert "docs: Add block device (blkdev) LED trigger
 documentation"

This reverts commit 736284f502519d3ffa13d9d3830c039a8df0b752.

Signed-off-by: Piotr Gorski <lucjan.lucjanov@gmail.com>
---
 Documentation/ABI/stable/sysfs-block          |  10 --
 .../testing/sysfs-class-led-trigger-blkdev    |  68 --------
 Documentation/leds/index.rst                  |   1 -
 Documentation/leds/ledtrig-blkdev.rst         | 155 ------------------
 4 files changed, 234 deletions(-)
 delete mode 100644 Documentation/ABI/testing/sysfs-class-led-trigger-blkdev
 delete mode 100644 Documentation/leds/ledtrig-blkdev.rst

diff --git a/Documentation/ABI/stable/sysfs-block b/Documentation/ABI/stable/sysfs-block
index 289c2447f..e8797cd09 100644
--- a/Documentation/ABI/stable/sysfs-block
+++ b/Documentation/ABI/stable/sysfs-block
@@ -101,16 +101,6 @@ Description:
 		devices that support receiving integrity metadata.
 
 
-What:		/sys/block/<disk>/linked_leds
-Date:		March 2022
-Contact:	Ian Pilcher <arequipeno@gmail.com>
-Description:
-		Directory that contains symbolic links to all LEDs that
-		are associated with (linked to) this block device by the
-		blkdev LED trigger.  Only present when at least one LED
-		is linked.  (See Documentation/leds/ledtrig-blkdev.rst.)
-
-
 What:		/sys/block/<disk>/<partition>/alignment_offset
 Date:		April 2009
 Contact:	Martin K. Petersen <martin.petersen@oracle.com>
diff --git a/Documentation/ABI/testing/sysfs-class-led-trigger-blkdev b/Documentation/ABI/testing/sysfs-class-led-trigger-blkdev
deleted file mode 100644
index 9214439b0..000000000
--- a/Documentation/ABI/testing/sysfs-class-led-trigger-blkdev
+++ /dev/null
@@ -1,68 +0,0 @@
-What:		/sys/class/leds/<led>/blink_time
-Date:		March 2022
-Contact:	Ian Pilcher <arequipeno@gmail.com>
-Description:
-		Time (in milliseconds) that the LED will be on during a single
-		"blink".
-
-What:		/sys/class/leds/<led>/check_interval
-Date:		March 2022
-Contact:	Ian Pilcher <arequipeno@gmail.com>
-Description:
-		Frequency (in milliseconds) with which block devices linked to
-		this LED will be checked for activity and the LED will
-		(potentially) be blinked.
-
-What:		/sys/class/leds/<led>/blink_on_read
-Date:		March 2022
-Contact:	Ian Pilcher <arequipeno@gmail.com>
-Description:
-		Boolean that determines whether the LED will blink in response
-		to read activity on any of its linked block devices.
-
-What:		/sys/class/leds/<led>/blink_on_write
-Date:		March 2022
-Contact:	Ian Pilcher <arequipeno@gmail.com>
-Description:
-		Boolean that determines whether the LED will blink in response
-		to write activity on any of its linked block devices.
-
-What:		/sys/class/leds/<led>/blink_on_discard
-Date:		March 2022
-Contact:	Ian Pilcher <arequipeno@gmail.com>
-Description:
-		Boolean that determines whether the LED will blink in response
-		to discard activity on any of its linked block devices.
-
-What:		/sys/class/leds/<led>/blink_on_flush
-Date:		March 2022
-Contact:	Ian Pilcher <arequipeno@gamil.com>
-Description:
-		Boolean that determines whether the LED will blink in response
-		to cache flush activity on any of its linked block devices.
-
-What:		/sys/class/leds/<led>/link_dev_by_path
-Date:		March 2022
-Contact:	Ian Pilcher <arequipeno@gmail.com>
-Description:
-		Associate a block device with this LED by writing the path to
-		the device special file (e.g. /dev/sda) to this attribute.
-		Symbolic links are followed.
-
-What:		/sys/class/leds/<led>/unlink_dev_by_path
-Date:		March 2022
-Contact:	Ian Pilcher <arequipeno@gmail.com>
-Description:
-		Remove the association between this LED and a block device by
-		writing the path to the device special file (e.g. /dev/sda) to
-		this attribute.  Symbolic links are followed.
-
-What:		/sys/class/leds/<led>/linked_devices
-Date:		March 2022
-Contact:	Ian Pilcher <arequipeno@gmail.com>
-Description:
-		Directory containing links to all block devices that are
-		associated with this LED.  (Note that the names of the
-		symbolic links in this directory are *kernel* names, which
-		may not match the device special file paths written to
-		link_device and unlink_device.)
diff --git a/Documentation/leds/index.rst b/Documentation/leds/index.rst
index e3c24e468..e5d63b940 100644
--- a/Documentation/leds/index.rst
+++ b/Documentation/leds/index.rst
@@ -10,7 +10,6 @@ LEDs
    leds-class
    leds-class-flash
    leds-class-multicolor
-   ledtrig-blkdev
    ledtrig-oneshot
    ledtrig-transient
    ledtrig-usbport
diff --git a/Documentation/leds/ledtrig-blkdev.rst b/Documentation/leds/ledtrig-blkdev.rst
deleted file mode 100644
index ae92aa559..000000000
--- a/Documentation/leds/ledtrig-blkdev.rst
+++ /dev/null
@@ -1,155 +0,0 @@
-.. SPDX-License-Identifier: GPL-2.0
-
-=================================
-Block Device (blkdev) LED Trigger
-=================================
-
-Available when ``CONFIG_LEDS_TRIGGER_BLKDEV=y`` or
-``CONFIG_LEDS_TRIGGER_BLKDEV=m``.
-
-See also:
-
-* ``Documentation/ABI/testing/sysfs-class-led-trigger-blkdev``
-* ``Documentation/ABI/stable/sysfs-block`` (``/sys/block/<disk>/linked_leds``)
-
-Overview
-========
-
-.. note::
-	The examples below use ``<LED>`` to refer to the name of a
-	system-specific LED.  If no suitable LED is available on a test
-	system (in a virtual machine, for example), it is possible to
-	use a userspace LED.  (See ``Documentation/leds/uleds.rst``.)
-
-Verify that the ``blkdev`` LED trigger is available::
-
-	# grep blkdev /sys/class/leds/<LED>/trigger
-	... rfkill-none blkdev
-
-(If the previous command produces no output, you may need to load the trigger
-module - ``modprobe ledtrig_blkdev``.  If the module is not available, check
-the value of ``CONFIG_LEDS_TRIGGER_BLKDEV`` in your kernel configuration.)
-
-Associate the LED with the ``blkdev`` LED trigger::
-
-	# echo blkdev > /sys/class/leds/<LED>/trigger
-
-	# cat /sys/class/leds/<LED>/trigger
-	... rfkill-none [blkdev]
-
-Note that several new device attributes are available in the
-``/sys/class/leds/<LED>`` directory.
-
-* ``link_dev_by_path`` and ``unlink_dev_by_path`` are used to manage the set of
-  block devices associated with this LED.  The LED will blink in response to
-  read or write activity on its linked devices.
-
-* ``blink_on_read``, ``blink_on_write``, ``blink_on_discard``, and
-  ``blink_on_flush`` are boolean values that determine whether the LED will
-  blink when a particular type of activity is detected on one of its linked
-  block devices.
-
-* ``blink_time`` is the duration (in milliseconds) of each blink of this LED.
-  (The minimum value is 10 milliseconds.)
-
-* ``check_interval`` is the frequency (in milliseconds) with which block devices
-  linked to this LED will be checked for activity and the LED blinked (if the
-  correct type of activity has occurred).
-
-* The ``linked_devices`` directory will contain a symbolic link to every device
-  that is associated with this LED.
-
-Link a block device to the LED::
-
-	# echo /dev/sda > /sys/class/leds/<LED>/link_dev_by_path
-
-	# ls /sys/class/leds/<LED>/linked_devices
-	sda
-
-(The value written to ``link_dev_by_path`` must be the path of the device
-special file, such as ``/dev/sda``, that represents the block device - or the
-path of a symbolic link to such a device special file.)
-
-Activity on the device will now cause the LED to blink.  The duration of each
-blink (in milliseconds) can be adjusted by setting
-``/sys/class/leds/<LED>/blink_time``.  (But see **check_interval and
-blink_time** below.)
-
-Associate a second device with the LED::
-
-	# echo /dev/sdb > /sys/class/leds/<LED>/link_dev_by_path
-
-	# ls /sys/class/leds/<LED>/linked_devices
-	sda  sdb
-
-When a block device is linked to one or more LEDs, the LEDs are linked from
-the device's ``linked_leds`` directory::
-
-	# ls /sys/class/block/sd{a,b}/linked_leds
-	/sys/class/block/sda/linked_leds:
-	<LED>
-
-	/sys/class/block/sdb/linked_leds:
-	<LED>
-
-(The ``linked_leds`` directory only exists when the block device is linked to
-at least one LED.)
-
-``check_interval`` and ``blink_time``
-=====================================
-
-* By default, linked block devices are checked for activity every 100
-  milliseconds.  This frequency can be changed for an LED via the
-  ``/sys/class/leds/<led>/check_interval`` attribute.  (The minimum value is 25
-  milliseconds.)
-
-* All block devices associated with an LED are checked for activity every
-  ``check_interval`` milliseconds, and a blink is triggered if the correct type
-  of activity (as determined by the LED's ``blink_on_*`` attributes) is
-  detected.  The duration of an LED's blink is determined by its ``blink_time``
-  attribute.  Thus (when the correct type of activity is detected), the LED will
-  be on for ``blink_time`` milliseconds and off for
-  ``check_interval - blink_time`` milliseconds.
-
-* The LED subsystem ignores new blink requests for an LED that is already in
-  in the process of blinking, so setting a ``blink_time`` greater than or equal
-  to ``check_interval`` will cause some blinks to be missed.
-
-* Because of processing times, scheduling latencies, etc., avoiding missed
-  blinks actually requires a difference of at least a few milliseconds between
-  the ``blink_time`` and ``check_interval``.  The required difference is likely
-  to vary from system to system.  As a  reference, a Thecus N5550 NAS requires a
-  difference of 7 milliseconds (e.g. ``check_interval == 100``,
-  ``blink_time == 93``).
-
-* The default values (``check_interval == 100``, ``blink_time == 75``) cause the
-  LED associated with a continuously active device to blink rapidly.  For a more
-  "always on" effect, increase the ``blink_time`` (but not too much; see the
-  previous bullet).
-
-Other Notes
-===========
-
-* Many (possibly all) types of block devices work with this trigger, including:
-
-  * SCSI (including SATA and USB) hard disk drives and SSDs
-  * SCSI (including SATA and USB) optical drives
-  * NVMe SSDs
-  * SD cards
-  * loopback block devices (``/dev/loop*``)
-  * device mapper devices, such as LVM logical volumes
-  * MD RAID devices
-  * zRAM compressed RAM-disks
-  * partitions on block devics that support them
-
-* The names of the symbolic links in ``/sys/class/leds/<LED>/linked_devices``
-  are **kernel** names, which may not match the paths used for
-  ``link_dev_by_path`` and ``unlink_dev_by_path``.  This is most likely when a
-  symbolic link is used to refer to the device (as is common with logical
-  volumes), but it can be true for any device, because nothing prevents the
-  creation of device special files with arbitrary names (e.g.
-  ``sudo mknod /foo b 8 0``).
-
-* The ``blkdev`` LED trigger supports many-to-many device/LED associations.
-  A device can be associated with multiple LEDs, and an LED can be associated
-  with multiple devices.
-- 
2.37.3.485.gbe1a02a17e


From f8fe1e1670df3044f58841829000b35a5259c9d2 Mon Sep 17 00:00:00 2001
From: Ian Pilcher <arequipeno@gmail.com>
Date: Mon, 26 Sep 2022 11:25:03 -0500
Subject: [PATCH 40/41] leds: trigger: Add block device LED trigger

Add "blkdev" LED trigger to blink LEDs in response to block device
activity.

Add LEDS_TRIGGER_BLKDEV (tristate) config option to control building of
the trigger.

Signed-off-by: Ian Pilcher <arequipeno@gmail.com>
---
 drivers/leds/trigger/Kconfig          |    9 +
 drivers/leds/trigger/Makefile         |    1 +
 drivers/leds/trigger/ledtrig-blkdev.c | 1220 +++++++++++++++++++++++++
 3 files changed, 1230 insertions(+)
 create mode 100644 drivers/leds/trigger/ledtrig-blkdev.c

diff --git a/drivers/leds/trigger/Kconfig b/drivers/leds/trigger/Kconfig
index dc6816d36..bda249068 100644
--- a/drivers/leds/trigger/Kconfig
+++ b/drivers/leds/trigger/Kconfig
@@ -154,4 +154,13 @@ config LEDS_TRIGGER_TTY
 
 	  When build as a module this driver will be called ledtrig-tty.
 
+config LEDS_TRIGGER_BLKDEV
+	tristate "LED Trigger for block devices"
+	depends on BLOCK
+	help
+	  The blkdev LED trigger allows LEDs to be controlled by block device
+	  activity (reads and writes).
+
+	  See Documentation/leds/ledtrig-blkdev.rst.
+
 endif # LEDS_TRIGGERS
diff --git a/drivers/leds/trigger/Makefile b/drivers/leds/trigger/Makefile
index 25c4db97c..d53bab5d9 100644
--- a/drivers/leds/trigger/Makefile
+++ b/drivers/leds/trigger/Makefile
@@ -16,3 +16,4 @@ obj-$(CONFIG_LEDS_TRIGGER_NETDEV)	+= ledtrig-netdev.o
 obj-$(CONFIG_LEDS_TRIGGER_PATTERN)	+= ledtrig-pattern.o
 obj-$(CONFIG_LEDS_TRIGGER_AUDIO)	+= ledtrig-audio.o
 obj-$(CONFIG_LEDS_TRIGGER_TTY)		+= ledtrig-tty.o
+obj-$(CONFIG_LEDS_TRIGGER_BLKDEV)	+= ledtrig-blkdev.o
diff --git a/drivers/leds/trigger/ledtrig-blkdev.c b/drivers/leds/trigger/ledtrig-blkdev.c
new file mode 100644
index 000000000..8614e308f
--- /dev/null
+++ b/drivers/leds/trigger/ledtrig-blkdev.c
@@ -0,0 +1,1220 @@
+// SPDX-License-Identifier: GPL-2.0-only
+
+/*
+ *	Block device LED trigger
+ *
+ *	Copyright 2021-2022 Ian Pilcher <arequipeno@gmail.com>
+ */
+
+#include <linux/blkdev.h>
+#include <linux/leds.h>
+#include <linux/module.h>
+#include <linux/part_stat.h>
+#include <linux/xarray.h>
+
+/**
+ * DOC: Overview
+ *
+ * The ``blkdev`` LED trigger works by periodically checking the activity
+ * counters of block devices that have been linked to one or more LEDs and
+ * blinking those LED(s) if the correct type of activity has occurred.  The
+ * periodic check is scheduled with the Linux kernel's deferred work facility.
+ *
+ * Trigger-specific data about block devices and LEDs is stored in two data
+ * structures --- &struct blkdev_trig_bdev (a "BTB") and &struct blkdev_trig_led
+ * (a "BTL").  Each structure contains a &struct xarray that holds links to any
+ * linked devices of the other type.  I.e. &blkdev_trig_bdev.linked_btls
+ * contains links to all BTLs whose LEDs have been linked to the BTB's block
+ * device, and &blkdev_trig_led.linked_btbs contains links to all BTBs whose
+ * block devices have been linked to the BTL's LED.  Thus, a block device can
+ * be linked to more than one LED, and an LED can be linked to more than one
+ * block device.
+ */
+
+/* Default, minimum & maximum blink duration (milliseconds) */
+#define BLKDEV_TRIG_BLINK_DEF	75
+#define BLKDEV_TRIG_BLINK_MIN	10
+#define BLKDEV_TRIG_BLINK_MAX	86400000  /* 24 hours */
+
+/* Default, minimum & maximum activity check interval (milliseconds) */
+#define BLKDEV_TRIG_CHECK_DEF	100
+#define BLKDEV_TRIG_CHECK_MIN	25
+#define BLKDEV_TRIG_CHECK_MAX	86400000  /* 24 hours */
+
+/*
+ * If blkdev_trig_check() can't lock the mutex, how long to wait before trying
+ * again (milliseconds)
+ */
+#define BLKDEV_TRIG_CHECK_RETRY	5
+
+/* Mode argument for calls to blkdev_get_by_path() and blkdev_put() */
+#define BLKDEV_TRIG_FMODE	0
+
+/**
+ * struct blkdev_trig_bdev - Trigger-specific data about a block device.
+ * @last_checked:	Time (in jiffies) at which the trigger last checked this
+ *			block device for activity.
+ * @last_activity:	Time (in jiffies) at which the trigger last detected
+ *			activity of each type.
+ * @ios:		Activity counter values for each type, corresponding to
+ *			the timestamps in &last_activity.
+ * @index:		&xarray index, so the BTB can be included in one or more
+ *			&blkdev_trig_led.linked_btbs.
+ * @bdev:		The block device.
+ * @linked_btls:	The BTLs that represent the LEDs linked to the BTB's
+ *			block device.
+ *
+ * Every block device linked to at least one LED gets a "BTB."  A BTB is created
+ * when a block device that is not currently linked to any LEDs is linked to an
+ * LED.
+ *
+ * A BTB is freed when one of the following occurs:
+ *
+ * * The number of LEDs linked to the block device becomes zero, because it has
+ *   been unlinked from its last LED using the trigger's &sysfs interface.
+ *
+ * * The number of LEDs linked to the block device becomes zero, because the
+ *   last LED to which it was linked has been disassociated from the trigger
+ *   (which happens automatically if the LED device is removed from the system).
+ *
+ * * The BTB's block device is removed from the system.  To accomodate this
+ *   scenario, BTB's are created as device resources, so that the release
+ *   function will be called by the driver core when the device is removed.
+ */
+struct blkdev_trig_bdev {
+	unsigned long		last_checked;
+	unsigned long		last_activity[NR_STAT_GROUPS];
+	unsigned long		ios[NR_STAT_GROUPS];
+	unsigned long		index;
+	struct block_device	*bdev;
+	struct xarray		linked_btls;
+};
+
+/**
+ * struct blkdev_trig_led - Trigger-specific data about an LED.
+ * @last_checked:	Time (in jiffies) at which the trigger last checked the
+ *			the block devices linked to this LED for activity.
+ * @index:		&xarray index, so the BTL can be included in one or more
+ *			&blkdev_trig_bdev.linked_btls.
+ * @mode:		Bitmask for types of block device activity that will
+ *			cause this LED to blink --- reads, writes, discards,
+ *			etc.
+ * @led:		The LED device.
+ * @blink_msec:		Duration of a blink (milliseconds).
+ * @check_jiffies:	Frequency with which block devices linked to this LED
+ *			should be checked for activity (jiffies).
+ * @linked_btbs:	The BTBs that represent the block devices linked to the
+ *			BTL's LED.
+ * @all_btls_node:	The BTL's node in the module's list of all BTLs.
+ *
+ * Every LED associated with the block device trigger gets a "BTL."  A BTL is
+ * created when the trigger is "activated" on an LED (usually by writing
+ * ``blkdev`` to the LED's &sysfs &trigger attribute).  A BTL is freed wnen its
+ * LED is disassociated from the trigger, either through the trigger's &sysfs
+ * interface or because the LED device is removed from the system.
+ */
+struct blkdev_trig_led {
+	unsigned long		last_checked;
+	unsigned long		index;
+	unsigned long		mode;  /* must be ulong for atomic bit ops */
+	struct led_classdev	*led;
+	unsigned int		blink_msec;
+	unsigned int		check_jiffies;
+	struct xarray		linked_btbs;
+	struct hlist_node	all_btls_node;
+};
+
+/* Protects everything except atomic LED attributes */
+static DEFINE_MUTEX(blkdev_trig_mutex);
+
+/* BTB device resource release function */
+static void blkdev_trig_btb_release(struct device *dev, void *res);
+
+/* Index for next BTB or BTL */
+static unsigned long blkdev_trig_next_index;
+
+/* All LEDs associated with the trigger */
+static HLIST_HEAD(blkdev_trig_all_btls);
+
+/* Delayed work to periodically check for activity & blink LEDs */
+static void blkdev_trig_check(struct work_struct *work);
+static DECLARE_DELAYED_WORK(blkdev_trig_work, blkdev_trig_check);
+
+/* When is the delayed work scheduled to run next (jiffies) */
+static unsigned long blkdev_trig_next_check;
+
+/* Total number of BTB-to-BTL links */
+static unsigned int blkdev_trig_link_count;
+
+/* Empty sysfs attribute list for next 2 declarations */
+static struct attribute *blkdev_trig_attrs_empty[] = { NULL };
+
+/* linked_leds sysfs directory for block devs linked to 1 or more LEDs */
+static const struct attribute_group blkdev_trig_linked_leds = {
+	.name	= "linked_leds",
+	.attrs	= blkdev_trig_attrs_empty,
+};
+
+/* linked_devices sysfs directory for each LED associated with the trigger */
+static const struct attribute_group blkdev_trig_linked_devs = {
+	.name	= "linked_devices",
+	.attrs	= blkdev_trig_attrs_empty,
+};
+
+
+/*
+ *
+ *	Delayed work to check for activity & blink LEDs
+ *
+ */
+
+/**
+ * blkdev_trig_blink() - Blink an LED, if the correct type of activity has
+ *	occurred on the block device.
+ * @btl:	The BTL that represents the LED
+ * @btb:	The BTB that represents the block device
+ *
+ * Context:	Process context.  Caller must hold &blkdev_trig_mutex.
+ * Return:	&true if the LED is blinked, &false if not.
+ */
+static bool blkdev_trig_blink(const struct blkdev_trig_led *btl,
+			      const struct blkdev_trig_bdev *btb)
+{
+	unsigned long mode, mask, delay_on, delay_off;
+	enum stat_group i;
+
+	mode = READ_ONCE(btl->mode);
+
+	for (i = STAT_READ, mask = 1; i <= STAT_FLUSH; ++i, mask <<= 1) {
+
+		if (!(mode & mask))
+			continue;
+
+		if (time_before_eq(btb->last_activity[i], btl->last_checked))
+			continue;
+
+		delay_on = READ_ONCE(btl->blink_msec);
+		delay_off = 1;	/* 0 leaves LED turned on */
+
+		led_blink_set_oneshot(btl->led, &delay_on, &delay_off, 0);
+		return true;
+	}
+
+	return false;
+}
+
+/**
+ * blkdev_trig_update_btb() - Update a BTB's activity counters and timestamps.
+ * @btb:	The BTB
+ * @now:	Timestamp (in jiffies)
+ *
+ * Context:	Process context.  Caller must hold &blkdev_trig_mutex.
+ */
+static void blkdev_trig_update_btb(struct blkdev_trig_bdev *btb,
+				   unsigned long now)
+{
+	unsigned long new_ios;
+	enum stat_group i;
+
+	for (i = STAT_READ; i <= STAT_FLUSH; ++i) {
+
+		new_ios = part_stat_read(btb->bdev, ios[i]);
+
+		if (new_ios != btb->ios[i]) {
+			btb->ios[i] = new_ios;
+			btb->last_activity[i] = now;
+		}
+	}
+
+	btb->last_checked = now;
+}
+
+/**
+ * blkdev_trig_check() - Check linked devices for activity and blink LEDs.
+ * @work:	Delayed work (&blkdev_trig_work)
+ *
+ * Context:	Process context.  Takes and releases &blkdev_trig_mutex.
+ */
+static void blkdev_trig_check(struct work_struct *work)
+{
+	struct blkdev_trig_led *btl;
+	struct blkdev_trig_bdev *btb;
+	unsigned long index, delay, now, led_check, led_delay;
+	bool blinked;
+
+	if (!mutex_trylock(&blkdev_trig_mutex)) {
+		delay = msecs_to_jiffies(BLKDEV_TRIG_CHECK_RETRY);
+		goto exit_reschedule;
+	}
+
+	now = jiffies;
+	delay = ULONG_MAX;
+
+	hlist_for_each_entry (btl, &blkdev_trig_all_btls, all_btls_node) {
+
+		led_check = btl->last_checked + btl->check_jiffies;
+
+		if (time_before_eq(led_check, now)) {
+
+			blinked = false;
+
+			xa_for_each (&btl->linked_btbs, index, btb) {
+
+				if (btb->last_checked != now)
+					blkdev_trig_update_btb(btb, now);
+				if (!blinked)
+					blinked = blkdev_trig_blink(btl, btb);
+			}
+
+			btl->last_checked = now;
+			led_delay = btl->check_jiffies;
+
+		} else {
+			led_delay = led_check - now;
+		}
+
+		if (led_delay < delay)
+			delay = led_delay;
+	}
+
+	mutex_unlock(&blkdev_trig_mutex);
+
+exit_reschedule:
+	WARN_ON_ONCE(delay == ULONG_MAX);
+	WARN_ON_ONCE(!schedule_delayed_work(&blkdev_trig_work, delay));
+}
+
+/**
+ * blkdev_trig_sched_led() - Set the schedule of the delayed work when a new
+ *	LED is added to the schedule.
+ * @btl:	The BTL that represents the LED
+ *
+ * Called when the number of block devices to which an LED is linked becomes
+ * non-zero.
+ *
+ * Context:	Process context.  Caller must hold &blkdev_trig_mutex.
+ */
+static void blkdev_trig_sched_led(const struct blkdev_trig_led *btl)
+{
+	unsigned long delay = READ_ONCE(btl->check_jiffies);
+	unsigned long check_by = jiffies + delay;
+
+	/*
+	 * If no other LED-to-block device links exist, simply schedule the
+	 * delayed work according to this LED's check_interval attribute
+	 * (check_jiffies).
+	 */
+	if (blkdev_trig_link_count == 0) {
+		WARN_ON(!schedule_delayed_work(&blkdev_trig_work, delay));
+		blkdev_trig_next_check = check_by;
+		return;
+	}
+
+	/*
+	 * If the next check is already scheduled to occur soon enough to
+	 * accomodate this LED's check_interval, the schedule doesn't need
+	 * to be changed.
+	 */
+	if (time_after_eq(check_by, blkdev_trig_next_check))
+		return;
+
+	/*
+	 * Modify the schedule, so that the delayed work runs soon enough for
+	 * this LED.
+	 */
+	WARN_ON(!mod_delayed_work(system_wq, &blkdev_trig_work, delay));
+	blkdev_trig_next_check = check_by;
+}
+
+
+/*
+ *
+ *	Linking and unlinking LEDs and block devices
+ *
+ */
+
+/**
+ * blkdev_trig_link() - Link a block device to an LED.
+ * @btl:	The BTL that represents the LED
+ * @btb:	The BTB that represents the block device
+ *
+ * Context:	Process context.  Caller must hold &blkdev_trig_mutex.
+ * Return:	&0 on success, negative &errno on error.
+ */
+static int blkdev_trig_link(struct blkdev_trig_led *btl,
+			    struct blkdev_trig_bdev *btb)
+{
+	bool led_first_link;
+	int err;
+
+	led_first_link = xa_empty(&btl->linked_btbs);
+
+	err = xa_insert(&btb->linked_btls, btl->index, btl, GFP_KERNEL);
+	if (err)
+		return err;
+
+	err = xa_insert(&btl->linked_btbs, btb->index, btb, GFP_KERNEL);
+	if (err)
+		goto error_erase_btl;
+
+	/* Create /sys/class/block/<bdev>/linked_leds/<led> symlink */
+	err = sysfs_add_link_to_group(bdev_kobj(btb->bdev),
+				      blkdev_trig_linked_leds.name,
+				      &btl->led->dev->kobj, btl->led->name);
+	if (err)
+		goto error_erase_btb;
+
+	/* Create /sys/class/leds/<led>/linked_devices/<bdev> symlink */
+	err = sysfs_add_link_to_group(&btl->led->dev->kobj,
+				      blkdev_trig_linked_devs.name,
+				      bdev_kobj(btb->bdev),
+				      dev_name(&btb->bdev->bd_device));
+	if (err)
+		goto error_remove_symlink;
+
+	/*
+	 * If this is the first block device linked to this LED, the delayed
+	 * work schedule may need to be changed.
+	 */
+	if (led_first_link)
+		blkdev_trig_sched_led(btl);
+
+	++blkdev_trig_link_count;
+
+	return 0;
+
+error_remove_symlink:
+	sysfs_remove_link_from_group(bdev_kobj(btb->bdev),
+				     blkdev_trig_linked_leds.name,
+				     btl->led->name);
+error_erase_btb:
+	xa_erase(&btl->linked_btbs, btb->index);
+error_erase_btl:
+	xa_erase(&btb->linked_btls, btl->index);
+	return err;
+}
+
+/**
+ * blkdev_trig_put_btb() - Remove and free a BTB, if it is no longer needed.
+ * @btb:	The BTB
+ *
+ * Does nothing if the BTB (block device) is still linked to at least one LED.
+ *
+ * Context:	Process context.  Caller must hold &blkdev_trig_mutex.
+ */
+static void blkdev_trig_put_btb(struct blkdev_trig_bdev *btb)
+{
+	struct block_device *bdev = btb->bdev;
+	int err;
+
+	if (xa_empty(&btb->linked_btls)) {
+
+		sysfs_remove_group(bdev_kobj(bdev), &blkdev_trig_linked_leds);
+		err = devres_destroy(&bdev->bd_device, blkdev_trig_btb_release,
+				     NULL, NULL);
+		WARN_ON(err);
+	}
+}
+
+/**
+ * _blkdev_trig_unlink_always() - Perform the unconditionally required steps of
+ *	unlinking a block device from an LED.
+ * @btl:	The BTL that represents the LED
+ * @btb:	The BTB that represents the block device
+ *
+ * When a block device is unlinked from an LED, certain steps must be performed
+ * only if the block device is **not** being released.  This function performs
+ * those steps that are **always** required, whether or not the block device is
+ * being released.
+ *
+ * Context:	Process context.  Caller must hold &blkdev_trig_mutex.
+ */
+static void _blkdev_trig_unlink_always(struct blkdev_trig_led *btl,
+				       struct blkdev_trig_bdev *btb)
+{
+	--blkdev_trig_link_count;
+
+	if (blkdev_trig_link_count == 0)
+		WARN_ON(!cancel_delayed_work_sync(&blkdev_trig_work));
+
+	xa_erase(&btb->linked_btls, btl->index);
+	xa_erase(&btl->linked_btbs, btb->index);
+
+	/* Remove /sys/class/leds/<led>/linked_devices/<bdev> symlink */
+	sysfs_remove_link_from_group(&btl->led->dev->kobj,
+				     blkdev_trig_linked_devs.name,
+				     dev_name(&btb->bdev->bd_device));
+}
+
+/**
+ * blkdev_trig_unlink_norelease() - Unlink an LED from a block device that is
+ *	**not** being released.
+ * @btl:	The BTL that represents the LED.
+ * @btb:	The BTB that represents the block device.
+ *
+ * Context:	Process context.  Caller must hold &blkdev_trig_mutex.
+ */
+static void blkdev_trig_unlink_norelease(struct blkdev_trig_led *btl,
+					 struct blkdev_trig_bdev *btb)
+{
+	_blkdev_trig_unlink_always(btl, btb);
+
+	/* Remove /sys/class/block/<bdev>/linked_leds/<led> symlink */
+	sysfs_remove_link_from_group(bdev_kobj(btb->bdev),
+				     blkdev_trig_linked_leds.name,
+				     btl->led->name);
+
+	blkdev_trig_put_btb(btb);
+}
+
+/**
+ * blkdev_trig_unlink_release() - Unlink an LED from a block device that is
+ *	being released.
+ * @btl:	The BTL that represents the LED
+ * @btb:	The BTB that represents the block device
+ *
+ * Context:	Process context.  Caller must hold &blkdev_trig_mutex.
+ */
+static void blkdev_trig_unlink_release(struct blkdev_trig_led *btl,
+				       struct blkdev_trig_bdev *btb)
+{
+	_blkdev_trig_unlink_always(btl, btb);
+
+	/*
+	 * If the BTB is being released, the driver core has already removed the
+	 * device's attribute groups, and the BTB will be freed automatically,
+	 * so there's nothing else to do.
+	 */
+}
+
+
+/*
+ *
+ *	BTB creation
+ *
+ */
+
+/**
+ * blkdev_trig_btb_release() - BTB device resource release function.
+ * @dev:	The block device
+ * @res:	The BTB
+ *
+ * Called by the driver core when a block device with a BTB is removed.
+ *
+ * Context:	Process context.  Takes and releases &blkdev_trig_mutex.
+ */
+static void blkdev_trig_btb_release(struct device *dev, void *res)
+{
+	struct blkdev_trig_bdev *btb = res;
+	struct blkdev_trig_led *btl;
+	unsigned long index;
+
+	mutex_lock(&blkdev_trig_mutex);
+
+	xa_for_each (&btb->linked_btls, index, btl)
+		blkdev_trig_unlink_release(btl, btb);
+
+	mutex_unlock(&blkdev_trig_mutex);
+}
+
+/**
+ * blkdev_trig_get_bdev() - Get a block device by path.
+ * @path:	The value written to an LED's &link_dev_by_path or
+ *		&unlink_dev_by_path attribute, which should be the path to a
+ *		special file that represents a block device
+ * @len:	The number of characters in &path (not including its
+ *		terminating null)
+ *
+ * The caller must call blkdev_put() when finished with the device.
+ *
+ * Context:	Process context.
+ * Return:	The block device, or an error pointer.
+ */
+static struct block_device *blkdev_trig_get_bdev(const char *path, size_t len)
+{
+	struct block_device *bdev;
+	char *buf;
+
+	buf = kmemdup(path, len + 1, GFP_KERNEL);  /* +1 to include null */
+	if (buf == NULL)
+		return ERR_PTR(-ENOMEM);
+
+	bdev = blkdev_get_by_path(strim(buf), BLKDEV_TRIG_FMODE, THIS_MODULE);
+	kfree(buf);
+	return bdev;
+}
+
+/**
+ * blkdev_trig_get_btb() - Find or create the BTB for a block device.
+ * @path:	The value written to an LED's &link_dev_by_path attribute,
+ *		which should be the path to a special file that represents a
+ *		block device
+ * @len:	The number of characters in &path
+ *
+ * If a new BTB is created, because the block device was not previously linked
+ * to any LEDs, the block device's &linked_leds &sysfs directory is created.
+ *
+ * Context:	Process context.  Caller must hold &blkdev_trig_mutex.
+ * Return:	Pointer to the BTB, error pointer on error.
+ */
+static struct blkdev_trig_bdev *blkdev_trig_get_btb(const char *path,
+						    size_t len)
+{
+	struct block_device *bdev;
+	struct blkdev_trig_bdev *btb;
+	int err;
+
+	bdev = blkdev_trig_get_bdev(path, len);
+	if (IS_ERR(bdev))
+		return ERR_CAST(bdev);
+
+	btb = devres_find(&bdev->bd_device, blkdev_trig_btb_release,
+			  NULL, NULL);
+	if (btb != NULL) {
+		err = 0;
+		goto exit_put_bdev;
+	}
+
+	if (blkdev_trig_next_index == ULONG_MAX) {
+		err = -EOVERFLOW;
+		goto exit_put_bdev;
+	}
+
+	btb = devres_alloc(blkdev_trig_btb_release, sizeof(*btb), GFP_KERNEL);
+	if (btb == NULL) {
+		err = -ENOMEM;
+		goto exit_put_bdev;
+	}
+
+	err = sysfs_create_group(bdev_kobj(bdev), &blkdev_trig_linked_leds);
+	if (err)
+		goto exit_free_btb;
+
+	btb->index = blkdev_trig_next_index++;
+	btb->bdev = bdev;
+	xa_init(&btb->linked_btls);
+
+	/* Populate BTB activity counters */
+	blkdev_trig_update_btb(btb, jiffies);
+
+	devres_add(&bdev->bd_device, btb);
+
+exit_free_btb:
+	if (err)
+		devres_free(btb);
+exit_put_bdev:
+	blkdev_put(bdev, BLKDEV_TRIG_FMODE);
+	return err ? ERR_PTR(err) : btb;
+}
+
+
+/*
+ *
+ *	Activating and deactivating the trigger on an LED
+ *
+ */
+
+/**
+ * blkdev_trig_activate() - Called by the LEDs subsystem when an LED is
+ *	associated with the trigger.
+ * @led:	The LED
+ *
+ * Context:	Process context.  Takes and releases &blkdev_trig_mutex.
+ * Return:	&0 on success, negative &errno on error.
+ */
+static int blkdev_trig_activate(struct led_classdev *led)
+{
+	struct blkdev_trig_led *btl;
+	int err;
+
+	btl = kzalloc(sizeof(*btl), GFP_KERNEL);
+	if (btl == NULL)
+		return -ENOMEM;
+
+	err = mutex_lock_interruptible(&blkdev_trig_mutex);
+	if (err)
+		goto exit_free;
+
+	if (blkdev_trig_next_index == ULONG_MAX) {
+		err = -EOVERFLOW;
+		goto exit_unlock;
+	}
+
+	btl->index = blkdev_trig_next_index++;
+	btl->last_checked = jiffies;
+	btl->mode = -1;  /* set all bits */
+	btl->led = led;
+	btl->blink_msec = BLKDEV_TRIG_BLINK_DEF;
+	btl->check_jiffies = msecs_to_jiffies(BLKDEV_TRIG_CHECK_DEF);
+	xa_init(&btl->linked_btbs);
+
+	hlist_add_head(&btl->all_btls_node, &blkdev_trig_all_btls);
+	led_set_trigger_data(led, btl);
+
+exit_unlock:
+	mutex_unlock(&blkdev_trig_mutex);
+exit_free:
+	if (err)
+		kfree(btl);
+	return err;
+}
+
+/**
+ * blkdev_trig_deactivate() - Called by the the LEDs subsystem when an LED is
+ *	disassociated from the trigger.
+ * @led:	The LED
+ *
+ * The LEDs subsystem also calls this function when an LED associated with the
+ * trigger is removed or when the trigger is unregistered (if the module is
+ * unloaded).
+ *
+ * Context:	Process context.  Takes and releases &blkdev_trig_mutex.
+ */
+static void blkdev_trig_deactivate(struct led_classdev *led)
+{
+	struct blkdev_trig_led *btl = led_get_trigger_data(led);
+	struct blkdev_trig_bdev *btb;
+	unsigned long index;
+
+	mutex_lock(&blkdev_trig_mutex);
+
+	xa_for_each (&btl->linked_btbs, index, btb)
+		blkdev_trig_unlink_norelease(btl, btb);
+
+	hlist_del(&btl->all_btls_node);
+	kfree(btl);
+
+	mutex_unlock(&blkdev_trig_mutex);
+}
+
+
+/*
+ *
+ *	Link-related attribute store functions
+ *
+ */
+
+/**
+ * link_dev_by_path_store() - &link_dev_by_path device attribute store function.
+ * @dev:	The LED device
+ * @attr:	The &link_dev_by_path attribute (&dev_attr_link_dev_by_path)
+ * @buf:	The value written to the attribute, which should be the path to
+ *		a special file that represents a block device to be linked to
+ *		the LED (e.g. ``/dev/sda``)
+ * @count:	The number of characters in &buf
+ *
+ * Context:	Process context.  Takes and releases &blkdev_trig_mutex.
+ * Return:	&count on success, negative &errno on error.
+ */
+static ssize_t link_dev_by_path_store(struct device *dev,
+				      struct device_attribute *attr,
+				      const char *buf, size_t count)
+{
+	struct blkdev_trig_led *btl = led_trigger_get_drvdata(dev);
+	struct blkdev_trig_bdev *btb;
+	int err;
+
+	err = mutex_lock_interruptible(&blkdev_trig_mutex);
+	if (err)
+		return err;
+
+	btb = blkdev_trig_get_btb(buf, count);
+	if (IS_ERR(btb)) {
+		err = PTR_ERR(btb);
+		goto exit_unlock;
+	}
+
+	if (xa_load(&btb->linked_btls, btl->index) != NULL) {
+		err = -EEXIST;
+		goto exit_put_btb;
+	}
+
+	err = blkdev_trig_link(btl, btb);
+
+exit_put_btb:
+	if (err)
+		blkdev_trig_put_btb(btb);
+exit_unlock:
+	mutex_unlock(&blkdev_trig_mutex);
+	return err ? : count;
+}
+
+/**
+ * unlink_dev_by_path_store() - &unlink_dev_by_path device attribute store
+ *	function.
+ * @dev:	The LED device
+ * @attr:	The &unlink_dev_by_path attribute (&dev_attr_unlink_dev_by_path)
+ * @buf:	The value written to the attribute, which should be the path to
+ *		a special file that represents a block device to be unlinked
+ *		from the LED (e.g. ``/dev/sda``)
+ * @count:	The number of characters in &buf
+ *
+ * Context:	Process context.  Takes and releases &blkdev_trig_mutex.
+ * Return:	&count on success, negative &errno on error.
+ */
+static ssize_t unlink_dev_by_path_store(struct device *dev,
+					struct device_attribute *attr,
+					const char *buf, size_t count)
+{
+	struct blkdev_trig_led *btl = led_trigger_get_drvdata(dev);
+	struct block_device *bdev;
+	struct blkdev_trig_bdev *btb;
+	int err;
+
+	bdev = blkdev_trig_get_bdev(buf, count);
+	if (IS_ERR(bdev))
+		return PTR_ERR(bdev);
+
+	err = mutex_lock_interruptible(&blkdev_trig_mutex);
+	if (err)
+		goto exit_put_bdev;
+
+	btb = devres_find(&bdev->bd_device, blkdev_trig_btb_release,
+			  NULL, NULL);
+	if (btb == NULL) {
+		err = -EUNATCH;  /* bdev isn't linked to any LED */
+		goto exit_unlock;
+	}
+
+	if (xa_load(&btb->linked_btls, btl->index) == NULL) {
+		err = -EUNATCH;  /* bdev isn't linked to this LED */
+		goto exit_unlock;
+	}
+
+	blkdev_trig_unlink_norelease(btl, btb);
+
+exit_unlock:
+	mutex_unlock(&blkdev_trig_mutex);
+exit_put_bdev:
+	blkdev_put(bdev, BLKDEV_TRIG_FMODE);
+	return err ? : count;
+}
+
+/**
+ * unlink_dev_by_name_store() - &unlink_dev_by_name device attribute store
+ *	function.
+ * @dev:	The LED device
+ * @attr:	The &unlink_dev_by_name attribute (&dev_attr_unlink_dev_by_name)
+ * @buf:	The value written to the attribute, which should be the kernel
+ *		name of a block device to be unlinked from the LED (e.g.
+ *		``sda``)
+ * @count:	The number of characters in &buf
+ *
+ * Context:	Process context.  Takes and releases &blkdev_trig_mutex.
+ * Return:	&count on success, negative &errno on error.
+ */
+static ssize_t unlink_dev_by_name_store(struct device *dev,
+					struct device_attribute *attr,
+					const char *buf, size_t count)
+{
+	struct blkdev_trig_led *btl = led_trigger_get_drvdata(dev);
+	struct blkdev_trig_bdev *btb;
+	unsigned long index;
+	int err;
+
+	err = mutex_lock_interruptible(&blkdev_trig_mutex);
+	if (err)
+		return err;
+
+	err = -EUNATCH;
+
+	xa_for_each (&btl->linked_btbs, index, btb) {
+
+		if (sysfs_streq(dev_name(&btb->bdev->bd_device), buf)) {
+			blkdev_trig_unlink_norelease(btl, btb);
+			err = 0;
+			break;
+		}
+	}
+
+	mutex_unlock(&blkdev_trig_mutex);
+	return err ? : count;
+}
+
+
+/*
+ *
+ *	Atomic attribute show & store functions
+ *
+ */
+
+/**
+ * blink_time_show() - &blink_time device attribute show function.
+ * @dev:	The LED device
+ * @attr:	The &blink_time attribute (&dev_attr_blink_time)
+ * @buf:	Output buffer
+ *
+ * Writes the value of &blkdev_trig_led.blink_msec to &buf.
+ *
+ * Context:	Process context.
+ * Return:	The number of characters written to &buf.
+ */
+static ssize_t blink_time_show(struct device *dev,
+			       struct device_attribute *attr, char *buf)
+{
+	const struct blkdev_trig_led *btl = led_trigger_get_drvdata(dev);
+
+	return sprintf(buf, "%u\n", READ_ONCE(btl->blink_msec));
+}
+
+/**
+ * blink_time_store() - &blink_time device attribute store function.
+ * @dev:	The LED device
+ * @attr:	The &blink_time attribute (&dev_attr_blink_time)
+ * @buf:	The new value (as written to the &sysfs attribute)
+ * @count:	The number of characters in &buf
+ *
+ * Sets &blkdev_trig_led.blink_msec to the value in &buf.
+ *
+ * Context:	Process context.
+ * Return:	&count on success, negative &errno on error.
+ */
+static ssize_t blink_time_store(struct device *dev,
+				struct device_attribute *attr,
+				const char *buf, size_t count)
+{
+	struct blkdev_trig_led *btl = led_trigger_get_drvdata(dev);
+	unsigned int value;
+	int err;
+
+	err = kstrtouint(buf, 0, &value);
+	if (err)
+		return err;
+
+	if (value < BLKDEV_TRIG_BLINK_MIN || value > BLKDEV_TRIG_BLINK_MAX)
+		return -ERANGE;
+
+	WRITE_ONCE(btl->blink_msec, value);
+	return count;
+}
+
+/**
+ * check_interval_show() - &check_interval device attribute show function.
+ * @dev:	The LED device
+ * @attr:	The &check_interval attribute (&dev_attr_check_interval)
+ * @buf:	Output buffer
+ *
+ * Writes the value of &blkdev_trig_led.check_jiffies (converted to
+ * milliseconds) to &buf.
+ *
+ * Context:	Process context.
+ * Return:	The number of characters written to &buf.
+ */
+static ssize_t check_interval_show(struct device *dev,
+				   struct device_attribute *attr, char *buf)
+{
+	struct blkdev_trig_led *btl = led_trigger_get_drvdata(dev);
+
+	return sprintf(buf, "%u\n",
+		       jiffies_to_msecs(READ_ONCE(btl->check_jiffies)));
+}
+
+/**
+ * check_interval_store() - &check_interval device attribute store function
+ * @dev:	The LED device
+ * @attr:	The &check_interval attribute (&dev_attr_check_interval)
+ * @buf:	The new value (as written to the &sysfs attribute)
+ * @count:	The number of characters in &buf
+ *
+ * Sets &blkdev_trig_led.check_jiffies to the value in &buf (after converting
+ * from milliseconds).
+ *
+ * Context:	Process context.
+ * Return:	&count on success, negative &errno on error.
+ */
+static ssize_t check_interval_store(struct device *dev,
+				    struct device_attribute *attr,
+				    const char *buf, size_t count)
+{
+	struct blkdev_trig_led *led = led_trigger_get_drvdata(dev);
+	unsigned int value;
+	int err;
+
+	err = kstrtouint(buf, 0, &value);
+	if (err)
+		return err;
+
+	if (value < BLKDEV_TRIG_CHECK_MIN || value > BLKDEV_TRIG_CHECK_MAX)
+		return -ERANGE;
+
+	WRITE_ONCE(led->check_jiffies, msecs_to_jiffies(value));
+
+	return count;
+}
+
+/**
+ * blkdev_trig_mode_show() - Helper for boolean attribute show functions.
+ * @led:	The LED
+ * @buf:	Output buffer
+ * @bit:	Which bit to show
+ *
+ * Context:	Process context.
+ * Return:	The number of characters written to &buf.
+ */
+static int blkdev_trig_mode_show(const struct blkdev_trig_led *led, char *buf,
+				 enum stat_group bit)
+{
+	return sprintf(buf, READ_ONCE(led->mode) & (1 << bit) ? "Y\n" : "N\n");
+}
+
+/**
+ * blkdev_trig_mode_store() - Helper for boolean attribute store functions.
+ * @led:	The LED
+ * @buf:	The new value (as written to the &sysfs attribute)
+ * @count:	The number of characters in &buf
+ * @bit:	Which bit to set
+ *
+ * Context:	Process context.
+ * Return:	&count on success, negative &errno on error.
+ */
+static int blkdev_trig_mode_store(struct blkdev_trig_led *led,
+				  const char *buf, size_t count,
+				  enum stat_group bit)
+{
+	bool set;
+	int err;
+
+	err = kstrtobool(buf, &set);
+	if (err)
+		return err;
+
+	if (set)
+		set_bit(bit, &led->mode);
+	else
+		clear_bit(bit, &led->mode);
+
+	return count;
+}
+
+/**
+ * blink_on_read_show() - &blink_on_read device attribute show function.
+ * @dev:	The LED device
+ * @attr:	The &blink_on_read attribute (&dev_attr_blink_on_read)
+ * @buf:	Output buffer
+ *
+ * Writes ``Y`` or ``N`` to &buf, depending on whether the &STAT_READ bit in
+ * &blkdev_trig_led.mode is set or cleared.
+ *
+ * Context:	Process context.
+ * Return:	The number of characters written to &buf.
+ */
+static ssize_t blink_on_read_show(struct device *dev,
+				  struct device_attribute *attr, char *buf)
+{
+	return blkdev_trig_mode_show(led_trigger_get_drvdata(dev),
+				     buf, STAT_READ);
+}
+
+/**
+ * blink_on_read_store() - &blink_on_read device attribute store function.
+ * @dev:	The LED device
+ * @attr:	The &blink_on_read attribute (&dev_attr_blink_on_read)
+ * @buf:	The new value (as written to the &sysfs attribute)
+ * @count:	The number of characters in &buf
+ *
+ * Sets the &STAT_READ bit in &blkdev_trig_led.mode to the value in &buf
+ * (interpretted as a boolean).
+ *
+ * Context:	Process context.
+ * Return:	&count on success, negative &errno on error.
+ */
+static ssize_t blink_on_read_store(struct device *dev,
+				   struct device_attribute *attr,
+				   const char *buf, size_t count)
+{
+	return blkdev_trig_mode_store(led_trigger_get_drvdata(dev),
+				      buf, count, STAT_READ);
+}
+
+/**
+ * blink_on_write_show() - &blink_on_write device attribute show function.
+ * @dev:	The LED device
+ * @attr:	The &blink_on_write attribute (&dev_attr_blink_on_write)
+ * @buf:	Output buffer
+ *
+ * Writes ``Y`` or ``N`` to &buf, depending on whether the &STAT_WRITE bit in
+ * in &blkdev_trig_led.mode is set or cleared.
+ *
+ * Context:	Process context.
+ * Return:	The number of characters written to &buf.
+ */
+static ssize_t blink_on_write_show(struct device *dev,
+				   struct device_attribute *attr, char *buf)
+{
+	return blkdev_trig_mode_show(led_trigger_get_drvdata(dev),
+				     buf, STAT_WRITE);
+}
+
+/**
+ * blink_on_write_store() - &blink_on_write device attribute store function.
+ * @dev:	The LED device
+ * @attr:	The &blink_on_write attribute (&dev_attr_blink_on_write)
+ * @buf:	The new value (as written to the &sysfs attribute)
+ * @count:	The number of characters in &buf
+ *
+ * Sets the &STAT_WRITE bit in &blkdev_trig_led.mode to the value in &buf
+ * (interpretted as a boolean).
+ *
+ * Context:	Process context.
+ * Return:	&count on success, negative &errno on error.
+ */
+static ssize_t blink_on_write_store(struct device *dev,
+				    struct device_attribute *attr,
+				    const char *buf, size_t count)
+{
+	return blkdev_trig_mode_store(led_trigger_get_drvdata(dev),
+				      buf, count, STAT_WRITE);
+}
+
+/**
+ * blink_on_flush_show() - &blink_on_flush device attribute show function.
+ * @dev:	The LED device
+ * @attr:	The &blink_on_flush attribute (&dev_attr_blink_on_flush)
+ * @buf:	Output buffer
+ *
+ * Writes ``Y`` or ``N`` to &buf, depending whether the &STAT_FLUSH bit in
+ * &blkdev_trig_led.mode is set or cleared.
+ *
+ * Context:	Process context.
+ * Return:	The number of characters written to &buf.
+ */
+static ssize_t blink_on_flush_show(struct device *dev,
+				   struct device_attribute *attr, char *buf)
+{
+	return blkdev_trig_mode_show(led_trigger_get_drvdata(dev),
+				     buf, STAT_FLUSH);
+}
+
+/**
+ * blink_on_flush_store() - &blink_on_flush device attribute store function.
+ * @dev:	The LED device
+ * @attr:	The &blink_on_flush attribute (&dev_attr_blink_on_flush)
+ * @buf:	The new value (as written to the &sysfs attribute)
+ * @count:	The number of characters in &buf
+ *
+ * Sets the &STAT_FLUSH bit in &blkdev_trig_led.mode to the value in &buf
+ * (interpretted as a boolean).
+ *
+ * Context:	Process context.
+ * Return:	&count on success, negative &errno on error.
+ */
+static ssize_t blink_on_flush_store(struct device *dev,
+				    struct device_attribute *attr,
+				    const char *buf, size_t count)
+{
+	return blkdev_trig_mode_store(led_trigger_get_drvdata(dev),
+				      buf, count, STAT_FLUSH);
+}
+
+/**
+ * blink_on_discard_show() - &blink_on_discard device attribute show function.
+ * @dev:	The LED device
+ * @attr:	The &blink_on_discard attribute (&dev_attr_blink_on_discard)
+ * @buf:	Output buffer
+ *
+ * Writes ``Y`` or ``N`` to &buf, depending on whether the &STAT_DISCARD bit in
+ * &blkdev_trig_led.mode is set or cleared.
+ *
+ * Context:	Process context.
+ * Return:	The number of characters written to &buf.
+ */
+static ssize_t blink_on_discard_show(struct device *dev,
+				     struct device_attribute *attr, char *buf)
+{
+	return blkdev_trig_mode_show(led_trigger_get_drvdata(dev),
+				     buf, STAT_DISCARD);
+}
+
+/**
+ * blink_on_discard_store() - &blink_on_discard device attribute store function.
+ * @dev:	The LED device
+ * @attr:	The &blink_on_discard attribute (&dev_attr_blink_on_discard)
+ * @buf:	The new value (as written to the &sysfs attribute)
+ * @count:	The number of characters in &buf
+ *
+ * Sets the &STAT_DISCARD bit in &blkdev_trig_led.mode to the value in &buf
+ * (interpretted as a boolean).
+ *
+ * Context:	Process context.
+ * Return:	&count on success, negative &errno on error.
+ */
+static ssize_t blink_on_discard_store(struct device *dev,
+				      struct device_attribute *attr,
+				      const char *buf, size_t count)
+{
+	return blkdev_trig_mode_store(led_trigger_get_drvdata(dev),
+				      buf, count, STAT_DISCARD);
+}
+
+/* Device attributes */
+static DEVICE_ATTR_WO(link_dev_by_path);
+static DEVICE_ATTR_WO(unlink_dev_by_path);
+static DEVICE_ATTR_WO(unlink_dev_by_name);
+static DEVICE_ATTR_RW(blink_time);
+static DEVICE_ATTR_RW(check_interval);
+static DEVICE_ATTR_RW(blink_on_read);
+static DEVICE_ATTR_RW(blink_on_write);
+static DEVICE_ATTR_RW(blink_on_flush);
+static DEVICE_ATTR_RW(blink_on_discard);
+
+/* Device attributes in LED directory (/sys/class/leds/<led>/...) */
+static struct attribute *blkdev_trig_attrs[] = {
+	&dev_attr_link_dev_by_path.attr,
+	&dev_attr_unlink_dev_by_path.attr,
+	&dev_attr_unlink_dev_by_name.attr,
+	&dev_attr_blink_time.attr,
+	&dev_attr_check_interval.attr,
+	&dev_attr_blink_on_read.attr,
+	&dev_attr_blink_on_write.attr,
+	&dev_attr_blink_on_flush.attr,
+	&dev_attr_blink_on_discard.attr,
+	NULL
+};
+
+/* Unnamed attribute group == no subdirectory */
+static const struct attribute_group blkdev_trig_attr_group = {
+	.attrs	= blkdev_trig_attrs,
+};
+
+/* Attribute groups for the trigger */
+static const struct attribute_group *blkdev_trig_attr_groups[] = {
+	&blkdev_trig_attr_group,   /* /sys/class/leds/<led>/... */
+	&blkdev_trig_linked_devs,  /* /sys/class/leds/<led>/linked_devices/ */
+	NULL
+};
+
+/* Trigger registration data */
+static struct led_trigger blkdev_trig_trigger = {
+	.name		= "blkdev",
+	.activate	= blkdev_trig_activate,
+	.deactivate	= blkdev_trig_deactivate,
+	.groups		= blkdev_trig_attr_groups,
+};
+
+/**
+ * blkdev_trig_init() - Block device LED trigger initialization.
+ *
+ * Registers the ``blkdev`` LED trigger.
+ *
+ * Return:	&0 on success, negative &errno on failure.
+ */
+static int __init blkdev_trig_init(void)
+{
+	return led_trigger_register(&blkdev_trig_trigger);
+}
+module_init(blkdev_trig_init);
+
+/**
+ * blkdev_trig_exit() - Block device LED trigger module exit.
+ *
+ * Unregisters the ``blkdev`` LED trigger.
+ */
+static void __exit blkdev_trig_exit(void)
+{
+	led_trigger_unregister(&blkdev_trig_trigger);
+}
+module_exit(blkdev_trig_exit);
+
+MODULE_DESCRIPTION("Block device LED trigger");
+MODULE_AUTHOR("Ian Pilcher <arequipeno@gmail.com>");
+MODULE_LICENSE("GPL v2");
-- 
2.37.3.485.gbe1a02a17e


From e2ac04e0534857f9462b6809e4af5394da629ca6 Mon Sep 17 00:00:00 2001
From: Ian Pilcher <arequipeno@gmail.com>
Date: Mon, 26 Sep 2022 11:25:02 -0500
Subject: [PATCH 41/41] docs: Add block device (blkdev) LED trigger
 documentation

Add Documentation/ABI/testing/sysfs-class-led-trigger-blkdev to
document:

  * /sys/class/leds/<led>/blink_time
  * /sys/class/leds/<led>/check_interval
  * /sys/class/leds/<led>/blink_on_{read,write,discard,flush}
  * /sys/class/leds/<led>/link_dev_by_path
  * /sys/class/leds/<led>/unlink_dev_by_path
  * /sys/class/leds/<led>/unlink_dev_by_name
  * /sys/class/leds/<led>/linked_devices

Add /sys/block/<disk>/linked_leds to
Documentation/ABI/stable/sysfs-block.

Add overview in Documentation/leds/ledtrig-blkdev.rst.

Signed-off-by: Ian Pilcher <arequipeno@gmail.com>
---
 Documentation/ABI/stable/sysfs-block          |  10 ++
 .../testing/sysfs-class-led-trigger-blkdev    |  78 +++++++++
 Documentation/leds/index.rst                  |   1 +
 Documentation/leds/ledtrig-blkdev.rst         | 158 ++++++++++++++++++
 4 files changed, 247 insertions(+)
 create mode 100644 Documentation/ABI/testing/sysfs-class-led-trigger-blkdev
 create mode 100644 Documentation/leds/ledtrig-blkdev.rst

diff --git a/Documentation/ABI/stable/sysfs-block b/Documentation/ABI/stable/sysfs-block
index e8797cd09..46a8820bb 100644
--- a/Documentation/ABI/stable/sysfs-block
+++ b/Documentation/ABI/stable/sysfs-block
@@ -101,6 +101,16 @@ Description:
 		devices that support receiving integrity metadata.
 
 
+What:		/sys/block/<disk>/linked_leds
+Date:		October 2022
+Contact:	Ian Pilcher <arequipeno@gmail.com>
+Description:
+		Directory that contains symbolic links to all LEDs that
+		are associated with (linked to) this block device by the
+		blkdev LED trigger.  Only present when at least one LED
+		is linked.  (See Documentation/leds/ledtrig-blkdev.rst.)
+
+
 What:		/sys/block/<disk>/<partition>/alignment_offset
 Date:		April 2009
 Contact:	Martin K. Petersen <martin.petersen@oracle.com>
diff --git a/Documentation/ABI/testing/sysfs-class-led-trigger-blkdev b/Documentation/ABI/testing/sysfs-class-led-trigger-blkdev
new file mode 100644
index 000000000..45275eb0b
--- /dev/null
+++ b/Documentation/ABI/testing/sysfs-class-led-trigger-blkdev
@@ -0,0 +1,78 @@
+What:		/sys/class/leds/<led>/blink_time
+Date:		October 2022
+Contact:	Ian Pilcher <arequipeno@gmail.com>
+Description:
+		Time (in milliseconds) that the LED will be on during a single
+		"blink".
+
+What:		/sys/class/leds/<led>/check_interval
+Date:		October 2022
+Contact:	Ian Pilcher <arequipeno@gmail.com>
+Description:
+		Interval (in milliseconds) between checks of the block devices
+		linked to this LED.  The LED will be blinked if the correct type
+		of activity (see blink_on_{read,write,discard,flush} attributes)
+		has occurred on any of the linked devices since the previous
+		check.
+
+What:		/sys/class/leds/<led>/blink_on_read
+Date:		October 2022
+Contact:	Ian Pilcher <arequipeno@gmail.com>
+Description:
+		Boolean that determines whether the LED will blink in response
+		to read activity on any of its linked block devices.
+
+What:		/sys/class/leds/<led>/blink_on_write
+Date:		October 2022
+Contact:	Ian Pilcher <arequipeno@gmail.com>
+Description:
+		Boolean that determines whether the LED will blink in response
+		to write activity on any of its linked block devices.
+
+What:		/sys/class/leds/<led>/blink_on_discard
+Date:		October 2022
+Contact:	Ian Pilcher <arequipeno@gmail.com>
+Description:
+		Boolean that determines whether the LED will blink in response
+		to discard activity on any of its linked block devices.
+
+What:		/sys/class/leds/<led>/blink_on_flush
+Date:		October 2022
+Contact:	Ian Pilcher <arequipeno@gamil.com>
+Description:
+		Boolean that determines whether the LED will blink in response
+		to cache flush activity on any of its linked block devices.
+
+What:		/sys/class/leds/<led>/link_dev_by_path
+Date:		October 2022
+Contact:	Ian Pilcher <arequipeno@gmail.com>
+Description:
+		Associate a block device with this LED by writing the path to
+		the device special file (e.g. /dev/sda) to this attribute.
+		Symbolic links are followed.
+
+What:		/sys/class/leds/<led>/unlink_dev_by_path
+Date:		October 2022
+Contact:	Ian Pilcher <arequipeno@gmail.com>
+Description:
+		Remove the association between this LED and a block device by
+		writing the path to the device special file (e.g. /dev/sda) to
+		this attribute.  Symbolic links are followed.
+
+What:		/sys/class/leds/<led>/unlink_dev_by_name
+Date:		October 2022
+Contact:	Ian Pilcher <arequipeno@gmail.com>
+Description:
+		Remove the association between this LED and a block device by
+		writing the kernel name of the device (e.g. sda) to this
+		attribute.
+
+What:		/sys/class/leds/<led>/linked_devices
+Date:		October 2022
+Contact:	Ian Pilcher <arequipeno@gmail.com>
+Description:
+		Directory containing links to all block devices that are
+		associated with this LED.  (Note that the names of the
+		symbolic links in this directory are *kernel* names, which
+		may not match the device special file paths written to
+		link_device and unlink_device.)
diff --git a/Documentation/leds/index.rst b/Documentation/leds/index.rst
index e5d63b940..e3c24e468 100644
--- a/Documentation/leds/index.rst
+++ b/Documentation/leds/index.rst
@@ -10,6 +10,7 @@ LEDs
    leds-class
    leds-class-flash
    leds-class-multicolor
+   ledtrig-blkdev
    ledtrig-oneshot
    ledtrig-transient
    ledtrig-usbport
diff --git a/Documentation/leds/ledtrig-blkdev.rst b/Documentation/leds/ledtrig-blkdev.rst
new file mode 100644
index 000000000..9ff5b99de
--- /dev/null
+++ b/Documentation/leds/ledtrig-blkdev.rst
@@ -0,0 +1,158 @@
+.. SPDX-License-Identifier: GPL-2.0
+
+=================================
+Block Device (blkdev) LED Trigger
+=================================
+
+Available when ``CONFIG_LEDS_TRIGGER_BLKDEV=y`` or
+``CONFIG_LEDS_TRIGGER_BLKDEV=m``.
+
+See also:
+
+* ``Documentation/ABI/testing/sysfs-class-led-trigger-blkdev``
+* ``Documentation/ABI/stable/sysfs-block`` (``/sys/block/<disk>/linked_leds``)
+
+Overview
+========
+
+.. note::
+	The examples below use ``<LED>`` to refer to the name of a
+	system-specific LED.  If no suitable LED is available on a test
+	system (in a virtual machine, for example), it is possible to
+	use a userspace LED.  (See ``Documentation/leds/uleds.rst``.)
+
+Verify that the ``blkdev`` LED trigger is available::
+
+	# grep blkdev /sys/class/leds/<LED>/trigger
+	... rfkill-none blkdev
+
+(If the previous command produces no output, you may need to load the trigger
+module - ``modprobe ledtrig_blkdev``.  If the module is not available, check
+the value of ``CONFIG_LEDS_TRIGGER_BLKDEV`` in your kernel configuration.)
+
+Associate the LED with the ``blkdev`` LED trigger::
+
+	# echo blkdev > /sys/class/leds/<LED>/trigger
+
+	# cat /sys/class/leds/<LED>/trigger
+	... rfkill-none [blkdev]
+
+Note that several new device attributes are available in the
+``/sys/class/leds/<LED>`` directory.
+
+* ``link_dev_by_path``, ``unlink_dev_by_path``, and ``unlink_dev_by_name`` are
+  used to manage the set of block devices associated with this LED.  The LED
+  will blink when activity occurs on any of its linked devices.
+
+* ``blink_on_read``, ``blink_on_write``, ``blink_on_discard``, and
+  ``blink_on_flush`` are boolean values that determine whether the LED will
+  blink when a particular type of activity is detected on one of its linked
+  block devices.
+
+* ``blink_time`` is the duration (in milliseconds) of each blink of this LED.
+  (The minimum value is 10 milliseconds.)
+
+* ``check_interval`` is the frequency (in milliseconds) with which block devices
+  linked to this LED will be checked for activity and the LED blinked (if the
+  correct type of activity has occurred).
+
+* The ``linked_devices`` directory will contain a symbolic link to every device
+  that is associated with this LED.
+
+Link a block device to the LED::
+
+	# echo /dev/sda > /sys/class/leds/<LED>/link_dev_by_path
+
+	# ls /sys/class/leds/<LED>/linked_devices
+	sda
+
+(The value written to ``link_dev_by_path`` must be the path of the device
+special file, such as ``/dev/sda``, that represents the block device - or the
+path of a symbolic link to such a device special file.)
+
+Activity on the device will now cause the LED to blink.  The duration of each
+blink (in milliseconds) can be adjusted by setting
+``/sys/class/leds/<LED>/blink_time``.  (But see **check_interval and
+blink_time** below.)
+
+Associate a second device with the LED::
+
+	# echo /dev/sdb > /sys/class/leds/<LED>/link_dev_by_path
+
+	# ls /sys/class/leds/<LED>/linked_devices
+	sda  sdb
+
+When a block device is linked to one or more LEDs, the LEDs are linked from
+the device's ``linked_leds`` directory::
+
+	# ls /sys/class/block/sd{a,b}/linked_leds
+	/sys/class/block/sda/linked_leds:
+	<LED>
+
+	/sys/class/block/sdb/linked_leds:
+	<LED>
+
+(The ``linked_leds`` directory only exists when the block device is linked to
+at least one LED.)
+
+``check_interval`` and ``blink_time``
+=====================================
+
+* By default, linked block devices are checked for activity every 100
+  milliseconds.  This frequency can be changed for an LED via the
+  ``/sys/class/leds/<led>/check_interval`` attribute.  (The minimum value is 25
+  milliseconds.)
+
+* All block devices associated with an LED are checked for activity every
+  ``check_interval`` milliseconds, and a blink is triggered if the correct type
+  of activity (as determined by the LED's ``blink_on_*`` attributes) is
+  detected.  The duration of an LED's blink is determined by its ``blink_time``
+  attribute.  Thus (when the correct type of activity is detected), the LED will
+  be on for ``blink_time`` milliseconds and off for
+  ``check_interval - blink_time`` milliseconds.
+
+* The LED subsystem ignores new blink requests for an LED that is already in
+  in the process of blinking, so setting a ``blink_time`` greater than or equal
+  to ``check_interval`` will cause some blinks to be missed.
+
+* Because of processing times, scheduling latencies, etc., avoiding missed
+  blinks actually requires a difference of at least a few milliseconds between
+  the ``blink_time`` and ``check_interval``.  The required difference is likely
+  to vary from system to system.  As a  reference, a Thecus N5550 NAS requires a
+  difference of 7 milliseconds (e.g. ``check_interval == 100``,
+  ``blink_time == 93``).
+
+* The default values (``check_interval == 100``, ``blink_time == 75``) cause the
+  LED associated with a continuously active device to blink rapidly.  For a more
+  "always on" effect, increase the ``blink_time`` (but not too much; see the
+  previous bullet).
+
+Other Notes
+===========
+
+* Many (possibly all) types of block devices work with this trigger, including:
+
+  * SCSI (including SATA and USB) hard disk drives and SSDs
+  * SCSI (including SATA and USB) optical drives
+  * NVMe SSDs
+  * SD cards
+  * loopback block devices (``/dev/loop*``)
+  * device mapper devices, such as LVM logical volumes
+  * MD RAID devices
+  * zRAM compressed RAM-disks
+  * partitions on block devices that support them
+
+* The names of the symbolic links in ``/sys/class/leds/<LED>/linked_devices``
+  are **kernel** names, which may not match the paths used for
+  ``link_dev_by_path`` and ``unlink_dev_by_path``.  This is most likely when a
+  symbolic link is used to refer to the device (as is common with logical
+  volumes), but it can be true for any device, because nothing prevents the
+  creation of device special files with arbitrary names (e.g.
+  ``sudo mknod /foo b 8 0``).
+
+  Kernel names can be used to unlink block devices from LEDs by writing them to
+  the LED's ``unlink_dev_by_name`` attribute.
+
+* The ``blkdev`` LED trigger supports many-to-many device/LED associations.
+  A device can be associated with multiple LEDs, and an LED can be associated
+  with multiple devices.
-- 
2.37.3.485.gbe1a02a17e

