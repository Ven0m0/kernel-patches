From a093fbcb68d6d505c66d10a585952f2c479be22c Mon Sep 17 00:00:00 2001
From: Piotr Gorski <lucjan.lucjanov@gmail.com>
Date: Fri, 24 Jun 2022 20:19:21 +0200
Subject: [PATCH 34/34] lrng-5.18: update to the latest git HEAD

Signed-off-by: Piotr Gorski <lucjan.lucjanov@gmail.com>
---
 drivers/char/lrng/lrng_drng_mgr.c             |   3 +-
 drivers/char/lrng/lrng_drng_mgr.h             |   1 +
 drivers/char/lrng/lrng_es_mgr.c               |   1 -
 .../char/lrng/lrng_interface_random_kernel.c  | 120 ------------------
 .../char/lrng/lrng_interface_random_kernel.h  |   4 -
 drivers/char/lrng/lrng_proc.c                 |   3 +-
 6 files changed, 4 insertions(+), 128 deletions(-)

diff --git a/drivers/char/lrng/lrng_drng_mgr.c b/drivers/char/lrng/lrng_drng_mgr.c
index d92559177..a0d50ddcc 100644
--- a/drivers/char/lrng/lrng_drng_mgr.c
+++ b/drivers/char/lrng/lrng_drng_mgr.c
@@ -263,8 +263,7 @@ static void lrng_drng_seed(struct lrng_drng *drng)
 		 * If no-one is waiting for the DRNG, seed the atomic DRNG
 		 * directly from the entropy sources.
 		 */
-		if (!wq_has_sleeper(&lrng_init_wait) &&
-		    !lrng_ready_chain_has_sleeper())
+		if (!wq_has_sleeper(&lrng_init_wait))
 			lrng_drng_atomic_seed_es();
 		else
 			lrng_init_ops(NULL);
diff --git a/drivers/char/lrng/lrng_drng_mgr.h b/drivers/char/lrng/lrng_drng_mgr.h
index 3eb20e705..ed3fac184 100644
--- a/drivers/char/lrng/lrng_drng_mgr.h
+++ b/drivers/char/lrng/lrng_drng_mgr.h
@@ -58,6 +58,7 @@ int lrng_drng_alloc_common(struct lrng_drng *drng,
 			   const struct lrng_drng_cb *crypto_cb);
 int lrng_drng_initalize(void);
 bool lrng_sp80090c_compliant(void);
+bool lrng_ntg1_compliant(void);
 bool lrng_get_available(void);
 void lrng_drng_reset(struct lrng_drng *drng);
 void lrng_drng_inject(struct lrng_drng *drng, const u8 *inbuf, u32 inbuflen,
diff --git a/drivers/char/lrng/lrng_es_mgr.c b/drivers/char/lrng/lrng_es_mgr.c
index 8cf80fa9e..5bec39d9e 100644
--- a/drivers/char/lrng/lrng_es_mgr.c
+++ b/drivers/char/lrng/lrng_es_mgr.c
@@ -218,7 +218,6 @@ static void lrng_set_operational(void)
 	 */
 	if (lrng_state.lrng_fully_seeded) {
 		lrng_state.lrng_operational = true;
-		lrng_process_ready_list();
 		lrng_init_wakeup();
 		pr_info("LRNG fully operational\n");
 	}
diff --git a/drivers/char/lrng/lrng_interface_random_kernel.c b/drivers/char/lrng/lrng_interface_random_kernel.c
index 81060ba98..a100ae81f 100644
--- a/drivers/char/lrng/lrng_interface_random_kernel.c
+++ b/drivers/char/lrng/lrng_interface_random_kernel.c
@@ -19,10 +19,6 @@
 #include "lrng_interface_dev_common.h"
 #include "lrng_interface_random_kernel.h"
 
-static RAW_NOTIFIER_HEAD(lrng_ready_chain);
-static DEFINE_SPINLOCK(lrng_ready_chain_lock);
-static unsigned int lrng_ready_chain_used = 0;
-
 /********************************** Helper ***********************************/
 
 int __init random_init(const char *command_line)
@@ -33,33 +29,6 @@ int __init random_init(const char *command_line)
 	return ret;
 }
 
-bool lrng_ready_chain_has_sleeper(void)
-{
-	return !!lrng_ready_chain_used;
-}
-
-/*
- * lrng_process_ready_list() - Ping all kernel internal callers waiting until
- * the DRNG is completely initialized to inform that the DRNG reached that
- * seed level.
- *
- * When the SP800-90B testing is enabled, the ping only happens if the SP800-90B
- * startup health tests are completed. This implies that kernel internal
- * callers always have an SP800-90B compliant noise source when being
- * pinged.
- */
-void lrng_process_ready_list(void)
-{
-	unsigned long flags;
-
-	if (!lrng_state_operational())
-		return;
-
-	spin_lock_irqsave(&lrng_ready_chain_lock, flags);
-	raw_notifier_call_chain(&lrng_ready_chain, 0, NULL);
-	spin_unlock_irqrestore(&lrng_ready_chain_lock, flags);
-}
-
 /************************ LRNG kernel input interfaces ************************/
 
 /*
@@ -157,58 +126,6 @@ void add_interrupt_randomness(int irq) { }
 EXPORT_SYMBOL(add_interrupt_randomness);
 #endif
 
-/*
- * unregister_random_ready_notifier() - Delete a previously registered readiness
- * callback function.
- *
- * @nb: callback definition that was registered initially
- */
-int unregister_random_ready_notifier(struct notifier_block *nb)
-{
-	unsigned long flags;
-	int ret;
-
-	spin_lock_irqsave(&lrng_ready_chain_lock, flags);
-	ret = raw_notifier_chain_unregister(&lrng_ready_chain, nb);
-	spin_unlock_irqrestore(&lrng_ready_chain_lock, flags);
-
-	if (!ret && lrng_ready_chain_used)
-		lrng_ready_chain_used--;
-
-	return ret;
-}
-EXPORT_SYMBOL(unregister_random_ready_notifier);
-
-/*
- * register_random_ready_notifier() - Add a callback function that will be
- * invoked when the DRNG is fully initialized and seeded.
- *
- * @nb: callback definition to be invoked when the LRNG is seeded
- *
- * Return:
- * * 0 if callback is successfully added
- * * -EALREADY if pool is already initialised (callback not called)
- */
-int register_random_ready_notifier(struct notifier_block *nb)
-{
-	unsigned long flags;
-	int err = -EALREADY;
-
-	if (likely(lrng_state_operational()))
-		return err;
-
-	spin_lock_irqsave(&lrng_ready_chain_lock, flags);
-	if (!lrng_state_operational())
-		err = raw_notifier_chain_register(&lrng_ready_chain, nb);
-	spin_unlock_irqrestore(&lrng_ready_chain_lock, flags);
-
-	if (!err)
-		lrng_ready_chain_used++;
-
-	return err;
-}
-EXPORT_SYMBOL(register_random_ready_notifier);
-
 #if IS_ENABLED(CONFIG_VMGENID)
 static BLOCKING_NOTIFIER_HEAD(lrng_vmfork_chain);
 
@@ -278,43 +195,6 @@ int wait_for_random_bytes(void)
 }
 EXPORT_SYMBOL(wait_for_random_bytes);
 
-/*
- * get_random_bytes_arch() - This function will use the architecture-specific
- * hardware random number generator if it is available.
- *
- * The arch-specific hw RNG will almost certainly be faster than what we can
- * do in software, but it is impossible to verify that it is implemented
- * securely (as opposed, to, say, the AES encryption of a sequence number using
- * a key known by the NSA).  So it's useful if we need the speed, but only if
- * we're willing to trust the hardware manufacturer not to have put in a back
- * door.
- *
- * @buf: buffer allocated by caller to store the random data in
- * @nbytes: length of outbuf
- *
- * Return: number of bytes filled in.
- */
-size_t __must_check get_random_bytes_arch(void *buf, size_t nbytes)
-{
-	size_t left = nbytes;
-	u8 *p = buf;
-
-	while (left) {
-		unsigned long v;
-		size_t chunk = min_t(size_t, left, sizeof(unsigned long));
-
-		if (!arch_get_random_long(&v))
-			break;
-
-		memcpy(p, &v, chunk);
-		p += chunk;
-		left -= chunk;
-	}
-
-	return nbytes - left;
-}
-EXPORT_SYMBOL(get_random_bytes_arch);
-
 /*
  * Returns whether or not the LRNG has been seeded.
  *
diff --git a/drivers/char/lrng/lrng_interface_random_kernel.h b/drivers/char/lrng/lrng_interface_random_kernel.h
index 763ec1a63..f4d09d1fb 100644
--- a/drivers/char/lrng/lrng_interface_random_kernel.h
+++ b/drivers/char/lrng/lrng_interface_random_kernel.h
@@ -7,12 +7,8 @@
 #define _LRNG_INTERFACE_RANDOM_H
 
 #ifdef CONFIG_LRNG_RANDOM_IF
-void lrng_process_ready_list(void);
-bool lrng_ready_chain_has_sleeper(void);
 void invalidate_batched_entropy(void);
 #else /* CONFIG_LRNG_RANDOM_IF */
-static inline bool lrng_ready_chain_has_sleeper(void) { return false; }
-static inline void lrng_process_ready_list(void) { }
 static inline void invalidate_batched_entropy(void) { }
 #endif /* CONFIG_LRNG_RANDOM_IF */
 
diff --git a/drivers/char/lrng/lrng_proc.c b/drivers/char/lrng/lrng_proc.c
index 0be848c6d..92329cc6e 100644
--- a/drivers/char/lrng/lrng_proc.c
+++ b/drivers/char/lrng/lrng_proc.c
@@ -34,7 +34,7 @@ static int lrng_proc_type_show(struct seq_file *m, void *v)
 		 "DRNG name: %s\n"
 		 "LRNG security strength in bits: %d\n"
 		 "Number of DRNG instances: %u\n"
-		 "Standards compliance: %s\n"
+		 "Standards compliance: %s%s\n"
 		 "LRNG minimally seeded: %s\n"
 		 "LRNG fully seeded: %s\n"
 		 "LRNG entropy level: %u\n",
@@ -42,6 +42,7 @@ static int lrng_proc_type_show(struct seq_file *m, void *v)
 		 lrng_security_strength(),
 		 numa_drngs,
 		 lrng_sp80090c_compliant() ? "SP800-90C " : "",
+		 lrng_ntg1_compliant() ? "NTG.1 " : "",
 		 lrng_state_min_seeded() ? "true" : "false",
 		 lrng_state_fully_seeded() ? "true" : "false",
 		 lrng_avail_entropy());
-- 
2.37.0.rc0.15.g3b9a5a33c2

