From 1d8c1897dc88333c4d92b363dda28f5fe72302b6 Mon Sep 17 00:00:00 2001
From: mions1 <simone.mione1@gmail.com>
Date: Thu, 13 Feb 2020 13:03:56 +0100
Subject: [PATCH 20/56] block, bfq, DEBUG: print all pids associated with a
 shared queue

Print the pid of all tasks associated with a queue. In particular,
print multiple pids in case of a shared queue.
To this goal, replace the 'pid' field of bfq_queue with a list.
---
 block/bfq-iosched.c   | 68 ++++++++++++++++++++++++++++++++-----------
 block/bfq-iosched.h   | 28 +++++++++++-------
 include/linux/sched.h |  2 ++
 3 files changed, 71 insertions(+), 27 deletions(-)

diff --git a/block/bfq-iosched.c b/block/bfq-iosched.c
index fd48fec86..579cd0169 100644
--- a/block/bfq-iosched.c
+++ b/block/bfq-iosched.c
@@ -593,9 +593,10 @@ bfq_rq_pos_tree_lookup(struct bfq_data *bfqd, struct rb_root *root,
 	if (rb_link)
 		*rb_link = p;
 
-	bfq_log(bfqd, "%llu: returning %d",
-		(unsigned long long) sector,
-		bfqq ? bfqq->pid : 0);
+	if (bfqq != NULL)
+		bfq_log(bfqd, "%llu: returning %d",
+			(unsigned long long) sector,
+			bfqq ? bfq_get_first_task_pid(bfqq) : 0);
 
 	return bfqq;
 }
@@ -2214,7 +2215,8 @@ static void bfq_add_request(struct request *rq)
 				bfq_clear_bfqq_has_waker(bfqq);
 				bfq_log_bfqq(bfqd, bfqq,
 					     "tentative waker: %d",
-					     bfqq->waker_bfqq->pid);
+					     bfq_get_first_task_pid(
+						     bfqq->waker_bfqq));
 			} else if (bfqd->last_completed_rq_bfqq ==
 				   bfqq->waker_bfqq &&
 				   !bfq_bfqq_has_waker(bfqq)) {
@@ -2224,7 +2226,8 @@ static void bfq_add_request(struct request *rq)
 				 */
 				bfq_mark_bfqq_has_waker(bfqq);
 				bfq_log_bfqq(bfqd, bfqq, "has waker set to %d",
-					     bfqq->waker_bfqq->pid);
+					     bfq_get_first_task_pid(
+						     bfqq->waker_bfqq));
 			}
 		}
 
@@ -2851,7 +2854,7 @@ bfq_setup_merge(struct bfq_queue *bfqq, struct bfq_queue *new_bfqq)
 		return NULL;
 
 	bfq_log_bfqq(bfqq->bfqd, bfqq, "scheduling merge with queue %d",
-		new_bfqq->pid);
+		bfq_get_first_task_pid(new_bfqq));
 
 	/*
 	 * Merging is just a redirection: the requests of the process
@@ -2884,7 +2887,7 @@ static bool bfq_may_be_close_cooperator(struct bfq_queue *bfqq,
 	if (bfq_too_late_for_merging(new_bfqq)) {
 		bfq_log_bfqq(bfqq->bfqd, bfqq,
 			     "too late for bfq%d to be merged",
-				new_bfqq->pid);
+				bfq_get_first_task_pid(new_bfqq));
 		return false;
 	}
 
@@ -3108,8 +3111,11 @@ static void
 bfq_merge_bfqqs(struct bfq_data *bfqd, struct bfq_io_cq *bic,
 		struct bfq_queue *bfqq, struct bfq_queue *new_bfqq)
 {
+	struct task_struct *item;
+	struct hlist_node *n;
+
 	bfq_log_bfqq(bfqd, bfqq, "merging with queue %lu",
-		(unsigned long)new_bfqq->pid);
+		(unsigned long)bfq_get_first_task_pid(new_bfqq));
 
 	BFQ_BUG_ON(new_bfqq == &bfqd->oom_bfqq);
 
@@ -3145,7 +3151,7 @@ bfq_merge_bfqqs(struct bfq_data *bfqd, struct bfq_io_cq *bic,
 		new_bfqq->entity.prio_changed = 1;
 		bfq_log_bfqq(bfqd, new_bfqq,
 			     "wr start after merge with %d, rais_max_time %u",
-			     bfqq->pid,
+			     bfq_get_first_task_pid(bfqq),
 			     jiffies_to_msecs(bfqq->wr_cur_max_time));
 	}
 
@@ -3187,8 +3193,16 @@ bfq_merge_bfqqs(struct bfq_data *bfqd, struct bfq_io_cq *bic,
 	 * We mark such a queue with a pid -1, and then print SHARED instead of
 	 * a pid in logging messages.
 	 */
-	new_bfqq->pid = -1;
 	bfqq->bic = NULL;
+
+	/*
+	 * move task_list_node from its current list to that of new_bfqq
+	 */
+	hlist_for_each_entry_safe(item, n, &bfqq->task_list, task_list_node) {
+		hlist_del_init(&item->task_list_node);
+		hlist_add_head(&item->task_list_node, &new_bfqq->task_list);
+	}
+
 	bfq_release_process_ref(bfqd, bfqq);
 }
 
@@ -5062,7 +5076,8 @@ static struct bfq_queue *bfq_select_queue(struct bfq_data *bfqd)
 		    bfq_bfqq_budget_left(async_bfqq)) {
 			bfq_log_bfqq(bfqd, bfqq,
 				     "choosing directly the async queue %d",
-				     bfqq->bic->bfqq[0]->pid);
+				     bfq_get_first_task_pid(
+					     bfqq->bic->bfqq[0]));
 			BUG_ON(bfqq->bic->bfqq[0] == bfqq);
 			bfqq = bfqq->bic->bfqq[0];
 			bfq_log_bfqq(bfqd, bfqq,
@@ -5076,7 +5091,7 @@ static struct bfq_queue *bfq_select_queue(struct bfq_data *bfqd)
 			) {
 			bfq_log_bfqq(bfqd, bfqq,
 				     "choosing directly the waker queue %d",
-				     bfqq->waker_bfqq->pid);
+				     bfq_get_first_task_pid(bfqq->waker_bfqq));
 			BUG_ON(bfqq->waker_bfqq == bfqq);
 			bfqq = bfqq->waker_bfqq;
 			bfq_log_bfqq(bfqd, bfqq,
@@ -5095,7 +5110,7 @@ static struct bfq_queue *bfq_select_queue(struct bfq_data *bfqd)
 			if (new_bfqq)
 				bfq_log_bfqq(bfqd, bfqq,
 					"chosen the queue %d for injection",
-					new_bfqq->pid);
+					bfq_get_first_task_pid(new_bfqq));
 			bfqq = new_bfqq;
 		} else {
 			bfqq = NULL;
@@ -5617,6 +5632,7 @@ static void bfq_exit_bfqq(struct bfq_data *bfqd, struct bfq_queue *bfqq)
 
 	bfq_put_cooperator(bfqq);
 
+	hlist_del_init(&current->task_list_node);
 	bfq_release_process_ref(bfqd, bfqq);
 }
 
@@ -5725,6 +5741,7 @@ static void bfq_check_ioprio_change(struct bfq_io_cq *bic, struct bio *bio)
 
 	bfqq = bic_to_bfqq(bic, false);
 	if (bfqq) {
+		hlist_del_init(&current->task_list_node);
 		bfq_release_process_ref(bfqd, bfqq);
 		bfqq = bfq_get_queue(bfqd, bio, BLK_RW_ASYNC, bic);
 		bic_set_bfqq(bic, bfqq, false);
@@ -5748,6 +5765,8 @@ static void bfq_init_bfqq(struct bfq_data *bfqd, struct bfq_queue *bfqq,
 	INIT_HLIST_NODE(&bfqq->burst_list_node);
 	INIT_HLIST_NODE(&bfqq->woken_list_node);
 	INIT_HLIST_HEAD(&bfqq->woken_list);
+	INIT_HLIST_HEAD(&bfqq->task_list);
+	INIT_HLIST_NODE(&current->task_list_node);
 	BFQ_BUG_ON(!hlist_unhashed(&bfqq->burst_list_node));
 
 	bfqq->ref = 0;
@@ -5777,7 +5796,8 @@ static void bfq_init_bfqq(struct bfq_data *bfqd, struct bfq_queue *bfqq,
 
 	bfq_mark_bfqq_IO_bound(bfqq);
 
-	bfqq->pid = pid;
+	/* add current task to task_list in bfqq */
+	hlist_add_head(&current->task_list_node, &bfqq->task_list);
 
 	/* Tentative initial value to trade off between thr and lat */
 	bfqq->max_budget = (2 * bfq_max_budget(bfqd)) / 3;
@@ -6814,12 +6834,14 @@ bfq_split_bfqq(struct bfq_io_cq *bic, struct bfq_queue *bfqq)
 	bfq_log_bfqq(bfqq->bfqd, bfqq, "splitting queue");
 
 	if (bfqq_process_refs(bfqq) == 1) {
-		bfqq->pid = current->pid;
 		bfq_clear_bfqq_coop(bfqq);
 		bfq_clear_bfqq_split_coop(bfqq);
 		return bfqq;
 	}
 
+	/* delete current task from queue iterating on task_list */
+	hlist_del_init(&current->task_list_node);
+
 	bic_set_bfqq(bic, NULL, 1);
 
 	bfq_put_cooperator(bfqq);
@@ -7466,7 +7488,7 @@ static ssize_t bfq_weights_show(struct elevator_queue *e, char *page)
 	list_for_each_entry(bfqq, &bfqd->active_list, bfqq_list) {
 		num_char += sprintf(page + num_char,
 				    "pid%d: weight %hu, nr_queued %d %d, ",
-				    bfqq->pid,
+				    bfq_get_first_task_pid(bfqq),
 				    bfqq->entity.weight,
 				    bfqq->queued[0],
 				    bfqq->queued[1]);
@@ -7482,7 +7504,7 @@ static ssize_t bfq_weights_show(struct elevator_queue *e, char *page)
 	list_for_each_entry(bfqq, &bfqd->idle_list, bfqq_list) {
 		num_char += sprintf(page + num_char,
 				    "pid%d: weight %hu, dur %d/%u\n",
-				    bfqq->pid,
+				    bfq_get_first_task_pid(bfqq),
 				    bfqq->entity.weight,
 				    jiffies_to_msecs(jiffies -
 						     bfqq->last_wr_start_finish),
@@ -7812,6 +7834,18 @@ static void __exit bfq_exit(void)
 	bfq_slab_kill();
 }
 
+pid_t bfq_get_first_task_pid(struct bfq_queue *bfqq)
+{
+	struct task_struct *item;
+
+	if ((&bfqq->task_list)->first != NULL)
+		return (hlist_entry_safe( (&bfqq->task_list)->first,
+					  typeof(*(item)), task_list_node))
+			->pid;
+
+	return -1;
+}
+
 module_init(bfq_init);
 module_exit(bfq_exit);
 
diff --git a/block/bfq-iosched.h b/block/bfq-iosched.h
index 5b675c3be..c91e84080 100644
--- a/block/bfq-iosched.h
+++ b/block/bfq-iosched.h
@@ -25,7 +25,7 @@
 #define BFQ_DEFAULT_GRP_IOPRIO	0
 #define BFQ_DEFAULT_GRP_CLASS	IOPRIO_CLASS_BE
 
-#define MAX_PID_STR_LENGTH 12
+#define MAX_PID_STR_LENGTH 256
 
 /*
  * Soft real-time applications are extremely more latency sensitive
@@ -315,6 +315,9 @@ struct bfq_queue {
 	 */
 	unsigned int requests_within_timer;
 
+	/* list of task in queue */
+	struct hlist_head task_list;
+
 	/* pid of the process owning the queue, used for logging purposes */
 	pid_t pid;
 
@@ -962,6 +965,7 @@ void bfq_end_wr_async_queues(struct bfq_data *bfqd, struct bfq_group *bfqg);
 void bfq_release_process_ref(struct bfq_data *bfqd, struct bfq_queue *bfqq);
 void bfq_schedule_dispatch(struct bfq_data *bfqd);
 void bfq_put_async_queues(struct bfq_data *bfqd, struct bfq_group *bfqg);
+pid_t bfq_get_first_task_pid(struct bfq_queue *queue);
 
 /* ------------ end of main algorithm interface -------------- */
 
@@ -1062,12 +1066,16 @@ void bfq_add_bfqq_busy(struct bfq_data *bfqd, struct bfq_queue *bfqq);
 /* --------------- end of interface of B-WF2Q+ ---------------- */
 
 /* Logging facilities. */
-static inline void bfq_pid_to_str(int pid, char *str, int len)
+static inline void bfq_pid_to_str(int pid, char *str, int len, struct bfq_queue *bfqq)
 {
-	if (pid != -1)
-		snprintf(str, len, "%d", pid);
-	else
-		snprintf(str, len, "SHARED-");
+	struct task_struct *item;
+	ssize_t num_char = 0;
+
+	hlist_for_each_entry(item, &bfqq->task_list, task_list_node) {
+		num_char += sprintf(str + num_char,
+					"%d-",
+					item->pid);
+	}
 }
 
 #ifdef CONFIG_BFQ_REDIRECT_TO_CONSOLE
@@ -1088,7 +1096,7 @@ static const char *checked_dev_name(const struct device *dev)
 	char pid_str[MAX_PID_STR_LENGTH];			\
 	if (likely(!blk_trace_note_message_enabled((bfqd)->queue)))	\
 		break;							\
-	bfq_pid_to_str((bfqq)->pid, pid_str, MAX_PID_STR_LENGTH); \
+	bfq_pid_to_str((bfqq)->pid, pid_str, MAX_PID_STR_LENGTH, bfqq); \
 	pr_crit("%s bfq%s%c %s [%s] " fmt "\n",			\
 		checked_dev_name((bfqd)->queue->backing_dev_info->dev), \
 		pid_str,					\
@@ -1108,7 +1116,7 @@ static const char *checked_dev_name(const struct device *dev)
 	char pid_str[MAX_PID_STR_LENGTH];			\
 	if (likely(!blk_trace_note_message_enabled((bfqd)->queue)))	\
 		break;							\
-	bfq_pid_to_str((bfqq)->pid, pid_str, MAX_PID_STR_LENGTH); \
+	bfq_pid_to_str((bfqq)->pid, pid_str, MAX_PID_STR_LENGTH, bfqq); \
 	pr_crit("%s bfq%s%c %s [%s] " fmt "\n",			\
 		checked_dev_name((bfqd)->queue->backing_dev_info->dev), \
 		pid_str, bfq_bfqq_sync((bfqq)) ? 'S' : 'A',	\
@@ -1144,7 +1152,7 @@ static const char *checked_dev_name(const struct device *dev)
 	char pid_str[MAX_PID_STR_LENGTH];			\
 	if (likely(!blk_trace_note_message_enabled((bfqd)->queue)))	\
 		break;							\
-	bfq_pid_to_str((bfqq)->pid, pid_str, MAX_PID_STR_LENGTH); \
+	bfq_pid_to_str((bfqq)->pid, pid_str, MAX_PID_STR_LENGTH, bfqq); \
 	blk_add_trace_msg((bfqd)->queue, "bfq%s%c %s [%s] " fmt, \
 			  pid_str,				\
 			  bfq_bfqq_sync((bfqq)) ? 'S' : 'A',    \
@@ -1164,7 +1172,7 @@ static const char *checked_dev_name(const struct device *dev)
 	char pid_str[MAX_PID_STR_LENGTH];			\
 	if (likely(!blk_trace_note_message_enabled((bfqd)->queue)))	\
 		break;							\
-	bfq_pid_to_str((bfqq)->pid, pid_str, MAX_PID_STR_LENGTH); \
+	bfq_pid_to_str((bfqq)->pid, pid_str, MAX_PID_STR_LENGTH, bfqq); \
 	blk_add_trace_msg((bfqd)->queue, "bfq%s%c [%s] " fmt, pid_str, \
 			  bfq_bfqq_sync((bfqq)) ? 'S' : 'A',	\
 			  __func__, ##args);			\
diff --git a/include/linux/sched.h b/include/linux/sched.h
index 76cd21fa5..0e936b8ac 100644
--- a/include/linux/sched.h
+++ b/include/linux/sched.h
@@ -1354,6 +1354,8 @@ struct task_struct {
 	 */
 	randomized_struct_fields_end
 
+	struct hlist_node task_list_node;
+
 	/* CPU-specific state of this task: */
 	struct thread_struct		thread;
 
-- 
2.30.0.155.g66e871b664

