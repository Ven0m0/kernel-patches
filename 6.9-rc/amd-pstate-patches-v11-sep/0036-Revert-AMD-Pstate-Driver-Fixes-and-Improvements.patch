From 550c4ce5c7867090db561de3360fe37864657e98 Mon Sep 17 00:00:00 2001
From: Peter Jung <admin@ptr1337.dev>
Date: Wed, 8 May 2024 14:47:13 +0200
Subject: [PATCH 36/38] Revert AMD Pstate Driver Fixes and Improvements

Signed-off-by: Peter Jung <admin@ptr1337.dev>
---
 Documentation/admin-guide/pm/amd-pstate.rst |  19 +-
 arch/x86/include/asm/cpufeatures.h          |   1 -
 arch/x86/include/asm/processor.h            |   2 -
 arch/x86/kernel/cpu/amd.c                   |  19 --
 arch/x86/kernel/cpu/scattered.c             |   1 -
 drivers/cpufreq/amd-pstate.c                | 196 ++++++--------------
 include/linux/amd-pstate.h                  |   8 -
 7 files changed, 61 insertions(+), 185 deletions(-)

diff --git a/Documentation/admin-guide/pm/amd-pstate.rst b/Documentation/admin-guide/pm/amd-pstate.rst
index b21449045..8c48b00fc 100644
--- a/Documentation/admin-guide/pm/amd-pstate.rst
+++ b/Documentation/admin-guide/pm/amd-pstate.rst
@@ -320,10 +320,6 @@ module which supports the new AMD P-States mechanism on most of the future AMD
 platforms. The AMD P-States mechanism is the more performance and energy
 efficiency frequency management method on AMD processors.
 
-When users attempt to switch from the acpi-cpufreq driver to the amd-pstate driver's working mode,
-it is recommended to reboot the system. This is to ensure that any low-level power management
-control states are properly switched to pstate control. By rebooting, the firmware can initialize
-with optimal power states, reducing the likelihood of unexpected issues.
 
 ``amd-pstate`` Driver Operation Modes
 ======================================
@@ -431,7 +427,7 @@ control its functionality at the system level.  They are located in the
 ``/sys/devices/system/cpu/amd_pstate/`` directory and affect all CPUs.
 
 ``status``
-	Operation mode of the driver: "active", "passive", "guided" or "disable".
+	Operation mode of the driver: "active", "passive" or "disable".
 
 	"active"
 		The driver is functional and in the ``active mode``
@@ -507,19 +503,6 @@ operations for the new ``amd-pstate`` module with this tool. ::
 Diagnostics and Tuning
 =======================
 
-Debugging AMD P-State Driver Loading Issues
-------------------------------------------
-
-On some platforms, there may be issues with the loading of the amd-pstate driver.
-To capture debug messages for issue analysis, users can add below parameter,
-"amd_pstate.dyndbg=+p cppc_acpi.dyndbg=+p  loglevel=4 debug amd_pstate=active"
-to the kernel command line. This will enable dynamic debugging and allow better
-analysis and troubleshooting of the driver loading process.
-
-Please note that adding this parameter will only enable debug logging during the
-driver loading phase and may affect system behavior. Use this option with caution
-and only for debugging purposes.
-
 Trace Events
 --------------
 
diff --git a/arch/x86/include/asm/cpufeatures.h b/arch/x86/include/asm/cpufeatures.h
index 39a92338c..3c7434329 100644
--- a/arch/x86/include/asm/cpufeatures.h
+++ b/arch/x86/include/asm/cpufeatures.h
@@ -470,7 +470,6 @@
 #define X86_FEATURE_BHI_CTRL		(21*32+ 2) /* "" BHI_DIS_S HW control available */
 #define X86_FEATURE_CLEAR_BHB_HW	(21*32+ 3) /* "" BHI_DIS_S HW control enabled */
 #define X86_FEATURE_CLEAR_BHB_LOOP_ON_VMEXIT (21*32+ 4) /* "" Clear branch history at vmexit using SW loop */
-#define X86_FEATURE_HETERO_CORE_TOPOLOGY       (21*32+ 5) /* "" Heterogeneous Core Topology */
 
 /*
  * BUG word(s)
diff --git a/arch/x86/include/asm/processor.h b/arch/x86/include/asm/processor.h
index 4648e4b46..78e51b0d6 100644
--- a/arch/x86/include/asm/processor.h
+++ b/arch/x86/include/asm/processor.h
@@ -682,12 +682,10 @@ static inline u32 per_cpu_l2c_id(unsigned int cpu)
 extern u32 amd_get_highest_perf(void);
 extern void amd_clear_divider(void);
 extern void amd_check_microcode(void);
-extern int amd_get_this_core_type(void);
 #else
 static inline u32 amd_get_highest_perf(void)		{ return 0; }
 static inline void amd_clear_divider(void)		{ }
 static inline void amd_check_microcode(void)		{ }
-static inline int amd_get_this_core_type(void)		{ }
 #endif
 
 extern unsigned long arch_align_stack(unsigned long sp);
diff --git a/arch/x86/kernel/cpu/amd.c b/arch/x86/kernel/cpu/amd.c
index 67966bdcd..307302af0 100644
--- a/arch/x86/kernel/cpu/amd.c
+++ b/arch/x86/kernel/cpu/amd.c
@@ -1219,22 +1219,3 @@ void noinstr amd_clear_divider(void)
 		     :: "a" (0), "d" (0), "r" (1));
 }
 EXPORT_SYMBOL_GPL(amd_clear_divider);
-
-#define X86_CPU_TYPE_ID_SHIFT	28
-
-/**
- * amd_get_this_core_type - Get the type of this heterogeneous CPU
- *
- * Returns the CPU type [31:28] (i.e., performance or efficient) of
- * a CPU in the processor.
- * If the processor has no core type support, returns -1.
- */
-
-int amd_get_this_core_type(void)
-{
-	if (!cpu_feature_enabled(X86_FEATURE_HETERO_CORE_TOPOLOGY))
-		return -1;
-
-	return cpuid_ebx(0x80000026) >> X86_CPU_TYPE_ID_SHIFT;
-}
-EXPORT_SYMBOL_GPL(amd_get_this_core_type);
diff --git a/arch/x86/kernel/cpu/scattered.c b/arch/x86/kernel/cpu/scattered.c
index 9e237a3da..af5aa2c75 100644
--- a/arch/x86/kernel/cpu/scattered.c
+++ b/arch/x86/kernel/cpu/scattered.c
@@ -51,7 +51,6 @@ static const struct cpuid_bit cpuid_bits[] = {
 	{ X86_FEATURE_PERFMON_V2,	CPUID_EAX,  0, 0x80000022, 0 },
 	{ X86_FEATURE_AMD_LBR_V2,	CPUID_EAX,  1, 0x80000022, 0 },
 	{ X86_FEATURE_AMD_LBR_PMC_FREEZE,	CPUID_EAX,  2, 0x80000022, 0 },
-	{ X86_FEATURE_HETERO_CORE_TOPOLOGY,	CPUID_EAX,  30, 0x80000026, 0 },
 	{ 0, 0, 0, 0, 0 }
 };
 
diff --git a/drivers/cpufreq/amd-pstate.c b/drivers/cpufreq/amd-pstate.c
index 0a311cd73..44531711a 100644
--- a/drivers/cpufreq/amd-pstate.c
+++ b/drivers/cpufreq/amd-pstate.c
@@ -50,9 +50,7 @@
 
 #define AMD_PSTATE_TRANSITION_LATENCY	20000
 #define AMD_PSTATE_TRANSITION_DELAY	1000
-#define CPPC_HIGHEST_PERF_EFFICIENT		132
-#define CPPC_HIGHEST_PERF_PERFORMANCE		196
-#define CPPC_HIGHEST_PERF_DEFAULT		166
+#define AMD_PSTATE_PREFCORE_THRESHOLD	166
 
 /*
  * TODO: We need more time to fine tune processors with shared memory solution
@@ -66,7 +64,7 @@
 static struct cpufreq_driver *current_pstate_driver;
 static struct cpufreq_driver amd_pstate_driver;
 static struct cpufreq_driver amd_pstate_epp_driver;
-static int cppc_state;
+static int cppc_state = AMD_PSTATE_UNDEFINED;
 static bool cppc_enabled;
 static bool amd_pstate_prefcore = true;
 static struct quirk_entry *quirks;
@@ -128,7 +126,7 @@ static int __init dmi_matched_7k62_bios_bug(const struct dmi_system_id *dmi)
 	 * broken BIOS lack of nominal_freq and lowest_freq capabilities
 	 * definition in ACPI tables
 	 */
-	if (cpu_feature_enabled(X86_FEATURE_ZEN2)) {
+	if (boot_cpu_has(X86_FEATURE_ZEN2)) {
 		quirks = dmi->driver_data;
 		pr_info("Overriding nominal and lowest frequencies for %s\n", dmi->ident);
 		return 1;
@@ -170,7 +168,7 @@ static s16 amd_pstate_get_epp(struct amd_cpudata *cpudata, u64 cppc_req_cached)
 	u64 epp;
 	int ret;
 
-	if (cpu_feature_enabled(X86_FEATURE_CPPC)) {
+	if (boot_cpu_has(X86_FEATURE_CPPC)) {
 		if (!cppc_req_cached) {
 			epp = rdmsrl_on_cpu(cpudata->cpu, MSR_AMD_CPPC_REQ,
 					&cppc_req_cached);
@@ -223,7 +221,7 @@ static int amd_pstate_set_epp(struct amd_cpudata *cpudata, u32 epp)
 	int ret;
 	struct cppc_perf_ctrls perf_ctrls;
 
-	if (cpu_feature_enabled(X86_FEATURE_CPPC)) {
+	if (boot_cpu_has(X86_FEATURE_CPPC)) {
 		u64 value = READ_ONCE(cpudata->cppc_req_cached);
 
 		value &= ~GENMASK_ULL(31, 24);
@@ -330,57 +328,6 @@ static inline int amd_pstate_enable(bool enable)
 	return static_call(amd_pstate_enable)(enable);
 }
 
-static void get_this_core_type(void *data)
-{
-	int *cpu_type = data;
-
-	*cpu_type = amd_get_this_core_type();
-}
-
-static int amd_pstate_get_cpu_type(int cpu)
-{
-	int cpu_type = 0;
-
-	smp_call_function_single(cpu, get_this_core_type, &cpu_type, 1);
-
-	return cpu_type;
-}
-
-static u32 amd_pstate_highest_perf_set(struct amd_cpudata *cpudata)
-{
-	u32 highest_perf;
-	int core_type;
-	struct cpuinfo_x86 *c = &cpu_data(0);
-
-	core_type = amd_pstate_get_cpu_type(cpudata->cpu);
-	pr_debug("core_type %d found\n", core_type);
-
-	switch (core_type) {
-	case CPU_CORE_TYPE_NO_HETERO_SUP:
-		highest_perf = CPPC_HIGHEST_PERF_DEFAULT;
-		/*
-		 * For AMD CPUs with Family ID 19H and Model ID range 0x70 to 0x7F,
-		 * the highest performance level is set to 196.
-		 * https://bugzilla.kernel.org/show_bug.cgi?id=218759
-		 */
-		if (c->x86 == 0x19 && (c->x86_model >= 0x70 && c->x86_model <= 0x7F))
-			highest_perf = CPPC_HIGHEST_PERF_PERFORMANCE;
-		break;
-	case CPU_CORE_TYPE_PERFORMANCE:
-		highest_perf = CPPC_HIGHEST_PERF_PERFORMANCE;
-		break;
-	case CPU_CORE_TYPE_EFFICIENCY:
-		highest_perf = CPPC_HIGHEST_PERF_EFFICIENT;
-		break;
-	default:
-		highest_perf = CPPC_HIGHEST_PERF_DEFAULT;
-		WARN_ONCE(true, "WARNING: Undefined core type found");
-		break;
-	}
-
-    return highest_perf;
-}
-
 static int pstate_init_perf(struct amd_cpudata *cpudata)
 {
 	u64 cap1;
@@ -391,7 +338,15 @@ static int pstate_init_perf(struct amd_cpudata *cpudata)
 	if (ret)
 		return ret;
 
-	highest_perf = amd_pstate_highest_perf_set(cpudata);
+	/* For platforms that do not support the preferred core feature, the
+	 * highest_pef may be configured with 166 or 255, to avoid max frequency
+	 * calculated wrongly. we take the AMD_CPPC_HIGHEST_PERF(cap1) value as
+	 * the default max perf.
+	 */
+	if (cpudata->hw_prefcore)
+		highest_perf = AMD_PSTATE_PREFCORE_THRESHOLD;
+	else
+		highest_perf = AMD_CPPC_HIGHEST_PERF(cap1);
 
 	WRITE_ONCE(cpudata->highest_perf, highest_perf);
 	WRITE_ONCE(cpudata->max_limit_perf, highest_perf);
@@ -412,7 +367,10 @@ static int cppc_init_perf(struct amd_cpudata *cpudata)
 	if (ret)
 		return ret;
 
-	highest_perf = amd_pstate_highest_perf_set(cpudata);
+	if (cpudata->hw_prefcore)
+		highest_perf = AMD_PSTATE_PREFCORE_THRESHOLD;
+	else
+		highest_perf = cppc_perf.highest_perf;
 
 	WRITE_ONCE(cpudata->highest_perf, highest_perf);
 	WRITE_ONCE(cpudata->max_limit_perf, highest_perf);
@@ -769,7 +727,7 @@ static int amd_pstate_get_highest_perf(int cpu, u32 *highest_perf)
 {
 	int ret;
 
-	if (cpu_feature_enabled(X86_FEATURE_CPPC)) {
+	if (boot_cpu_has(X86_FEATURE_CPPC)) {
 		u64 cap1;
 
 		ret = rdmsrl_safe_on_cpu(cpu, MSR_AMD_CPPC_CAP1, &cap1);
@@ -937,24 +895,6 @@ static int amd_pstate_init_freq(struct amd_cpudata *cpudata)
 	WRITE_ONCE(cpudata->nominal_freq, nominal_freq);
 	WRITE_ONCE(cpudata->max_freq, max_freq);
 
-	/**
-	 * Below values need to be initialized correctly, otherwise driver will be failed to load
-	 * max_freq is calculated accoreding to (nominal_freq * highest_perf)/nominal_perf
-	 * lowest_nonlinear_freq is a value between [min_freq, nominal_freq]
-	 * Check _CPC in ACPI table ojbects if any values are incorrect
-	 */
-	if (min_freq <= 0 || max_freq <= 0 || nominal_freq <= 0 || min_freq > max_freq) {
-		pr_err("min_freq(%d) or max_freq(%d) or nominal_freq(%d) value is incorrect\n",
-			min_freq, max_freq, nominal_freq);
-		return -EINVAL;
-	}
-
-	if (lowest_nonlinear_freq <= min_freq || lowest_nonlinear_freq > nominal_freq * 1000) {
-		pr_err("lowest_nonlinear_freq(%d) value is out of range [min_freq(%d), nominal_freq(%d)]\n",
-			lowest_nonlinear_freq, min_freq, nominal_freq * 1000);
-		return -EINVAL;
-	}
-
 	return 0;
 }
 
@@ -998,6 +938,15 @@ static int amd_pstate_cpu_init(struct cpufreq_policy *policy)
 	max_freq = READ_ONCE(cpudata->max_freq);
 	nominal_freq = READ_ONCE(cpudata->nominal_freq);
 
+	if (min_freq <= 0 || max_freq <= 0 ||
+	    nominal_freq <= 0 || min_freq > max_freq) {
+		dev_err(dev,
+			"min_freq(%d) or max_freq(%d) or nominal_freq (%d) value is incorrect, check _CPC in ACPI tables\n",
+			min_freq, max_freq, nominal_freq);
+		ret = -EINVAL;
+		goto free_cpudata1;
+	}
+
 	policy->cpuinfo.transition_latency = amd_pstate_get_transition_latency(policy->cpu);
 	policy->transition_delay_us = amd_pstate_get_transition_delay_us(policy->cpu);
 
@@ -1010,7 +959,7 @@ static int amd_pstate_cpu_init(struct cpufreq_policy *policy)
 	/* It will be updated by governor */
 	policy->cur = policy->cpuinfo.min_freq;
 
-	if (cpu_feature_enabled(X86_FEATURE_CPPC))
+	if (boot_cpu_has(X86_FEATURE_CPPC))
 		policy->fast_switch_possible = true;
 
 	ret = freq_qos_add_request(&policy->constraints, &cpudata->req[0],
@@ -1242,7 +1191,7 @@ static int amd_pstate_change_mode_without_dvr_change(int mode)
 
 	cppc_state = mode;
 
-	if (cpu_feature_enabled(X86_FEATURE_CPPC) || cppc_state == AMD_PSTATE_ACTIVE)
+	if (boot_cpu_has(X86_FEATURE_CPPC) || cppc_state == AMD_PSTATE_ACTIVE)
 		return 0;
 
 	for_each_present_cpu(cpu) {
@@ -1591,6 +1540,14 @@ static int amd_pstate_epp_cpu_init(struct cpufreq_policy *policy)
 	min_freq = READ_ONCE(cpudata->min_freq);
 	max_freq = READ_ONCE(cpudata->max_freq);
 	nominal_freq = READ_ONCE(cpudata->nominal_freq);
+	if (min_freq <= 0 || max_freq <= 0 ||
+	    nominal_freq <= 0 || min_freq > max_freq) {
+		dev_err(dev,
+			"min_freq(%d) or max_freq(%d) or nominal_freq(%d) value is incorrect, check _CPC in ACPI tables\n",
+			min_freq, max_freq, nominal_freq);
+		ret = -EINVAL;
+		goto free_cpudata1;
+	}
 
 	policy->cpuinfo.min_freq = min_freq;
 	policy->cpuinfo.max_freq = max_freq;
@@ -1614,7 +1571,7 @@ static int amd_pstate_epp_cpu_init(struct cpufreq_policy *policy)
 	else
 		policy->policy = CPUFREQ_POLICY_POWERSAVE;
 
-	if (cpu_feature_enabled(X86_FEATURE_CPPC)) {
+	if (boot_cpu_has(X86_FEATURE_CPPC)) {
 		ret = rdmsrl_on_cpu(cpudata->cpu, MSR_AMD_CPPC_REQ, &value);
 		if (ret)
 			return ret;
@@ -1696,7 +1653,7 @@ static void amd_pstate_epp_update_limit(struct cpufreq_policy *policy)
 		epp = 0;
 
 	/* Set initial EPP value */
-	if (cpu_feature_enabled(X86_FEATURE_CPPC)) {
+	if (boot_cpu_has(X86_FEATURE_CPPC)) {
 		value &= ~GENMASK_ULL(31, 24);
 		value |= (u64)epp << 24;
 	}
@@ -1735,7 +1692,7 @@ static void amd_pstate_epp_reenable(struct amd_cpudata *cpudata)
 	value = READ_ONCE(cpudata->cppc_req_cached);
 	max_perf = READ_ONCE(cpudata->highest_perf);
 
-	if (cpu_feature_enabled(X86_FEATURE_CPPC)) {
+	if (boot_cpu_has(X86_FEATURE_CPPC)) {
 		wrmsrl_on_cpu(cpudata->cpu, MSR_AMD_CPPC_REQ, value);
 	} else {
 		perf_ctrls.max_perf = max_perf;
@@ -1769,7 +1726,7 @@ static void amd_pstate_epp_offline(struct cpufreq_policy *policy)
 	value = READ_ONCE(cpudata->cppc_req_cached);
 
 	mutex_lock(&amd_pstate_limits_lock);
-	if (cpu_feature_enabled(X86_FEATURE_CPPC)) {
+	if (boot_cpu_has(X86_FEATURE_CPPC)) {
 		cpudata->epp_policy = CPUFREQ_POLICY_UNKNOWN;
 
 		/* Set max perf same as min perf */
@@ -1896,31 +1853,6 @@ static int __init amd_pstate_set_driver(int mode_idx)
 	return -EINVAL;
 }
 
-/**
- * CPPC function is not supported for family ID 17H with model_ID ranging from 0x10 to 0x2F.
- * show the debug message that helps to check if the CPU has CPPC support for loading issue.
- */
-static bool amd_cppc_supported(void)
-{
-	if ((boot_cpu_data.x86 == 0x17) && (boot_cpu_data.x86_model < 0x30)) {
-		pr_debug_once("CPPC feature is not supported by the processor\n");
-		return false;
-	}
-
-	/*
-	 * If the CPPC flag is disabled in the BIOS for processors that support MSR-based CPPC
-	 * the AMD Pstate driver may not function correctly.
-	 */
-	if ((boot_cpu_data.x86 >= 0x19) && (boot_cpu_data.x86_model >= 0x40) &&
-			!cpu_feature_enabled(X86_FEATURE_CPPC)) {
-		pr_debug_once("The CPPC feature is supported but disabled by the BIOS. "
-						"Please enable it if your BIOS has the CPPC option.\n");
-		return false;
-	}
-
-	return true;
-}
-
 static int __init amd_pstate_init(void)
 {
 	struct device *dev_root;
@@ -1929,21 +1861,6 @@ static int __init amd_pstate_init(void)
 	if (boot_cpu_data.x86_vendor != X86_VENDOR_AMD)
 		return -ENODEV;
 
-	/* Disable on the following configs by default:
-	 * 1. Undefined platforms
-	 * 2. Server platforms
-	 */
-	if (amd_pstate_acpi_pm_profile_undefined() ||
-		amd_pstate_acpi_pm_profile_server()) {
-		pr_info("driver load is disabled for server or undefined platform\n");
-		return -ENODEV;
-	}
-
-	/* show debug message only if CPPC is not supported */
-	if (!amd_cppc_supported())
-		return -EOPNOTSUPP;
-
-	/* show warning message when BIOS broken or ACPI disabled */
 	if (!acpi_cpc_valid()) {
 		pr_warn_once("the _CPC object is not present in SBIOS or ACPI disabled\n");
 		return -ENODEV;
@@ -1958,28 +1875,35 @@ static int __init amd_pstate_init(void)
 	/* check if this machine need CPPC quirks */
 	dmi_check_system(amd_pstate_quirks_table);
 
-	/* get default driver mode for loading*/
-	cppc_state = CONFIG_X86_AMD_PSTATE_DEFAULT_MODE;
-	pr_debug("cppc working state set to mode:%d\n", cppc_state);
-
 	switch (cppc_state) {
+	case AMD_PSTATE_UNDEFINED:
+		/* Disable on the following configs by default:
+		 * 1. Undefined platforms
+		 * 2. Server platforms
+		 * 3. Shared memory designs
+		 */
+		if (amd_pstate_acpi_pm_profile_undefined() ||
+		    amd_pstate_acpi_pm_profile_server() ||
+		    !boot_cpu_has(X86_FEATURE_CPPC)) {
+			pr_info("driver load is disabled, boot with specific mode to enable this\n");
+			return -ENODEV;
+		}
+		ret = amd_pstate_set_driver(CONFIG_X86_AMD_PSTATE_DEFAULT_MODE);
+		if (ret)
+			return ret;
+		break;
 	case AMD_PSTATE_DISABLE:
-		pr_info("driver load is disabled, boot with specific mode to enable this\n");
 		return -ENODEV;
-	case AMD_PSTATE_UNDEFINED:
 	case AMD_PSTATE_PASSIVE:
 	case AMD_PSTATE_ACTIVE:
 	case AMD_PSTATE_GUIDED:
-		ret = amd_pstate_set_driver(cppc_state);
-		if (ret)
-			return ret;
 		break;
 	default:
 		return -EINVAL;
 	}
 
 	/* capability check */
-	if (cpu_feature_enabled(X86_FEATURE_CPPC)) {
+	if (boot_cpu_has(X86_FEATURE_CPPC)) {
 		pr_debug("AMD CPPC MSR based functionality is supported\n");
 		if (cppc_state != AMD_PSTATE_ACTIVE)
 			current_pstate_driver->adjust_perf = amd_pstate_adjust_perf;
@@ -1993,7 +1917,7 @@ static int __init amd_pstate_init(void)
 	/* enable amd pstate feature */
 	ret = amd_pstate_enable(true);
 	if (ret) {
-		pr_err("failed to enable driver mode(%d) with return %d\n", cppc_state, ret);
+		pr_err("failed to enable with return %d\n", ret);
 		return ret;
 	}
 
diff --git a/include/linux/amd-pstate.h b/include/linux/amd-pstate.h
index ebb7de0cd..56f616a5c 100644
--- a/include/linux/amd-pstate.h
+++ b/include/linux/amd-pstate.h
@@ -148,12 +148,4 @@ struct amd_pstate_global_params {
 
 extern struct amd_pstate_global_params amd_pstate_global_params;
 
-/* defined by CPUID_Fn80000026_EBX BIT [31:28] */
-enum amd_core_type {
-	CPU_CORE_TYPE_NO_HETERO_SUP = -1,
-	CPU_CORE_TYPE_PERFORMANCE = 0,
-	CPU_CORE_TYPE_EFFICIENCY = 1,
-	CPU_CORE_TYPE_UNDEFINED = 2,
-};
-
 #endif /* _LINUX_AMD_PSTATE_H */
-- 
2.44.0.325.g11c821f2f2

