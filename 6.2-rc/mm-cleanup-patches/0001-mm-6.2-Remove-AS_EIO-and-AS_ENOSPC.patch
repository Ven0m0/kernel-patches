From fdf1af24f21e3ea73963881a9d26c8c7b630b411 Mon Sep 17 00:00:00 2001
From: Piotr Gorski <lucjan.lucjanov@gmail.com>
Date: Mon, 9 Jan 2023 09:58:02 +0100
Subject: [PATCH] mm-6.2: Remove AS_EIO and AS_ENOSPC

Signed-off-by: Piotr Gorski <lucjan.lucjanov@gmail.com>
---
 block/bdev.c            |   8 +--
 fs/btrfs/extent_io.c    |   6 +--
 fs/cifs/file.c          |   8 ++-
 fs/f2fs/data.c          |   2 +-
 fs/f2fs/node.c          |   4 +-
 fs/fs-writeback.c       |   7 +--
 fs/fuse/file.c          |   3 +-
 fs/jbd2/commit.c        |  12 ++---
 fs/xfs/scrub/bmap.c     |   2 +-
 include/linux/pagemap.h |  23 ++------
 mm/filemap.c            | 113 +++++++---------------------------------
 mm/memory-failure.c     |  28 ----------
 mm/page-writeback.c     |  17 +++---
 13 files changed, 51 insertions(+), 182 deletions(-)

diff --git a/block/bdev.c b/block/bdev.c
index edc110d90..2fae19f0a 100644
--- a/block/bdev.c
+++ b/block/bdev.c
@@ -1053,13 +1053,7 @@ void sync_bdevs(bool wait)
 		if (!atomic_read(&bdev->bd_openers)) {
 			; /* skip */
 		} else if (wait) {
-			/*
-			 * We keep the error status of individual mapping so
-			 * that applications can catch the writeback error using
-			 * fsync(2). See filemap_fdatawait_keep_errors() for
-			 * details.
-			 */
-			filemap_fdatawait_keep_errors(inode->i_mapping);
+			filemap_fdatawait(inode->i_mapping);
 		} else {
 			filemap_fdatawrite(inode->i_mapping);
 		}
diff --git a/fs/btrfs/extent_io.c b/fs/btrfs/extent_io.c
index 9bd32daa9..f1c3572b6 100644
--- a/fs/btrfs/extent_io.c
+++ b/fs/btrfs/extent_io.c
@@ -2386,7 +2386,7 @@ static void set_btree_ioerr(struct page *page, struct extent_buffer *eb)
 	 * or the content of some node/leaf from a past generation that got
 	 * cowed or deleted and is no longer valid.
 	 *
-	 * Note: setting AS_EIO/AS_ENOSPC in the btree inode's i_mapping would
+	 * Note: setting wb_err in the btree inode's i_mapping would
 	 * not be enough - we need to distinguish between log tree extents vs
 	 * non-log tree extents, and the next filemap_fdatawait_range() call
 	 * will catch and clear such errors in the mapping - and that call might
@@ -2397,10 +2397,10 @@ static void set_btree_ioerr(struct page *page, struct extent_buffer *eb)
 	 * set (since it's a runtime flag, not persisted on disk).
 	 *
 	 * Using the flags below in the btree inode also makes us achieve the
-	 * goal of AS_EIO/AS_ENOSPC when writepages() returns success, started
+	 * goal of wb_err when writepages() returns success, started
 	 * writeback for all dirty pages and before filemap_fdatawait_range()
 	 * is called, the writeback for all dirty pages had already finished
-	 * with errors - because we were not using AS_EIO/AS_ENOSPC,
+	 * with errors - because we were not using wb_err,
 	 * filemap_fdatawait_range() would return success, as it could not know
 	 * that writeback errors happened (the pages were no longer tagged for
 	 * writeback).
diff --git a/fs/cifs/file.c b/fs/cifs/file.c
index 22dfc1f8b..7e7ee26cf 100644
--- a/fs/cifs/file.c
+++ b/fs/cifs/file.c
@@ -3042,14 +3042,12 @@ int cifs_flush(struct file *file, fl_owner_t id)
 	int rc = 0;
 
 	if (file->f_mode & FMODE_WRITE)
-		rc = filemap_write_and_wait(inode->i_mapping);
+		rc = filemap_write_and_wait(file->f_mapping);
 
 	cifs_dbg(FYI, "Flush inode %p file %p rc %d\n", inode, file, rc);
-	if (rc) {
-		/* get more nuanced writeback errors */
-		rc = filemap_check_wb_err(file->f_mapping, 0);
+	if (rc)
 		trace_cifs_flush_err(inode->i_ino, rc);
-	}
+
 	return rc;
 }
 
diff --git a/fs/f2fs/data.c b/fs/f2fs/data.c
index 97e816590..566fe19ca 100644
--- a/fs/f2fs/data.c
+++ b/fs/f2fs/data.c
@@ -2913,7 +2913,7 @@ int f2fs_write_single_data_page(struct page *page, int *submitted,
 	redirty_page_for_writepage(wbc, page);
 	/*
 	 * pageout() in MM traslates EAGAIN, so calls handle_write_error()
-	 * -> mapping_set_error() -> set_bit(AS_EIO, ...).
+	 * -> mapping_set_error().
 	 * file_write_and_wait_range() will see EIO error, which is critical
 	 * to return value of fsync() followed by atomic_write failure to user.
 	 */
diff --git a/fs/f2fs/node.c b/fs/f2fs/node.c
index dde4c0458..a87b5515c 100644
--- a/fs/f2fs/node.c
+++ b/fs/f2fs/node.c
@@ -2055,12 +2055,14 @@ int f2fs_sync_node_pages(struct f2fs_sb_info *sbi,
 int f2fs_wait_on_node_pages_writeback(struct f2fs_sb_info *sbi,
 						unsigned int seq_id)
 {
+	struct address_space *mapping = NODE_MAPPING(sbi);
 	struct fsync_node_entry *fn;
 	struct page *page;
 	struct list_head *head = &sbi->fsync_node_list;
 	unsigned long flags;
 	unsigned int cur_seq_id = 0;
 	int ret2, ret = 0;
+	errseq_t since = filemap_sample_wb_err(mapping);
 
 	while (seq_id && cur_seq_id < seq_id) {
 		spin_lock_irqsave(&sbi->fsync_node_lock, flags);
@@ -2088,7 +2090,7 @@ int f2fs_wait_on_node_pages_writeback(struct f2fs_sb_info *sbi,
 			break;
 	}
 
-	ret2 = filemap_check_errors(NODE_MAPPING(sbi));
+	ret2 = filemap_check_wb_err(mapping, since);
 	if (!ret)
 		ret = ret2;
 
diff --git a/fs/fs-writeback.c b/fs/fs-writeback.c
index 6fba5a521..dc0158125 100644
--- a/fs/fs-writeback.c
+++ b/fs/fs-writeback.c
@@ -2598,12 +2598,7 @@ static void wait_sb_inodes(struct super_block *sb)
 		spin_unlock(&inode->i_lock);
 		rcu_read_unlock();
 
-		/*
-		 * We keep the error status of individual mapping so that
-		 * applications can catch the writeback error using fsync(2).
-		 * See filemap_fdatawait_keep_errors() for details.
-		 */
-		filemap_fdatawait_keep_errors(mapping);
+		filemap_fdatawait(mapping);
 
 		cond_resched();
 
diff --git a/fs/fuse/file.c b/fs/fuse/file.c
index 875314ee6..7174646dd 100644
--- a/fs/fuse/file.c
+++ b/fs/fuse/file.c
@@ -500,11 +500,10 @@ static int fuse_flush(struct file *file, fl_owner_t id)
 	fuse_sync_writes(inode);
 	inode_unlock(inode);
 
-	err = filemap_check_errors(file->f_mapping);
+	err = file_check_and_advance_wb_err(file);
 	if (err)
 		return err;
 
-	err = 0;
 	if (fm->fc->no_flush)
 		goto inval_attr_out;
 
diff --git a/fs/jbd2/commit.c b/fs/jbd2/commit.c
index 4810438b7..36aa1b117 100644
--- a/fs/jbd2/commit.c
+++ b/fs/jbd2/commit.c
@@ -221,11 +221,10 @@ EXPORT_SYMBOL(jbd2_submit_inode_data);
 int jbd2_wait_inode_data(journal_t *journal, struct jbd2_inode *jinode)
 {
 	if (!jinode || !(jinode->i_flags & JI_WAIT_DATA) ||
-		!jinode->i_vfs_inode || !jinode->i_vfs_inode->i_mapping)
+	    !jinode->i_vfs_inode || !jinode->i_vfs_inode->i_mapping)
 		return 0;
-	return filemap_fdatawait_range_keep_errors(
-		jinode->i_vfs_inode->i_mapping, jinode->i_dirty_start,
-		jinode->i_dirty_end);
+	return filemap_fdatawait_range(jinode->i_vfs_inode->i_mapping,
+				jinode->i_dirty_start, jinode->i_dirty_end);
 }
 EXPORT_SYMBOL(jbd2_wait_inode_data);
 
@@ -270,9 +269,8 @@ int jbd2_journal_finish_inode_data_buffers(struct jbd2_inode *jinode)
 {
 	struct address_space *mapping = jinode->i_vfs_inode->i_mapping;
 
-	return filemap_fdatawait_range_keep_errors(mapping,
-						   jinode->i_dirty_start,
-						   jinode->i_dirty_end);
+	return filemap_fdatawait_range(mapping, jinode->i_dirty_start,
+			jinode->i_dirty_end);
 }
 
 /*
diff --git a/fs/xfs/scrub/bmap.c b/fs/xfs/scrub/bmap.c
index d50d0eab1..8f169047d 100644
--- a/fs/xfs/scrub/bmap.c
+++ b/fs/xfs/scrub/bmap.c
@@ -64,7 +64,7 @@ xchk_setup_inode_bmap(
 		 */
 		error = filemap_fdatawrite(mapping);
 		if (!error)
-			error = filemap_fdatawait_keep_errors(mapping);
+			error = filemap_fdatawait(mapping);
 		if (error && (error != -ENOSPC && error != -EIO))
 			goto out;
 	}
diff --git a/include/linux/pagemap.h b/include/linux/pagemap.h
index 29e1f9e76..69190335d 100644
--- a/include/linux/pagemap.h
+++ b/include/linux/pagemap.h
@@ -33,10 +33,7 @@ int invalidate_inode_pages2_range(struct address_space *mapping,
 int write_inode_now(struct inode *, int sync);
 int filemap_fdatawrite(struct address_space *);
 int filemap_flush(struct address_space *);
-int filemap_fdatawait_keep_errors(struct address_space *mapping);
 int filemap_fdatawait_range(struct address_space *, loff_t lstart, loff_t lend);
-int filemap_fdatawait_range_keep_errors(struct address_space *mapping,
-		loff_t start_byte, loff_t end_byte);
 
 static inline int filemap_fdatawait(struct address_space *mapping)
 {
@@ -50,7 +47,6 @@ int __filemap_fdatawrite_range(struct address_space *mapping,
 		loff_t start, loff_t end, int sync_mode);
 int filemap_fdatawrite_range(struct address_space *mapping,
 		loff_t start, loff_t end);
-int filemap_check_errors(struct address_space *mapping);
 void __filemap_set_wb_err(struct address_space *mapping, int err);
 int filemap_fdatawrite_wbc(struct address_space *mapping,
 			   struct writeback_control *wbc);
@@ -191,14 +187,11 @@ static inline bool mapping_shrinkable(struct address_space *mapping)
  * Bits in mapping->flags.
  */
 enum mapping_flags {
-	AS_EIO		= 0,	/* IO error on async write */
-	AS_ENOSPC	= 1,	/* ENOSPC on async write */
-	AS_MM_ALL_LOCKS	= 2,	/* under mm_take_all_locks() */
-	AS_UNEVICTABLE	= 3,	/* e.g., ramdisk, SHM_LOCK */
-	AS_EXITING	= 4, 	/* final truncate in progress */
-	/* writeback related tags are not used */
-	AS_NO_WRITEBACK_TAGS = 5,
-	AS_LARGE_FOLIO_SUPPORT = 6,
+	AS_MM_ALL_LOCKS	= 0,	/* under mm_take_all_locks() */
+	AS_UNEVICTABLE,		/* e.g., ramdisk, SHM_LOCK */
+	AS_EXITING, 		/* final truncate in progress */
+	AS_NO_WRITEBACK_TAGS,	/* writeback related tags are not used */
+	AS_LARGE_FOLIO_SUPPORT,
 };
 
 /**
@@ -226,12 +219,6 @@ static inline void mapping_set_error(struct address_space *mapping, int error)
 	/* Record it in superblock */
 	if (mapping->host)
 		errseq_set(&mapping->host->i_sb->s_wb_err, error);
-
-	/* Record it in flags for now, for legacy callers */
-	if (error == -ENOSPC)
-		set_bit(AS_ENOSPC, &mapping->flags);
-	else
-		set_bit(AS_EIO, &mapping->flags);
 }
 
 static inline void mapping_set_unevictable(struct address_space *mapping)
diff --git a/mm/filemap.c b/mm/filemap.c
index c4d4ace9c..7bf8442bc 100644
--- a/mm/filemap.c
+++ b/mm/filemap.c
@@ -341,30 +341,6 @@ void delete_from_page_cache_batch(struct address_space *mapping,
 		filemap_free_folio(mapping, fbatch->folios[i]);
 }
 
-int filemap_check_errors(struct address_space *mapping)
-{
-	int ret = 0;
-	/* Check for outstanding write errors */
-	if (test_bit(AS_ENOSPC, &mapping->flags) &&
-	    test_and_clear_bit(AS_ENOSPC, &mapping->flags))
-		ret = -ENOSPC;
-	if (test_bit(AS_EIO, &mapping->flags) &&
-	    test_and_clear_bit(AS_EIO, &mapping->flags))
-		ret = -EIO;
-	return ret;
-}
-EXPORT_SYMBOL(filemap_check_errors);
-
-static int filemap_check_and_keep_errors(struct address_space *mapping)
-{
-	/* Check for outstanding write errors */
-	if (test_bit(AS_EIO, &mapping->flags))
-		return -EIO;
-	if (test_bit(AS_ENOSPC, &mapping->flags))
-		return -ENOSPC;
-	return 0;
-}
-
 /**
  * filemap_fdatawrite_wbc - start writeback on mapping dirty pages in range
  * @mapping:	address space structure to write
@@ -536,41 +512,17 @@ static void __filemap_fdatawait_range(struct address_space *mapping,
  * in the given range and wait for all of them.  Check error status of
  * the address space and return it.
  *
- * Since the error status of the address space is cleared by this function,
- * callers are responsible for checking the return value and handling and/or
- * reporting the error.
- *
  * Return: error status of the address space.
  */
 int filemap_fdatawait_range(struct address_space *mapping, loff_t start_byte,
 			    loff_t end_byte)
 {
-	__filemap_fdatawait_range(mapping, start_byte, end_byte);
-	return filemap_check_errors(mapping);
-}
-EXPORT_SYMBOL(filemap_fdatawait_range);
+	errseq_t since = filemap_sample_wb_err(mapping);
 
-/**
- * filemap_fdatawait_range_keep_errors - wait for writeback to complete
- * @mapping:		address space structure to wait for
- * @start_byte:		offset in bytes where the range starts
- * @end_byte:		offset in bytes where the range ends (inclusive)
- *
- * Walk the list of under-writeback pages of the given address space in the
- * given range and wait for all of them.  Unlike filemap_fdatawait_range(),
- * this function does not clear error status of the address space.
- *
- * Use this function if callers don't handle errors themselves.  Expected
- * call sites are system-wide / filesystem-wide data flushers: e.g. sync(2),
- * fsfreeze(8)
- */
-int filemap_fdatawait_range_keep_errors(struct address_space *mapping,
-		loff_t start_byte, loff_t end_byte)
-{
 	__filemap_fdatawait_range(mapping, start_byte, end_byte);
-	return filemap_check_and_keep_errors(mapping);
+	return filemap_check_wb_err(mapping, since);
 }
-EXPORT_SYMBOL(filemap_fdatawait_range_keep_errors);
+EXPORT_SYMBOL(filemap_fdatawait_range);
 
 /**
  * file_fdatawait_range - wait for writeback to complete
@@ -597,27 +549,6 @@ int file_fdatawait_range(struct file *file, loff_t start_byte, loff_t end_byte)
 }
 EXPORT_SYMBOL(file_fdatawait_range);
 
-/**
- * filemap_fdatawait_keep_errors - wait for writeback without clearing errors
- * @mapping: address space structure to wait for
- *
- * Walk the list of under-writeback pages of the given address space
- * and wait for all of them.  Unlike filemap_fdatawait(), this function
- * does not clear error status of the address space.
- *
- * Use this function if callers don't handle errors themselves.  Expected
- * call sites are system-wide / filesystem-wide data flushers: e.g. sync(2),
- * fsfreeze(8)
- *
- * Return: error status of the address space.
- */
-int filemap_fdatawait_keep_errors(struct address_space *mapping)
-{
-	__filemap_fdatawait_range(mapping, 0, LLONG_MAX);
-	return filemap_check_and_keep_errors(mapping);
-}
-EXPORT_SYMBOL(filemap_fdatawait_keep_errors);
-
 /* Returns true if writeback might be needed or already in progress. */
 static bool mapping_needs_writeback(struct address_space *mapping)
 {
@@ -665,26 +596,27 @@ EXPORT_SYMBOL_GPL(filemap_range_has_writeback);
 int filemap_write_and_wait_range(struct address_space *mapping,
 				 loff_t lstart, loff_t lend)
 {
-	int err = 0, err2;
+	int err;
+	errseq_t since;
 
 	if (lend < lstart)
 		return 0;
+	if (!mapping_needs_writeback(mapping))
+		return 0;
 
-	if (mapping_needs_writeback(mapping)) {
-		err = __filemap_fdatawrite_range(mapping, lstart, lend,
-						 WB_SYNC_ALL);
-		/*
-		 * Even if the above returned error, the pages may be
-		 * written partially (e.g. -ENOSPC), so we wait for it.
-		 * But the -EIO is special case, it may indicate the worst
-		 * thing (e.g. bug) happened, so we avoid waiting for it.
-		 */
-		if (err != -EIO)
-			__filemap_fdatawait_range(mapping, lstart, lend);
-	}
-	err2 = filemap_check_errors(mapping);
+	since = filemap_sample_wb_err(mapping);
+	err = __filemap_fdatawrite_range(mapping, lstart, lend, WB_SYNC_ALL);
+	/*
+	 * Even if the above returned an error, the pages may be written
+	 * partially (e.g. -ENOSPC), so we wait for it.  But the -EIO
+	 * is a special case, it may indicate the worst thing (e.g. bug)
+	 * happened, so we avoid waiting for it.
+	 */
+	if (err != -EIO)
+		__filemap_fdatawait_range(mapping, lstart, lend);
 	if (!err)
-		err = err2;
+		err = filemap_check_wb_err(mapping, since);
+
 	return err;
 }
 EXPORT_SYMBOL(filemap_write_and_wait_range);
@@ -738,13 +670,6 @@ int file_check_and_advance_wb_err(struct file *file)
 		spin_unlock(&file->f_lock);
 	}
 
-	/*
-	 * We're mostly using this function as a drop in replacement for
-	 * filemap_check_errors. Clear AS_EIO/AS_ENOSPC to emulate the effect
-	 * that the legacy code would have had on these flags.
-	 */
-	clear_bit(AS_EIO, &mapping->flags);
-	clear_bit(AS_ENOSPC, &mapping->flags);
 	return err;
 }
 EXPORT_SYMBOL(file_check_and_advance_wb_err);
diff --git a/mm/memory-failure.c b/mm/memory-failure.c
index c77a9e37e..1a1c66f7e 100644
--- a/mm/memory-failure.c
+++ b/mm/memory-failure.c
@@ -992,34 +992,6 @@ static int me_pagecache_dirty(struct page_state *ps, struct page *p)
 		 * who check the mapping.
 		 * This way the application knows that something went
 		 * wrong with its dirty file data.
-		 *
-		 * There's one open issue:
-		 *
-		 * The EIO will be only reported on the next IO
-		 * operation and then cleared through the IO map.
-		 * Normally Linux has two mechanisms to pass IO error
-		 * first through the AS_EIO flag in the address space
-		 * and then through the PageError flag in the page.
-		 * Since we drop pages on memory failure handling the
-		 * only mechanism open to use is through AS_AIO.
-		 *
-		 * This has the disadvantage that it gets cleared on
-		 * the first operation that returns an error, while
-		 * the PageError bit is more sticky and only cleared
-		 * when the page is reread or dropped.  If an
-		 * application assumes it will always get error on
-		 * fsync, but does other operations on the fd before
-		 * and the page is dropped between then the error
-		 * will not be properly reported.
-		 *
-		 * This can already happen even without hwpoisoned
-		 * pages: first on metadata IO errors (which only
-		 * report through AS_EIO) or when the page is dropped
-		 * at the wrong time.
-		 *
-		 * So right now we assume that the application DTRT on
-		 * the first EIO, but we're not worse than other parts
-		 * of the kernel.
 		 */
 		mapping_set_error(mapping, -EIO);
 	}
diff --git a/mm/page-writeback.c b/mm/page-writeback.c
index ad608ef2a..491b70dad 100644
--- a/mm/page-writeback.c
+++ b/mm/page-writeback.c
@@ -2610,15 +2610,12 @@ int do_writepages(struct address_space *mapping, struct writeback_control *wbc)
  *
  * The folio must be locked by the caller and will be unlocked upon return.
  *
- * Note that the mapping's AS_EIO/AS_ENOSPC flags will be cleared when this
- * function returns.
- *
  * Return: %0 on success, negative error code otherwise
  */
 int folio_write_one(struct folio *folio)
 {
 	struct address_space *mapping = folio->mapping;
-	int ret = 0;
+	int err = 0;
 	struct writeback_control wbc = {
 		.sync_mode = WB_SYNC_ALL,
 		.nr_to_write = folio_nr_pages(folio),
@@ -2629,18 +2626,20 @@ int folio_write_one(struct folio *folio)
 	folio_wait_writeback(folio);
 
 	if (folio_clear_dirty_for_io(folio)) {
+		errseq_t since = filemap_sample_wb_err(mapping);
+
 		folio_get(folio);
-		ret = mapping->a_ops->writepage(&folio->page, &wbc);
-		if (ret == 0)
+		err = mapping->a_ops->writepage(&folio->page, &wbc);
+		if (!err) {
 			folio_wait_writeback(folio);
+			err = filemap_check_wb_err(mapping, since);
+		}
 		folio_put(folio);
 	} else {
 		folio_unlock(folio);
 	}
 
-	if (!ret)
-		ret = filemap_check_errors(mapping);
-	return ret;
+	return err;
 }
 EXPORT_SYMBOL(folio_write_one);
 
-- 
2.39.0.rc2.1.gbd5df96b79

