From c9647d9d48ea80efb4aad168302458868f6d1fb0 Mon Sep 17 00:00:00 2001
From: "Matthew Wilcox (Oracle)" <willy@infradead.org>
Date: Mon, 9 Jan 2023 05:18:13 +0000
Subject: [PATCH 01/11] memory-failure: Remove comment referencing AS_EIO

The EIO is now reported to every caller which has the file open on
the next operation which returns an error.  We obviously cannot check
whether the user took action correctly on that error, but we can remove
this comment as wb_err is never cleared, unlike AS_EIO.

Signed-off-by: Matthew Wilcox (Oracle) <willy@infradead.org>
---
 mm/memory-failure.c | 28 ----------------------------
 1 file changed, 28 deletions(-)

diff --git a/mm/memory-failure.c b/mm/memory-failure.c
index c77a9e37e..1a1c66f7e 100644
--- a/mm/memory-failure.c
+++ b/mm/memory-failure.c
@@ -992,34 +992,6 @@ static int me_pagecache_dirty(struct page_state *ps, struct page *p)
 		 * who check the mapping.
 		 * This way the application knows that something went
 		 * wrong with its dirty file data.
-		 *
-		 * There's one open issue:
-		 *
-		 * The EIO will be only reported on the next IO
-		 * operation and then cleared through the IO map.
-		 * Normally Linux has two mechanisms to pass IO error
-		 * first through the AS_EIO flag in the address space
-		 * and then through the PageError flag in the page.
-		 * Since we drop pages on memory failure handling the
-		 * only mechanism open to use is through AS_AIO.
-		 *
-		 * This has the disadvantage that it gets cleared on
-		 * the first operation that returns an error, while
-		 * the PageError bit is more sticky and only cleared
-		 * when the page is reread or dropped.  If an
-		 * application assumes it will always get error on
-		 * fsync, but does other operations on the fd before
-		 * and the page is dropped between then the error
-		 * will not be properly reported.
-		 *
-		 * This can already happen even without hwpoisoned
-		 * pages: first on metadata IO errors (which only
-		 * report through AS_EIO) or when the page is dropped
-		 * at the wrong time.
-		 *
-		 * So right now we assume that the application DTRT on
-		 * the first EIO, but we're not worse than other parts
-		 * of the kernel.
 		 */
 		mapping_set_error(mapping, -EIO);
 	}
-- 
2.39.0.rc2.1.gbd5df96b79


From 5b1aa1b31097e15891f3d5711417bf4421be421f Mon Sep 17 00:00:00 2001
From: "Matthew Wilcox (Oracle)" <willy@infradead.org>
Date: Mon, 9 Jan 2023 05:18:14 +0000
Subject: [PATCH 02/11] filemap: Remove filemap_check_and_keep_errors()

Convert both callers to use the "new" errseq infrastructure.

Signed-off-by: Matthew Wilcox (Oracle) <willy@infradead.org>
---
 mm/filemap.c | 18 ++++++------------
 1 file changed, 6 insertions(+), 12 deletions(-)

diff --git a/mm/filemap.c b/mm/filemap.c
index c4d4ace9c..48daedc22 100644
--- a/mm/filemap.c
+++ b/mm/filemap.c
@@ -355,16 +355,6 @@ int filemap_check_errors(struct address_space *mapping)
 }
 EXPORT_SYMBOL(filemap_check_errors);
 
-static int filemap_check_and_keep_errors(struct address_space *mapping)
-{
-	/* Check for outstanding write errors */
-	if (test_bit(AS_EIO, &mapping->flags))
-		return -EIO;
-	if (test_bit(AS_ENOSPC, &mapping->flags))
-		return -ENOSPC;
-	return 0;
-}
-
 /**
  * filemap_fdatawrite_wbc - start writeback on mapping dirty pages in range
  * @mapping:	address space structure to write
@@ -567,8 +557,10 @@ EXPORT_SYMBOL(filemap_fdatawait_range);
 int filemap_fdatawait_range_keep_errors(struct address_space *mapping,
 		loff_t start_byte, loff_t end_byte)
 {
+	errseq_t since = filemap_sample_wb_err(mapping);
+
 	__filemap_fdatawait_range(mapping, start_byte, end_byte);
-	return filemap_check_and_keep_errors(mapping);
+	return filemap_check_wb_err(mapping, since);
 }
 EXPORT_SYMBOL(filemap_fdatawait_range_keep_errors);
 
@@ -613,8 +605,10 @@ EXPORT_SYMBOL(file_fdatawait_range);
  */
 int filemap_fdatawait_keep_errors(struct address_space *mapping)
 {
+	errseq_t since = filemap_sample_wb_err(mapping);
+
 	__filemap_fdatawait_range(mapping, 0, LLONG_MAX);
-	return filemap_check_and_keep_errors(mapping);
+	return filemap_check_wb_err(mapping, since);
 }
 EXPORT_SYMBOL(filemap_fdatawait_keep_errors);
 
-- 
2.39.0.rc2.1.gbd5df96b79


From c28c59253918f7645ff514b1d3f719022ed53e57 Mon Sep 17 00:00:00 2001
From: "Matthew Wilcox (Oracle)" <willy@infradead.org>
Date: Mon, 9 Jan 2023 05:18:15 +0000
Subject: [PATCH 03/11] f2fs: Convert f2fs_wait_on_node_pages_writeback() to
 errseq

Convert from the old filemap_check_errors() to the errseq infrastructure.
This means we will not report any previously-occurring error, and we will
not clear any previously-occurring error.

Signed-off-by: Matthew Wilcox (Oracle) <willy@infradead.org>
---
 fs/f2fs/node.c | 4 +++-
 1 file changed, 3 insertions(+), 1 deletion(-)

diff --git a/fs/f2fs/node.c b/fs/f2fs/node.c
index dde4c0458..a87b5515c 100644
--- a/fs/f2fs/node.c
+++ b/fs/f2fs/node.c
@@ -2055,12 +2055,14 @@ int f2fs_sync_node_pages(struct f2fs_sb_info *sbi,
 int f2fs_wait_on_node_pages_writeback(struct f2fs_sb_info *sbi,
 						unsigned int seq_id)
 {
+	struct address_space *mapping = NODE_MAPPING(sbi);
 	struct fsync_node_entry *fn;
 	struct page *page;
 	struct list_head *head = &sbi->fsync_node_list;
 	unsigned long flags;
 	unsigned int cur_seq_id = 0;
 	int ret2, ret = 0;
+	errseq_t since = filemap_sample_wb_err(mapping);
 
 	while (seq_id && cur_seq_id < seq_id) {
 		spin_lock_irqsave(&sbi->fsync_node_lock, flags);
@@ -2088,7 +2090,7 @@ int f2fs_wait_on_node_pages_writeback(struct f2fs_sb_info *sbi,
 			break;
 	}
 
-	ret2 = filemap_check_errors(NODE_MAPPING(sbi));
+	ret2 = filemap_check_wb_err(mapping, since);
 	if (!ret)
 		ret = ret2;
 
-- 
2.39.0.rc2.1.gbd5df96b79


From 78f7a1800f18b567204a58b68acc805eed0c86e6 Mon Sep 17 00:00:00 2001
From: "Matthew Wilcox (Oracle)" <willy@infradead.org>
Date: Mon, 9 Jan 2023 05:18:16 +0000
Subject: [PATCH 04/11] fuse: Convert fuse_flush() to use
 file_check_and_advance_wb_err()

As with fsync, use the newer file_check_and_advance_wb_err() instead
of filemap_check_errors().

Signed-off-by: Matthew Wilcox (Oracle) <willy@infradead.org>
---
 fs/fuse/file.c | 3 +--
 1 file changed, 1 insertion(+), 2 deletions(-)

diff --git a/fs/fuse/file.c b/fs/fuse/file.c
index 875314ee6..7174646dd 100644
--- a/fs/fuse/file.c
+++ b/fs/fuse/file.c
@@ -500,11 +500,10 @@ static int fuse_flush(struct file *file, fl_owner_t id)
 	fuse_sync_writes(inode);
 	inode_unlock(inode);
 
-	err = filemap_check_errors(file->f_mapping);
+	err = file_check_and_advance_wb_err(file);
 	if (err)
 		return err;
 
-	err = 0;
 	if (fm->fc->no_flush)
 		goto inval_attr_out;
 
-- 
2.39.0.rc2.1.gbd5df96b79


From 7166f721f5ed8d3ad77f70fb1862d901b5153a48 Mon Sep 17 00:00:00 2001
From: "Matthew Wilcox (Oracle)" <willy@infradead.org>
Date: Mon, 9 Jan 2023 05:18:17 +0000
Subject: [PATCH 05/11] page-writeback: Convert folio_write_one() to use an
 errseq

Use the errseq infrastructure to detect an error due to writing
back this folio instead of the old error checking code.

Signed-off-by: Matthew Wilcox (Oracle) <willy@infradead.org>
---
 mm/page-writeback.c | 17 ++++++++---------
 1 file changed, 8 insertions(+), 9 deletions(-)

diff --git a/mm/page-writeback.c b/mm/page-writeback.c
index ad608ef2a..491b70dad 100644
--- a/mm/page-writeback.c
+++ b/mm/page-writeback.c
@@ -2610,15 +2610,12 @@ int do_writepages(struct address_space *mapping, struct writeback_control *wbc)
  *
  * The folio must be locked by the caller and will be unlocked upon return.
  *
- * Note that the mapping's AS_EIO/AS_ENOSPC flags will be cleared when this
- * function returns.
- *
  * Return: %0 on success, negative error code otherwise
  */
 int folio_write_one(struct folio *folio)
 {
 	struct address_space *mapping = folio->mapping;
-	int ret = 0;
+	int err = 0;
 	struct writeback_control wbc = {
 		.sync_mode = WB_SYNC_ALL,
 		.nr_to_write = folio_nr_pages(folio),
@@ -2629,18 +2626,20 @@ int folio_write_one(struct folio *folio)
 	folio_wait_writeback(folio);
 
 	if (folio_clear_dirty_for_io(folio)) {
+		errseq_t since = filemap_sample_wb_err(mapping);
+
 		folio_get(folio);
-		ret = mapping->a_ops->writepage(&folio->page, &wbc);
-		if (ret == 0)
+		err = mapping->a_ops->writepage(&folio->page, &wbc);
+		if (!err) {
 			folio_wait_writeback(folio);
+			err = filemap_check_wb_err(mapping, since);
+		}
 		folio_put(folio);
 	} else {
 		folio_unlock(folio);
 	}
 
-	if (!ret)
-		ret = filemap_check_errors(mapping);
-	return ret;
+	return err;
 }
 EXPORT_SYMBOL(folio_write_one);
 
-- 
2.39.0.rc2.1.gbd5df96b79


From a36f01336e627c529e3a590614c191cc94b6dcb8 Mon Sep 17 00:00:00 2001
From: "Matthew Wilcox (Oracle)" <willy@infradead.org>
Date: Mon, 9 Jan 2023 05:18:18 +0000
Subject: [PATCH 06/11] filemap: Convert filemap_write_and_wait_range() to use
 errseq

Use the errseq APIs to discover writeback errors instead of
filemap_check_errors().  This gives us more precise information
about whether this writeback generated the error.  This will no
longer clear errors, so they will be visible to other users, which
is what we want.  Take this opportunity to de-indent
filemap_write_and_wait_range().

Signed-off-by: Matthew Wilcox (Oracle) <willy@infradead.org>
---
 mm/filemap.c | 31 ++++++++++++++++---------------
 1 file changed, 16 insertions(+), 15 deletions(-)

diff --git a/mm/filemap.c b/mm/filemap.c
index 48daedc22..c72b2e114 100644
--- a/mm/filemap.c
+++ b/mm/filemap.c
@@ -659,26 +659,27 @@ EXPORT_SYMBOL_GPL(filemap_range_has_writeback);
 int filemap_write_and_wait_range(struct address_space *mapping,
 				 loff_t lstart, loff_t lend)
 {
-	int err = 0, err2;
+	int err;
+	errseq_t since;
 
 	if (lend < lstart)
 		return 0;
+	if (!mapping_needs_writeback(mapping))
+		return 0;
 
-	if (mapping_needs_writeback(mapping)) {
-		err = __filemap_fdatawrite_range(mapping, lstart, lend,
-						 WB_SYNC_ALL);
-		/*
-		 * Even if the above returned error, the pages may be
-		 * written partially (e.g. -ENOSPC), so we wait for it.
-		 * But the -EIO is special case, it may indicate the worst
-		 * thing (e.g. bug) happened, so we avoid waiting for it.
-		 */
-		if (err != -EIO)
-			__filemap_fdatawait_range(mapping, lstart, lend);
-	}
-	err2 = filemap_check_errors(mapping);
+	since = filemap_sample_wb_err(mapping);
+	err = __filemap_fdatawrite_range(mapping, lstart, lend, WB_SYNC_ALL);
+	/*
+	 * Even if the above returned an error, the pages may be written
+	 * partially (e.g. -ENOSPC), so we wait for it.  But the -EIO
+	 * is a special case, it may indicate the worst thing (e.g. bug)
+	 * happened, so we avoid waiting for it.
+	 */
+	if (err != -EIO)
+		__filemap_fdatawait_range(mapping, lstart, lend);
 	if (!err)
-		err = err2;
+		err = filemap_check_wb_err(mapping, since);
+
 	return err;
 }
 EXPORT_SYMBOL(filemap_write_and_wait_range);
-- 
2.39.0.rc2.1.gbd5df96b79


From b73b8741ac72e250d09d5dec66ab4f9162b5b351 Mon Sep 17 00:00:00 2001
From: "Matthew Wilcox (Oracle)" <willy@infradead.org>
Date: Mon, 9 Jan 2023 05:18:19 +0000
Subject: [PATCH 07/11] filemap: Convert filemap_fdatawait_range() to errseq

This removes the unwelcome behaviour of clearing the
errors in the address space, which is the same behaviour as
filemap_fdatawait_range_keep_errors(), so unify the two functions.
We can also get rid of filemap_fdatawait_keep_errors() as it is now the
same as filemap_fdatawait()

Signed-off-by: Matthew Wilcox (Oracle) <willy@infradead.org>
---
 include/linux/pagemap.h |  7 +++---
 mm/filemap.c            | 51 +----------------------------------------
 2 files changed, 5 insertions(+), 53 deletions(-)

diff --git a/include/linux/pagemap.h b/include/linux/pagemap.h
index 29e1f9e76..985fd4773 100644
--- a/include/linux/pagemap.h
+++ b/include/linux/pagemap.h
@@ -33,16 +33,17 @@ int invalidate_inode_pages2_range(struct address_space *mapping,
 int write_inode_now(struct inode *, int sync);
 int filemap_fdatawrite(struct address_space *);
 int filemap_flush(struct address_space *);
-int filemap_fdatawait_keep_errors(struct address_space *mapping);
 int filemap_fdatawait_range(struct address_space *, loff_t lstart, loff_t lend);
-int filemap_fdatawait_range_keep_errors(struct address_space *mapping,
-		loff_t start_byte, loff_t end_byte);
 
 static inline int filemap_fdatawait(struct address_space *mapping)
 {
 	return filemap_fdatawait_range(mapping, 0, LLONG_MAX);
 }
 
+#define filemap_fdatawait_range_keep_errors(mapping, start, end)	\
+	filemap_fdatawait_range(mapping, start, end)
+#define filemap_fdatawait_keep_errors(mapping)	filemap_fdatawait(mapping)
+
 bool filemap_range_has_page(struct address_space *, loff_t lstart, loff_t lend);
 int filemap_write_and_wait_range(struct address_space *mapping,
 		loff_t lstart, loff_t lend);
diff --git a/mm/filemap.c b/mm/filemap.c
index c72b2e114..887520db1 100644
--- a/mm/filemap.c
+++ b/mm/filemap.c
@@ -526,43 +526,17 @@ static void __filemap_fdatawait_range(struct address_space *mapping,
  * in the given range and wait for all of them.  Check error status of
  * the address space and return it.
  *
- * Since the error status of the address space is cleared by this function,
- * callers are responsible for checking the return value and handling and/or
- * reporting the error.
- *
  * Return: error status of the address space.
  */
 int filemap_fdatawait_range(struct address_space *mapping, loff_t start_byte,
 			    loff_t end_byte)
-{
-	__filemap_fdatawait_range(mapping, start_byte, end_byte);
-	return filemap_check_errors(mapping);
-}
-EXPORT_SYMBOL(filemap_fdatawait_range);
-
-/**
- * filemap_fdatawait_range_keep_errors - wait for writeback to complete
- * @mapping:		address space structure to wait for
- * @start_byte:		offset in bytes where the range starts
- * @end_byte:		offset in bytes where the range ends (inclusive)
- *
- * Walk the list of under-writeback pages of the given address space in the
- * given range and wait for all of them.  Unlike filemap_fdatawait_range(),
- * this function does not clear error status of the address space.
- *
- * Use this function if callers don't handle errors themselves.  Expected
- * call sites are system-wide / filesystem-wide data flushers: e.g. sync(2),
- * fsfreeze(8)
- */
-int filemap_fdatawait_range_keep_errors(struct address_space *mapping,
-		loff_t start_byte, loff_t end_byte)
 {
 	errseq_t since = filemap_sample_wb_err(mapping);
 
 	__filemap_fdatawait_range(mapping, start_byte, end_byte);
 	return filemap_check_wb_err(mapping, since);
 }
-EXPORT_SYMBOL(filemap_fdatawait_range_keep_errors);
+EXPORT_SYMBOL(filemap_fdatawait_range);
 
 /**
  * file_fdatawait_range - wait for writeback to complete
@@ -589,29 +563,6 @@ int file_fdatawait_range(struct file *file, loff_t start_byte, loff_t end_byte)
 }
 EXPORT_SYMBOL(file_fdatawait_range);
 
-/**
- * filemap_fdatawait_keep_errors - wait for writeback without clearing errors
- * @mapping: address space structure to wait for
- *
- * Walk the list of under-writeback pages of the given address space
- * and wait for all of them.  Unlike filemap_fdatawait(), this function
- * does not clear error status of the address space.
- *
- * Use this function if callers don't handle errors themselves.  Expected
- * call sites are system-wide / filesystem-wide data flushers: e.g. sync(2),
- * fsfreeze(8)
- *
- * Return: error status of the address space.
- */
-int filemap_fdatawait_keep_errors(struct address_space *mapping)
-{
-	errseq_t since = filemap_sample_wb_err(mapping);
-
-	__filemap_fdatawait_range(mapping, 0, LLONG_MAX);
-	return filemap_check_wb_err(mapping, since);
-}
-EXPORT_SYMBOL(filemap_fdatawait_keep_errors);
-
 /* Returns true if writeback might be needed or already in progress. */
 static bool mapping_needs_writeback(struct address_space *mapping)
 {
-- 
2.39.0.rc2.1.gbd5df96b79


From d9231365ca68f0e13762b4cc20370fc38ddb48f3 Mon Sep 17 00:00:00 2001
From: "Matthew Wilcox (Oracle)" <willy@infradead.org>
Date: Mon, 9 Jan 2023 05:18:20 +0000
Subject: [PATCH 08/11] cifs: Remove call to filemap_check_wb_err()

filemap_write_and_wait() now calls filemap_check_wb_err(), so we cannot
glean any additional information by calling it ourselves.  It may also
be misleading as it will pick up on any errors since the beginning of
time which may well be since before this program opened the file.

Signed-off-by: Matthew Wilcox (Oracle) <willy@infradead.org>
---
 fs/cifs/file.c | 8 +++-----
 1 file changed, 3 insertions(+), 5 deletions(-)

diff --git a/fs/cifs/file.c b/fs/cifs/file.c
index 22dfc1f8b..7e7ee26cf 100644
--- a/fs/cifs/file.c
+++ b/fs/cifs/file.c
@@ -3042,14 +3042,12 @@ int cifs_flush(struct file *file, fl_owner_t id)
 	int rc = 0;
 
 	if (file->f_mode & FMODE_WRITE)
-		rc = filemap_write_and_wait(inode->i_mapping);
+		rc = filemap_write_and_wait(file->f_mapping);
 
 	cifs_dbg(FYI, "Flush inode %p file %p rc %d\n", inode, file, rc);
-	if (rc) {
-		/* get more nuanced writeback errors */
-		rc = filemap_check_wb_err(file->f_mapping, 0);
+	if (rc)
 		trace_cifs_flush_err(inode->i_ino, rc);
-	}
+
 	return rc;
 }
 
-- 
2.39.0.rc2.1.gbd5df96b79


From 3fd129fd56196ad70afd70710477a9ada29b073a Mon Sep 17 00:00:00 2001
From: "Matthew Wilcox (Oracle)" <willy@infradead.org>
Date: Mon, 9 Jan 2023 05:18:21 +0000
Subject: [PATCH 09/11] mm: Remove AS_EIO and AS_ENOSPC

All users are now converted to use wb_err, so convert the
remaining comments, drop the unused filemap_check_errors()
and remove the compatibility code in mapping_set_error() and
file_check_and_advance_wb_err().

Signed-off-by: Matthew Wilcox (Oracle) <willy@infradead.org>
---
 fs/btrfs/extent_io.c    |  6 +++---
 fs/f2fs/data.c          |  2 +-
 include/linux/pagemap.h | 20 +++++---------------
 mm/filemap.c            | 21 ---------------------
 4 files changed, 9 insertions(+), 40 deletions(-)

diff --git a/fs/btrfs/extent_io.c b/fs/btrfs/extent_io.c
index 9bd32daa9..f1c3572b6 100644
--- a/fs/btrfs/extent_io.c
+++ b/fs/btrfs/extent_io.c
@@ -2386,7 +2386,7 @@ static void set_btree_ioerr(struct page *page, struct extent_buffer *eb)
 	 * or the content of some node/leaf from a past generation that got
 	 * cowed or deleted and is no longer valid.
 	 *
-	 * Note: setting AS_EIO/AS_ENOSPC in the btree inode's i_mapping would
+	 * Note: setting wb_err in the btree inode's i_mapping would
 	 * not be enough - we need to distinguish between log tree extents vs
 	 * non-log tree extents, and the next filemap_fdatawait_range() call
 	 * will catch and clear such errors in the mapping - and that call might
@@ -2397,10 +2397,10 @@ static void set_btree_ioerr(struct page *page, struct extent_buffer *eb)
 	 * set (since it's a runtime flag, not persisted on disk).
 	 *
 	 * Using the flags below in the btree inode also makes us achieve the
-	 * goal of AS_EIO/AS_ENOSPC when writepages() returns success, started
+	 * goal of wb_err when writepages() returns success, started
 	 * writeback for all dirty pages and before filemap_fdatawait_range()
 	 * is called, the writeback for all dirty pages had already finished
-	 * with errors - because we were not using AS_EIO/AS_ENOSPC,
+	 * with errors - because we were not using wb_err,
 	 * filemap_fdatawait_range() would return success, as it could not know
 	 * that writeback errors happened (the pages were no longer tagged for
 	 * writeback).
diff --git a/fs/f2fs/data.c b/fs/f2fs/data.c
index 97e816590..566fe19ca 100644
--- a/fs/f2fs/data.c
+++ b/fs/f2fs/data.c
@@ -2913,7 +2913,7 @@ int f2fs_write_single_data_page(struct page *page, int *submitted,
 	redirty_page_for_writepage(wbc, page);
 	/*
 	 * pageout() in MM traslates EAGAIN, so calls handle_write_error()
-	 * -> mapping_set_error() -> set_bit(AS_EIO, ...).
+	 * -> mapping_set_error().
 	 * file_write_and_wait_range() will see EIO error, which is critical
 	 * to return value of fsync() followed by atomic_write failure to user.
 	 */
diff --git a/include/linux/pagemap.h b/include/linux/pagemap.h
index 985fd4773..573b8cce3 100644
--- a/include/linux/pagemap.h
+++ b/include/linux/pagemap.h
@@ -51,7 +51,6 @@ int __filemap_fdatawrite_range(struct address_space *mapping,
 		loff_t start, loff_t end, int sync_mode);
 int filemap_fdatawrite_range(struct address_space *mapping,
 		loff_t start, loff_t end);
-int filemap_check_errors(struct address_space *mapping);
 void __filemap_set_wb_err(struct address_space *mapping, int err);
 int filemap_fdatawrite_wbc(struct address_space *mapping,
 			   struct writeback_control *wbc);
@@ -192,14 +191,11 @@ static inline bool mapping_shrinkable(struct address_space *mapping)
  * Bits in mapping->flags.
  */
 enum mapping_flags {
-	AS_EIO		= 0,	/* IO error on async write */
-	AS_ENOSPC	= 1,	/* ENOSPC on async write */
-	AS_MM_ALL_LOCKS	= 2,	/* under mm_take_all_locks() */
-	AS_UNEVICTABLE	= 3,	/* e.g., ramdisk, SHM_LOCK */
-	AS_EXITING	= 4, 	/* final truncate in progress */
-	/* writeback related tags are not used */
-	AS_NO_WRITEBACK_TAGS = 5,
-	AS_LARGE_FOLIO_SUPPORT = 6,
+	AS_MM_ALL_LOCKS	= 0,	/* under mm_take_all_locks() */
+	AS_UNEVICTABLE,		/* e.g., ramdisk, SHM_LOCK */
+	AS_EXITING, 		/* final truncate in progress */
+	AS_NO_WRITEBACK_TAGS,	/* writeback related tags are not used */
+	AS_LARGE_FOLIO_SUPPORT,
 };
 
 /**
@@ -227,12 +223,6 @@ static inline void mapping_set_error(struct address_space *mapping, int error)
 	/* Record it in superblock */
 	if (mapping->host)
 		errseq_set(&mapping->host->i_sb->s_wb_err, error);
-
-	/* Record it in flags for now, for legacy callers */
-	if (error == -ENOSPC)
-		set_bit(AS_ENOSPC, &mapping->flags);
-	else
-		set_bit(AS_EIO, &mapping->flags);
 }
 
 static inline void mapping_set_unevictable(struct address_space *mapping)
diff --git a/mm/filemap.c b/mm/filemap.c
index 887520db1..7bf8442bc 100644
--- a/mm/filemap.c
+++ b/mm/filemap.c
@@ -341,20 +341,6 @@ void delete_from_page_cache_batch(struct address_space *mapping,
 		filemap_free_folio(mapping, fbatch->folios[i]);
 }
 
-int filemap_check_errors(struct address_space *mapping)
-{
-	int ret = 0;
-	/* Check for outstanding write errors */
-	if (test_bit(AS_ENOSPC, &mapping->flags) &&
-	    test_and_clear_bit(AS_ENOSPC, &mapping->flags))
-		ret = -ENOSPC;
-	if (test_bit(AS_EIO, &mapping->flags) &&
-	    test_and_clear_bit(AS_EIO, &mapping->flags))
-		ret = -EIO;
-	return ret;
-}
-EXPORT_SYMBOL(filemap_check_errors);
-
 /**
  * filemap_fdatawrite_wbc - start writeback on mapping dirty pages in range
  * @mapping:	address space structure to write
@@ -684,13 +670,6 @@ int file_check_and_advance_wb_err(struct file *file)
 		spin_unlock(&file->f_lock);
 	}
 
-	/*
-	 * We're mostly using this function as a drop in replacement for
-	 * filemap_check_errors. Clear AS_EIO/AS_ENOSPC to emulate the effect
-	 * that the legacy code would have had on these flags.
-	 */
-	clear_bit(AS_EIO, &mapping->flags);
-	clear_bit(AS_ENOSPC, &mapping->flags);
 	return err;
 }
 EXPORT_SYMBOL(file_check_and_advance_wb_err);
-- 
2.39.0.rc2.1.gbd5df96b79


From 1aa4b3d83524b1e545eeed01c5f9a9b4dbcf83bc Mon Sep 17 00:00:00 2001
From: "Matthew Wilcox (Oracle)" <willy@infradead.org>
Date: Mon, 9 Jan 2023 05:18:22 +0000
Subject: [PATCH 10/11] mm: Remove filemap_fdatawait_range_keep_errors()

This function is now the same as filemap_fdatawait_range(), so change
both callers to use that instead.

Signed-off-by: Matthew Wilcox (Oracle) <willy@infradead.org>
---
 fs/jbd2/commit.c        | 12 +++++-------
 include/linux/pagemap.h |  2 --
 2 files changed, 5 insertions(+), 9 deletions(-)

diff --git a/fs/jbd2/commit.c b/fs/jbd2/commit.c
index 4810438b7..36aa1b117 100644
--- a/fs/jbd2/commit.c
+++ b/fs/jbd2/commit.c
@@ -221,11 +221,10 @@ EXPORT_SYMBOL(jbd2_submit_inode_data);
 int jbd2_wait_inode_data(journal_t *journal, struct jbd2_inode *jinode)
 {
 	if (!jinode || !(jinode->i_flags & JI_WAIT_DATA) ||
-		!jinode->i_vfs_inode || !jinode->i_vfs_inode->i_mapping)
+	    !jinode->i_vfs_inode || !jinode->i_vfs_inode->i_mapping)
 		return 0;
-	return filemap_fdatawait_range_keep_errors(
-		jinode->i_vfs_inode->i_mapping, jinode->i_dirty_start,
-		jinode->i_dirty_end);
+	return filemap_fdatawait_range(jinode->i_vfs_inode->i_mapping,
+				jinode->i_dirty_start, jinode->i_dirty_end);
 }
 EXPORT_SYMBOL(jbd2_wait_inode_data);
 
@@ -270,9 +269,8 @@ int jbd2_journal_finish_inode_data_buffers(struct jbd2_inode *jinode)
 {
 	struct address_space *mapping = jinode->i_vfs_inode->i_mapping;
 
-	return filemap_fdatawait_range_keep_errors(mapping,
-						   jinode->i_dirty_start,
-						   jinode->i_dirty_end);
+	return filemap_fdatawait_range(mapping, jinode->i_dirty_start,
+			jinode->i_dirty_end);
 }
 
 /*
diff --git a/include/linux/pagemap.h b/include/linux/pagemap.h
index 573b8cce3..7fe2a5ec1 100644
--- a/include/linux/pagemap.h
+++ b/include/linux/pagemap.h
@@ -40,8 +40,6 @@ static inline int filemap_fdatawait(struct address_space *mapping)
 	return filemap_fdatawait_range(mapping, 0, LLONG_MAX);
 }
 
-#define filemap_fdatawait_range_keep_errors(mapping, start, end)	\
-	filemap_fdatawait_range(mapping, start, end)
 #define filemap_fdatawait_keep_errors(mapping)	filemap_fdatawait(mapping)
 
 bool filemap_range_has_page(struct address_space *, loff_t lstart, loff_t lend);
-- 
2.39.0.rc2.1.gbd5df96b79


From 61b1c1840d562ea5115cde654fdbdc5930643abb Mon Sep 17 00:00:00 2001
From: "Matthew Wilcox (Oracle)" <willy@infradead.org>
Date: Mon, 9 Jan 2023 05:18:23 +0000
Subject: [PATCH 11/11] mm: Remove filemap_fdatawait_keep_errors()

This function is now the same as filemap_fdatawait(), so change all
callers to use that instead.  Remove the comments which talk about keeping
the errors around for other callers as this is now the only behaviour.

Signed-off-by: Matthew Wilcox (Oracle) <willy@infradead.org>
---
 block/bdev.c            | 8 +-------
 fs/fs-writeback.c       | 7 +------
 fs/xfs/scrub/bmap.c     | 2 +-
 include/linux/pagemap.h | 2 --
 4 files changed, 3 insertions(+), 16 deletions(-)

diff --git a/block/bdev.c b/block/bdev.c
index edc110d90..2fae19f0a 100644
--- a/block/bdev.c
+++ b/block/bdev.c
@@ -1053,13 +1053,7 @@ void sync_bdevs(bool wait)
 		if (!atomic_read(&bdev->bd_openers)) {
 			; /* skip */
 		} else if (wait) {
-			/*
-			 * We keep the error status of individual mapping so
-			 * that applications can catch the writeback error using
-			 * fsync(2). See filemap_fdatawait_keep_errors() for
-			 * details.
-			 */
-			filemap_fdatawait_keep_errors(inode->i_mapping);
+			filemap_fdatawait(inode->i_mapping);
 		} else {
 			filemap_fdatawrite(inode->i_mapping);
 		}
diff --git a/fs/fs-writeback.c b/fs/fs-writeback.c
index 6fba5a521..dc0158125 100644
--- a/fs/fs-writeback.c
+++ b/fs/fs-writeback.c
@@ -2598,12 +2598,7 @@ static void wait_sb_inodes(struct super_block *sb)
 		spin_unlock(&inode->i_lock);
 		rcu_read_unlock();
 
-		/*
-		 * We keep the error status of individual mapping so that
-		 * applications can catch the writeback error using fsync(2).
-		 * See filemap_fdatawait_keep_errors() for details.
-		 */
-		filemap_fdatawait_keep_errors(mapping);
+		filemap_fdatawait(mapping);
 
 		cond_resched();
 
diff --git a/fs/xfs/scrub/bmap.c b/fs/xfs/scrub/bmap.c
index d50d0eab1..8f169047d 100644
--- a/fs/xfs/scrub/bmap.c
+++ b/fs/xfs/scrub/bmap.c
@@ -64,7 +64,7 @@ xchk_setup_inode_bmap(
 		 */
 		error = filemap_fdatawrite(mapping);
 		if (!error)
-			error = filemap_fdatawait_keep_errors(mapping);
+			error = filemap_fdatawait(mapping);
 		if (error && (error != -ENOSPC && error != -EIO))
 			goto out;
 	}
diff --git a/include/linux/pagemap.h b/include/linux/pagemap.h
index 7fe2a5ec1..69190335d 100644
--- a/include/linux/pagemap.h
+++ b/include/linux/pagemap.h
@@ -40,8 +40,6 @@ static inline int filemap_fdatawait(struct address_space *mapping)
 	return filemap_fdatawait_range(mapping, 0, LLONG_MAX);
 }
 
-#define filemap_fdatawait_keep_errors(mapping)	filemap_fdatawait(mapping)
-
 bool filemap_range_has_page(struct address_space *, loff_t lstart, loff_t lend);
 int filemap_write_and_wait_range(struct address_space *mapping,
 		loff_t lstart, loff_t lend);
-- 
2.39.0.rc2.1.gbd5df96b79

