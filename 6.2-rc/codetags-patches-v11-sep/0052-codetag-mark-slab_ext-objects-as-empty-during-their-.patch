From 2f6f2eb27f8de2a76df9c2f1943c0729bc2f7969 Mon Sep 17 00:00:00 2001
From: Suren Baghdasaryan <surenb@google.com>
Date: Mon, 13 Feb 2023 18:29:20 +0000
Subject: [PATCH 52/53] codetag: mark slab_ext objects as empty during their
 allocation

If slabobj_ext vector allocation for a slab object fails and later on it
succeeds for another object, the slabobj_ext for the original object will
be NULL and will be flagged if CONFIG_MEM_ALLOC_PROFILING_DEBUG is enabled.
Mark all slabobj_ext objects in a newly allocated slabobj_ext vector
as empty to avoid this.

Signed-off-by: Suren Baghdasaryan <surenb@google.com>
---
 mm/slab_common.c | 8 +++++++-
 1 file changed, 7 insertions(+), 1 deletion(-)

diff --git a/mm/slab_common.c b/mm/slab_common.c
index 11d2b35b8..4a87c642f 100644
--- a/mm/slab_common.c
+++ b/mm/slab_common.c
@@ -217,7 +217,7 @@ int alloc_slab_obj_exts(struct slab *slab, struct kmem_cache *s,
 {
 	unsigned int objects = objs_per_slab(s, slab);
 	unsigned long obj_exts;
-	void *vec;
+	struct slabobj_ext *vec;
 
 	gfp &= ~OBJCGS_CLEAR_MASK;
 	/* Prevent recursive extension vector allocation */
@@ -232,6 +232,12 @@ int alloc_slab_obj_exts(struct slab *slab, struct kmem_cache *s,
 	obj_exts |= MEMCG_DATA_OBJEXTS;
 #endif
 	if (new_slab) {
+#ifdef CONFIG_MEM_ALLOC_PROFILING_DEBUG
+		unsigned int i;
+
+		for (i = 0; i < objects; i++)
+			set_codetag_empty(&vec[i].ref);
+#endif
 		/*
 		 * If the slab is brand new and nobody can yet access its
 		 * obj_exts, no synchronization is required and obj_exts can
-- 
2.39.1.418.g7876265d61

