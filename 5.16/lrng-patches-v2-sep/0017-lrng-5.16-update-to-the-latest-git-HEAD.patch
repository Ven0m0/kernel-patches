From 7320df72eb8d32d86213291163eb6f4a9c82a9e4 Mon Sep 17 00:00:00 2001
From: Piotr Gorski <lucjan.lucjanov@gmail.com>
Date: Fri, 18 Mar 2022 23:35:24 +0100
Subject: [PATCH 17/17] lrng-5.16: update to the latest git HEAD

Signed-off-by: Piotr Gorski <lucjan.lucjanov@gmail.com>
---
 drivers/char/lrng/Kconfig              | 36 +++++++++++++++++++++-----
 drivers/char/lrng/lrng_drng.c          |  4 +--
 drivers/char/lrng/lrng_es_archrandom.c |  4 +--
 drivers/char/lrng/lrng_es_aux.c        | 13 +++++-----
 drivers/char/lrng/lrng_es_irq.c        | 27 ++++++++++---------
 drivers/char/lrng/lrng_es_mgr.c        |  4 +--
 drivers/char/lrng/lrng_health.c        | 26 +++++++++----------
 drivers/char/lrng/lrng_interfaces.c    |  4 +--
 drivers/char/lrng/lrng_kcapi_hash.c    |  2 +-
 drivers/char/lrng/lrng_numa.c          |  2 +-
 drivers/char/lrng/lrng_proc.c          | 14 ++++++++--
 drivers/char/lrng/lrng_selftest.c      |  6 ++---
 drivers/char/lrng/lrng_testing.c       | 16 ++++++------
 13 files changed, 96 insertions(+), 62 deletions(-)

diff --git a/drivers/char/lrng/Kconfig b/drivers/char/lrng/Kconfig
index 6f969ac6e..658f89f6b 100644
--- a/drivers/char/lrng/Kconfig
+++ b/drivers/char/lrng/Kconfig
@@ -3,14 +3,36 @@
 # Linux Random Number Generator configuration
 #
 
-menuconfig LRNG
-	bool "Linux Random Number Generator"
+choice
+	prompt "Random Number Generator Implementation"
+	default RANDOM_DEFAULT_IMPL
+	help
+	  Select the random number generator implementation that is
+	  accessible via /dev/random, /dev/urandom, getrandom(2), and
+	  the in-kernel function get_random_bytes.
+
+config RANDOM_DEFAULT_IMPL
+	bool "Default Implementation"
+	help
+	  The default random number generator as provided with
+	  drivers/char/random.c is selected with this option.
+
+config LRNG
+	bool "LRNG Implementation with SP800-90A/B/C compliance"
 	select CRYPTO_LIB_SHA256 if CRYPTO
 	help
-	  The Linux Random Number Generator (LRNG) is the replacement
-	  of the existing /dev/random provided with drivers/char/random.c.
-	  It generates entropy from different noise sources and
-	  delivers significant entropy during boot.
+	  The Linux Random Number Generator (LRNG) generates entropy
+	  from different entropy sources. Each entropy source can
+	  be enabled and configured independently. The interrupt
+	  entropy source can be configured to be SP800-90B compliant.
+	  The entire LRNG can be configured to be SP800-90C compliant.
+	  Runtime-switchable cryptographic support is available.
+	  The LRNG delivers significant entropy during boot.
+
+endchoice
+
+menu "Linux Random Number Generator Configuration"
+	depends on LRNG
 
 if LRNG
 
@@ -587,3 +609,5 @@ config LRNG_SELFTEST_PANIC
 endif # LRNG_SELFTEST
 
 endif # LRNG
+
+endmenu # LRNG
diff --git a/drivers/char/lrng/lrng_drng.c b/drivers/char/lrng/lrng_drng.c
index 1ab533263..b1d89a6f5 100644
--- a/drivers/char/lrng/lrng_drng.c
+++ b/drivers/char/lrng/lrng_drng.c
@@ -198,7 +198,7 @@ static void lrng_drng_inject(struct lrng_drng *drng,
 /*
  * Perform the seeding of the DRNG with data from noise source
  */
-static inline void _lrng_drng_seed(struct lrng_drng *drng)
+static void _lrng_drng_seed(struct lrng_drng *drng)
 {
 	struct entropy_buf seedbuf __aligned(LRNG_KCAPI_ALIGN);
 
@@ -243,7 +243,7 @@ static void lrng_drng_seed(struct lrng_drng *drng)
 	}
 }
 
-static inline void _lrng_drng_seed_work(struct lrng_drng *drng, u32 node)
+static void _lrng_drng_seed_work(struct lrng_drng *drng, u32 node)
 {
 	pr_debug("reseed triggered by interrupt noise source for DRNG on NUMA node %d\n",
 		 node);
diff --git a/drivers/char/lrng/lrng_es_archrandom.c b/drivers/char/lrng/lrng_es_archrandom.c
index ecc74b93d..337f84fab 100644
--- a/drivers/char/lrng/lrng_es_archrandom.c
+++ b/drivers/char/lrng/lrng_es_archrandom.c
@@ -78,8 +78,8 @@ static u32 lrng_get_arch_data(u8 *outbuf, u32 requested_bits)
 	return requested_bits;
 }
 
-static inline u32 lrng_get_arch_data_compress(u8 *outbuf, u32 requested_bits,
-					      u32 data_multiplier)
+static u32 lrng_get_arch_data_compress(u8 *outbuf, u32 requested_bits,
+				       u32 data_multiplier)
 {
 	SHASH_DESC_ON_STACK(shash, NULL);
 	const struct lrng_crypto_cb *crypto_cb;
diff --git a/drivers/char/lrng/lrng_es_aux.c b/drivers/char/lrng/lrng_es_aux.c
index cd51c7311..c8a040d29 100644
--- a/drivers/char/lrng/lrng_es_aux.c
+++ b/drivers/char/lrng/lrng_es_aux.c
@@ -51,7 +51,7 @@ u32 lrng_avail_aux_entropy(void)
 }
 
 /* Set the digest size of the used hash in bytes */
-static inline void lrng_set_digestsize(u32 digestsize)
+static void lrng_set_digestsize(u32 digestsize)
 {
 	struct lrng_pool *pool = &lrng_pool;
 	u32 ent_bits = atomic_xchg_relaxed(&pool->aux_entropy_bits, 0),
@@ -197,7 +197,7 @@ int lrng_pool_insert_aux(const u8 *inbuf, u32 inbuflen, u32 entropy_bits)
  * @requested_bits: Requested amount of entropy
  * @return: amount of entropy in outbuf in bits.
  */
-static inline u32 lrng_get_aux_pool(u8 *outbuf, u32 requested_bits)
+static u32 lrng_get_aux_pool(u8 *outbuf, u32 requested_bits)
 {
 	struct lrng_pool *pool = &lrng_pool;
 	struct shash_desc *shash = (struct shash_desc *)pool->aux_pool;
@@ -206,7 +206,7 @@ static inline u32 lrng_get_aux_pool(u8 *outbuf, u32 requested_bits)
 	unsigned long flags;
 	void *hash;
 	u32 collected_ent_bits, returned_ent_bits, unused_bits = 0,
-	    digestsize;
+	    digestsize, requested_bits_osr;
 	u8 aux_output[LRNG_MAX_DIGESTSIZE];
 
 	if (unlikely(!pool->initialized))
@@ -220,19 +220,20 @@ static inline u32 lrng_get_aux_pool(u8 *outbuf, u32 requested_bits)
 
 	/* Ensure that no more than the size of aux_pool can be requested */
 	requested_bits = min_t(u32, requested_bits, (LRNG_MAX_DIGESTSIZE << 3));
+	requested_bits_osr = requested_bits + lrng_compress_osr();
 
 	/* Cap entropy with entropy counter from aux pool and the used digest */
 	collected_ent_bits = min_t(u32, digestsize << 3,
 			       atomic_xchg_relaxed(&pool->aux_entropy_bits, 0));
 
 	/* We collected too much entropy and put the overflow back */
-	if (collected_ent_bits > (requested_bits + lrng_compress_osr())) {
+	if (collected_ent_bits > requested_bits_osr) {
 		/* Amount of bits we collected too much */
-		unused_bits = collected_ent_bits - requested_bits;
+		unused_bits = collected_ent_bits - requested_bits_osr;
 		/* Put entropy back */
 		atomic_add(unused_bits, &pool->aux_entropy_bits);
 		/* Fix collected entropy */
-		collected_ent_bits = requested_bits;
+		collected_ent_bits = requested_bits_osr;
 	}
 
 	/* Apply oversampling: discount requested oversampling rate */
diff --git a/drivers/char/lrng/lrng_es_irq.c b/drivers/char/lrng/lrng_es_irq.c
index b97fec244..6b13ff97d 100644
--- a/drivers/char/lrng/lrng_es_irq.c
+++ b/drivers/char/lrng/lrng_es_irq.c
@@ -102,13 +102,13 @@ static atomic_t lrng_gcd_history_ptr = ATOMIC_INIT(-1);
 /* The common divisor for all timestamps */
 static u32 lrng_gcd_timer = 0;
 
-static inline bool lrng_gcd_tested(void)
+static bool lrng_gcd_tested(void)
 {
 	return (lrng_gcd_timer != 0);
 }
 
 /* Set the GCD for use in IRQ ES - if 0, the GCD calculation is restarted. */
-static inline void _lrng_gcd_set(u32 running_gcd)
+static void _lrng_gcd_set(u32 running_gcd)
 {
 	lrng_gcd_timer = running_gcd;
 	/* Ensure that update to global variable lrng_gcd_timer is visible */
@@ -190,20 +190,20 @@ static bool lrng_pool_highres_timer(void)
 }
 
 /* Convert entropy in bits into number of IRQs with the same entropy content. */
-static inline u32 lrng_entropy_to_data(u32 entropy_bits)
+static u32 lrng_entropy_to_data(u32 entropy_bits)
 {
 	return ((entropy_bits * lrng_irq_entropy_bits) /
 		LRNG_DRNG_SECURITY_STRENGTH_BITS);
 }
 
 /* Convert number of IRQs into entropy value. */
-static inline u32 lrng_data_to_entropy(u32 irqnum)
+static u32 lrng_data_to_entropy(u32 irqnum)
 {
 	return ((irqnum * LRNG_DRNG_SECURITY_STRENGTH_BITS) /
 		lrng_irq_entropy_bits);
 }
 
-static inline bool lrng_pcpu_pool_online(int cpu)
+static bool lrng_pcpu_pool_online(int cpu)
 {
 	return per_cpu(lrng_pcpu_lock_init, cpu);
 }
@@ -390,7 +390,7 @@ int lrng_pcpu_switch_hash(int node,
  * callbacks defined for the NUMA node the per-CPU pool is defined for because
  * the LRNG crypto switch support is only atomic per NUMA node.
  */
-static inline u32
+static u32
 lrng_pcpu_pool_hash_one(const struct lrng_crypto_cb *pcpu_crypto_cb,
 			void *pcpu_hash, int cpu, u8 *digest, u32 *digestsize)
 {
@@ -561,7 +561,7 @@ u32 lrng_pcpu_pool_hash(u8 *outbuf, u32 requested_bits, bool fully_seeded)
 }
 
 /* Compress the lrng_pcpu_array array into lrng_pcpu_pool */
-static inline void lrng_pcpu_array_compress(void)
+static void lrng_pcpu_array_compress(void)
 {
 	struct shash_desc *shash =
 			(struct shash_desc *)this_cpu_ptr(lrng_pcpu_pool);
@@ -609,7 +609,7 @@ static inline void lrng_pcpu_array_compress(void)
 }
 
 /* Compress data array into hash */
-static inline void lrng_pcpu_array_to_hash(u32 ptr)
+static void lrng_pcpu_array_to_hash(u32 ptr)
 {
 	u32 *array = this_cpu_ptr(lrng_pcpu_array);
 
@@ -649,7 +649,7 @@ static inline void lrng_pcpu_array_to_hash(u32 ptr)
  * Concatenate full 32 bit word at the end of time array even when current
  * ptr is not aligned to sizeof(data).
  */
-static inline void _lrng_pcpu_array_add_u32(u32 data)
+static void _lrng_pcpu_array_add_u32(u32 data)
 {
 	/* Increment pointer by number of slots taken for input value */
 	u32 pre_ptr, mask, ptr = this_cpu_add_return(lrng_pcpu_array_ptr,
@@ -701,7 +701,7 @@ void lrng_pcpu_array_add_u32(u32 data)
 }
 
 /* Concatenate data of max LRNG_DATA_SLOTSIZE_MASK at the end of time array */
-static inline void lrng_pcpu_array_add_slot(u32 data)
+static void lrng_pcpu_array_add_slot(u32 data)
 {
 	/* Get slot */
 	u32 ptr = this_cpu_inc_return(lrng_pcpu_array_ptr) &
@@ -724,7 +724,7 @@ static inline void lrng_pcpu_array_add_slot(u32 data)
 	lrng_pcpu_array_to_hash(ptr);
 }
 
-static inline void
+static void
 lrng_time_process_common(u32 time, void(*add_time)(u32 data))
 {
 	enum lrng_health_res health_test;
@@ -745,7 +745,7 @@ lrng_time_process_common(u32 time, void(*add_time)(u32 data))
 /*
  * Batching up of entropy in per-CPU array before injecting into entropy pool.
  */
-static inline void lrng_time_process(void)
+static void lrng_time_process(void)
 {
 	u32 now_time = random_get_entropy();
 
@@ -764,7 +764,7 @@ static inline void lrng_time_process(void)
 }
 
 /* Hot code path - Callback for interrupt handler */
-void add_interrupt_randomness(int irq, int irq_flg)
+void add_interrupt_randomness(int irq)
 {
 	if (lrng_pool_highres_timer()) {
 		lrng_time_process();
@@ -797,7 +797,6 @@ void add_interrupt_randomness(int irq, int irq_flg)
 		 */
 		tmp = lrng_raw_jiffies_entropy_store(jiffies) ? 0 : jiffies;
 		tmp ^= lrng_raw_irq_entropy_store(irq) ? 0 : irq;
-		tmp ^= lrng_raw_irqflags_entropy_store(irq_flg) ? 0 : irq_flg;
 		tmp ^= lrng_raw_retip_entropy_store(ip) ? 0 : ip;
 		tmp ^= ip >> 32;
 		_lrng_pcpu_array_add_u32(tmp);
diff --git a/drivers/char/lrng/lrng_es_mgr.c b/drivers/char/lrng/lrng_es_mgr.c
index c0025ad2b..efeb62ce0 100644
--- a/drivers/char/lrng/lrng_es_mgr.c
+++ b/drivers/char/lrng/lrng_es_mgr.c
@@ -64,7 +64,7 @@ void lrng_state_exseed_set(enum lrng_external_noise_source source, bool type)
 		lrng_state.lrng_seed_user = type;
 }
 
-static inline void lrng_state_exseed_allow_all(void)
+static void lrng_state_exseed_allow_all(void)
 {
 	lrng_state_exseed_set(lrng_noise_source_hw, true);
 	lrng_state_exseed_set(lrng_noise_source_user, true);
@@ -161,7 +161,7 @@ void lrng_unset_fully_seeded(struct lrng_drng *drng)
 }
 
 /* Policy to enable LRNG operational mode */
-static inline void lrng_set_operational(u32 external_es)
+static void lrng_set_operational(u32 external_es)
 {
 	/* LRNG is operational if the initial DRNG is fully seeded ... */
 	if (lrng_state.lrng_fully_seeded &&
diff --git a/drivers/char/lrng/lrng_health.c b/drivers/char/lrng/lrng_health.c
index 66afc04dc..61f266537 100644
--- a/drivers/char/lrng/lrng_health.c
+++ b/drivers/char/lrng/lrng_health.c
@@ -70,13 +70,13 @@ static struct lrng_health lrng_health = {
 
 static DEFINE_PER_CPU(struct lrng_stuck_test, lrng_stuck_test);
 
-static inline bool lrng_sp80090b_health_requested(void)
+static bool lrng_sp80090b_health_requested(void)
 {
 	/* Health tests are only requested in FIPS mode */
 	return fips_enabled;
 }
 
-static inline bool lrng_sp80090b_health_enabled(void)
+static bool lrng_sp80090b_health_enabled(void)
 {
 	struct lrng_health *health = &lrng_health;
 
@@ -102,7 +102,7 @@ static inline bool lrng_sp80090b_health_enabled(void)
 /*
  * Perform SP800-90B startup testing
  */
-static inline void lrng_sp80090b_startup(struct lrng_health *health)
+static void lrng_sp80090b_startup(struct lrng_health *health)
 {
 	if (!health->sp80090b_startup_done &&
 	    atomic_dec_and_test(&health->sp80090b_startup_blocks)) {
@@ -126,7 +126,7 @@ static inline void lrng_sp80090b_startup(struct lrng_health *health)
 /*
  * Handle failure of SP800-90B startup testing
  */
-static inline void lrng_sp80090b_startup_failure(struct lrng_health *health)
+static void lrng_sp80090b_startup_failure(struct lrng_health *health)
 {
 	/* Reset of LRNG and its entropy - NOTE: we are in atomic context */
 	lrng_reset();
@@ -146,13 +146,13 @@ static inline void lrng_sp80090b_startup_failure(struct lrng_health *health)
 /*
  * Handle failure of SP800-90B runtime testing
  */
-static inline void lrng_sp80090b_runtime_failure(struct lrng_health *health)
+static void lrng_sp80090b_runtime_failure(struct lrng_health *health)
 {
 	lrng_sp80090b_startup_failure(health);
 	health->sp80090b_startup_done = false;
 }
 
-static inline void lrng_sp80090b_failure(struct lrng_health *health)
+static void lrng_sp80090b_failure(struct lrng_health *health)
 {
 	if (health->sp80090b_startup_done) {
 		pr_err("SP800-90B runtime health test failure - invalidating all existing entropy and initiate SP800-90B startup\n");
@@ -196,7 +196,7 @@ bool lrng_sp80090b_compliant(void)
  *
  * @health [in] Reference to health state
  */
-static inline void lrng_apt_reset(struct lrng_health *health,
+static void lrng_apt_reset(struct lrng_health *health,
 				  unsigned int time_masked)
 {
 	struct lrng_apt *apt = &health->apt;
@@ -209,7 +209,7 @@ static inline void lrng_apt_reset(struct lrng_health *health,
 	atomic_set(&apt->apt_base, time_masked);
 }
 
-static inline void lrng_apt_restart(struct lrng_health *health)
+static void lrng_apt_restart(struct lrng_health *health)
 {
 	struct lrng_apt *apt = &health->apt;
 
@@ -227,8 +227,8 @@ static inline void lrng_apt_restart(struct lrng_health *health)
  * @health [in] Reference to health state
  * @now_time [in] Time stamp to process
  */
-static inline void lrng_apt_insert(struct lrng_health *health,
-				   unsigned int now_time)
+static void lrng_apt_insert(struct lrng_health *health,
+			    unsigned int now_time)
 {
 	struct lrng_apt *apt = &health->apt;
 
@@ -281,7 +281,7 @@ static inline void lrng_apt_insert(struct lrng_health *health,
  * @health: Reference to health information
  * @stuck: Decision of stuck test
  */
-static inline void lrng_rct(struct lrng_health *health, int stuck)
+static void lrng_rct(struct lrng_health *health, int stuck)
 {
 	struct lrng_rct *rct = &health->rct;
 
@@ -332,7 +332,7 @@ static inline void lrng_rct(struct lrng_health *health, int stuck)
  * high-resolution time stamps are identified after initialization.
  ***************************************************************************/
 
-static inline u32 lrng_delta(u32 prev, u32 next)
+static u32 lrng_delta(u32 prev, u32 next)
 {
 	/*
 	 * Note that this (unsigned) subtraction does yield the correct value
@@ -349,7 +349,7 @@ static inline u32 lrng_delta(u32 prev, u32 next)
  * @return: 0 event occurrence not stuck (good time stamp)
  *	    != 0 event occurrence stuck (reject time stamp)
  */
-static inline int lrng_irq_stuck(struct lrng_stuck_test *stuck, u32 now_time)
+static int lrng_irq_stuck(struct lrng_stuck_test *stuck, u32 now_time)
 {
 	u32 delta = lrng_delta(stuck->last_time, now_time);
 	u32 delta2 = lrng_delta(stuck->last_delta, delta);
diff --git a/drivers/char/lrng/lrng_interfaces.c b/drivers/char/lrng/lrng_interfaces.c
index b656aaf0c..134e556ac 100644
--- a/drivers/char/lrng/lrng_interfaces.c
+++ b/drivers/char/lrng/lrng_interfaces.c
@@ -41,7 +41,7 @@ static struct fasync_struct *fasync;
 /********************************** Helper ***********************************/
 
 /* Is the DRNG seed level too low? */
-static inline bool lrng_need_entropy(void)
+static bool lrng_need_entropy(void)
 {
 	return (lrng_avail_aux_entropy() < lrng_write_wakeup_bits);
 }
@@ -199,7 +199,7 @@ EXPORT_SYMBOL(add_disk_randomness);
 #endif
 
 #ifndef CONFIG_LRNG_IRQ
-void add_interrupt_randomness(int irq, int irq_flg) { }
+void add_interrupt_randomness(int irq) { }
 EXPORT_SYMBOL(add_interrupt_randomness);
 #endif
 
diff --git a/drivers/char/lrng/lrng_kcapi_hash.c b/drivers/char/lrng/lrng_kcapi_hash.c
index 9647d980e..9927e1022 100644
--- a/drivers/char/lrng/lrng_kcapi_hash.c
+++ b/drivers/char/lrng/lrng_kcapi_hash.c
@@ -15,7 +15,7 @@ struct lrng_hash_info {
 	struct crypto_shash *tfm;
 };
 
-static inline void _lrng_kcapi_hash_free(struct lrng_hash_info *lrng_hash)
+static void _lrng_kcapi_hash_free(struct lrng_hash_info *lrng_hash)
 {
 	struct crypto_shash *tfm = lrng_hash->tfm;
 
diff --git a/drivers/char/lrng/lrng_numa.c b/drivers/char/lrng/lrng_numa.c
index f13ee0314..094929107 100644
--- a/drivers/char/lrng/lrng_numa.c
+++ b/drivers/char/lrng/lrng_numa.c
@@ -17,7 +17,7 @@ static struct lrng_drng **lrng_drng __read_mostly = NULL;
 struct lrng_drng **lrng_drng_instances(void)
 {
 	/* counterpart to cmpxchg_release in _lrng_drngs_numa_alloc */
-	return smp_load_acquire(&lrng_drng);
+	return READ_ONCE(lrng_drng);
 }
 
 /* Allocate the data structures for the per-NUMA node DRNGs */
diff --git a/drivers/char/lrng/lrng_proc.c b/drivers/char/lrng/lrng_proc.c
index 9d5b3153e..5c7b4908f 100644
--- a/drivers/char/lrng/lrng_proc.c
+++ b/drivers/char/lrng/lrng_proc.c
@@ -90,7 +90,7 @@ void lrng_proc_update_max_write_thresh(u32 new_digestsize)
 	mb();
 }
 
-struct ctl_table random_table[] = {
+static struct ctl_table random_table[] = {
 	{
 		.procname	= "poolsize",
 		.maxlen		= sizeof(int),
@@ -191,10 +191,20 @@ static int lrng_proc_type_show(struct seq_file *m, void *v)
 	return 0;
 }
 
+/*
+ * rand_initialize() is called before sysctl_init(),
+ * so we cannot call register_sysctl_init() in rand_initialize()
+ */
+static int __init random_sysctls_init(void)
+{
+	register_sysctl_init("kernel/random", random_table);
+	return 0;
+}
+device_initcall(random_sysctls_init);
+
 static int __init lrng_proc_type_init(void)
 {
 	proc_create_single("lrng_type", 0444, NULL, &lrng_proc_type_show);
 	return 0;
 }
-
 module_init(lrng_proc_type_init);
diff --git a/drivers/char/lrng/lrng_selftest.c b/drivers/char/lrng/lrng_selftest.c
index 7f65c047e..2e81047fe 100644
--- a/drivers/char/lrng/lrng_selftest.c
+++ b/drivers/char/lrng/lrng_selftest.c
@@ -45,7 +45,7 @@
 static u32 lrng_data_selftest_ptr = 0;
 static u32 lrng_data_selftest[LRNG_DATA_ARRAY_SIZE];
 
-static inline void lrng_data_process_selftest_insert(u32 time)
+static void lrng_data_process_selftest_insert(u32 time)
 {
 	u32 ptr = lrng_data_selftest_ptr++ & LRNG_DATA_WORD_MASK;
 	unsigned int array = lrng_data_idx2array(ptr);
@@ -59,7 +59,7 @@ static inline void lrng_data_process_selftest_insert(u32 time)
 		lrng_data_slot_val(time & LRNG_DATA_SLOTSIZE_MASK, slot);
 }
 
-static inline void lrng_data_process_selftest_u32(u32 data)
+static void lrng_data_process_selftest_u32(u32 data)
 {
 	u32 pre_ptr, ptr, mask;
 	unsigned int pre_array;
@@ -165,7 +165,7 @@ static unsigned int lrng_gcd_selftest(void)
 
 #endif /* CONFIG_LRNG_IRQ */
 
-static inline void lrng_selftest_bswap32(u32 *ptr, u32 words)
+static void lrng_selftest_bswap32(u32 *ptr, u32 words)
 {
 	u32 i;
 
diff --git a/drivers/char/lrng/lrng_testing.c b/drivers/char/lrng/lrng_testing.c
index 99cc35abf..3517319ac 100644
--- a/drivers/char/lrng/lrng_testing.c
+++ b/drivers/char/lrng/lrng_testing.c
@@ -46,7 +46,7 @@ struct lrng_testing {
  *	 disabled
  */
 
-static inline void lrng_testing_reset(struct lrng_testing *data)
+static void lrng_testing_reset(struct lrng_testing *data)
 {
 	unsigned long flags;
 
@@ -56,7 +56,7 @@ static inline void lrng_testing_reset(struct lrng_testing *data)
 	spin_unlock_irqrestore(&data->lock, flags);
 }
 
-static inline void lrng_testing_init(struct lrng_testing *data, u32 boot)
+static void lrng_testing_init(struct lrng_testing *data, u32 boot)
 {
 	/*
 	 * The boot time testing implies we have a running test. If the
@@ -71,7 +71,7 @@ static inline void lrng_testing_init(struct lrng_testing *data, u32 boot)
 	pr_warn("Enabling data collection\n");
 }
 
-static inline void lrng_testing_fini(struct lrng_testing *data, u32 boot)
+static void lrng_testing_fini(struct lrng_testing *data, u32 boot)
 {
 	/* If we have boot data, we do not reset yet to allow data to be read */
 	if (boot)
@@ -82,8 +82,8 @@ static inline void lrng_testing_fini(struct lrng_testing *data, u32 boot)
 	pr_warn("Disabling data collection\n");
 }
 
-static inline bool lrng_testing_store(struct lrng_testing *data, u32 value,
-				      u32 *boot)
+static bool lrng_testing_store(struct lrng_testing *data, u32 value,
+			       u32 *boot)
 {
 	unsigned long flags;
 
@@ -120,14 +120,14 @@ static inline bool lrng_testing_store(struct lrng_testing *data, u32 value,
 	return true;
 }
 
-static inline bool lrng_testing_have_data(struct lrng_testing *data)
+static bool lrng_testing_have_data(struct lrng_testing *data)
 {
 	return ((data->rb_writer & LRNG_TESTING_RINGBUFFER_MASK) !=
 		 (data->rb_reader & LRNG_TESTING_RINGBUFFER_MASK));
 }
 
-static inline int lrng_testing_reader(struct lrng_testing *data, u32 *boot,
-				      u8 *outbuf, u32 outbuflen)
+static int lrng_testing_reader(struct lrng_testing *data, u32 *boot,
+			       u8 *outbuf, u32 outbuflen)
 {
 	unsigned long flags;
 	int collected_data = 0;
-- 
2.35.1.354.g715d08a9e5

