From dd85bf6e4090dbe0f989a869dac6dff8d40fc067 Mon Sep 17 00:00:00 2001
From: Piotr Gorski <lucjan.lucjanov@gmail.com>
Date: Fri, 9 Dec 2022 13:21:39 +0100
Subject: [PATCH 49/54] Drop v11 iteration

Signed-off-by: Piotr Gorski <lucjan.lucjanov@gmail.com>
---
 MAINTAINERS                                   |   2 -
 arch/alpha/kernel/syscalls/syscall.tbl        |   1 -
 arch/arm/tools/syscall.tbl                    |   1 -
 arch/arm64/include/asm/unistd.h               |   2 +-
 arch/arm64/include/asm/unistd32.h             |   2 -
 arch/ia64/kernel/syscalls/syscall.tbl         |   1 -
 arch/m68k/kernel/syscalls/syscall.tbl         |   1 -
 arch/microblaze/kernel/syscalls/syscall.tbl   |   1 -
 arch/mips/kernel/syscalls/syscall_n32.tbl     |   1 -
 arch/mips/kernel/syscalls/syscall_n64.tbl     |   1 -
 arch/mips/kernel/syscalls/syscall_o32.tbl     |   1 -
 arch/parisc/kernel/syscalls/syscall.tbl       |   1 -
 arch/powerpc/kernel/syscalls/syscall.tbl      |   1 -
 arch/s390/kernel/syscalls/syscall.tbl         |   1 -
 arch/sh/kernel/syscalls/syscall.tbl           |   1 -
 arch/sparc/kernel/syscalls/syscall.tbl        |   1 -
 arch/x86/Kconfig                              |   1 -
 arch/x86/entry/syscalls/syscall_32.tbl        |   1 -
 arch/x86/entry/syscalls/syscall_64.tbl        |   1 -
 arch/x86/entry/vdso/Makefile                  |   3 +-
 arch/x86/entry/vdso/vdso.lds.S                |   2 -
 arch/x86/entry/vdso/vgetrandom-chacha.S       | 177 -----------
 arch/x86/entry/vdso/vgetrandom.c              |  17 --
 arch/x86/include/asm/vdso/getrandom.h         |  55 ----
 arch/x86/include/asm/vdso/vsyscall.h          |   2 -
 arch/x86/include/asm/vvar.h                   |  16 -
 arch/xtensa/kernel/syscalls/syscall.tbl       |   1 -
 drivers/char/random.c                         | 138 ---------
 include/linux/syscalls.h                      |   3 -
 include/uapi/asm-generic/unistd.h             |   5 +-
 include/vdso/datapage.h                       |  12 -
 include/vdso/getrandom.h                      |  44 ---
 include/vdso/types.h                          |  35 ---
 kernel/sys_ni.c                               |   3 -
 lib/vdso/Kconfig                              |   5 -
 lib/vdso/getrandom.c                          | 205 -------------
 tools/include/uapi/asm-generic/unistd.h       |   5 +-
 .../arch/mips/entry/syscalls/syscall_n64.tbl  |   1 -
 .../arch/powerpc/entry/syscalls/syscall.tbl   |   1 -
 .../perf/arch/s390/entry/syscalls/syscall.tbl |   1 -
 .../arch/x86/entry/syscalls/syscall_64.tbl    |   1 -
 tools/testing/selftests/vDSO/.gitignore       |   2 -
 tools/testing/selftests/vDSO/Makefile         |  11 -
 .../testing/selftests/vDSO/vdso_test_chacha.c |  43 ---
 .../selftests/vDSO/vdso_test_getrandom.c      | 279 ------------------
 45 files changed, 4 insertions(+), 1085 deletions(-)
 delete mode 100644 arch/x86/entry/vdso/vgetrandom-chacha.S
 delete mode 100644 arch/x86/entry/vdso/vgetrandom.c
 delete mode 100644 arch/x86/include/asm/vdso/getrandom.h
 delete mode 100644 include/vdso/getrandom.h
 delete mode 100644 include/vdso/types.h
 delete mode 100644 lib/vdso/getrandom.c
 delete mode 100644 tools/testing/selftests/vDSO/vdso_test_chacha.c
 delete mode 100644 tools/testing/selftests/vDSO/vdso_test_getrandom.c

diff --git a/MAINTAINERS b/MAINTAINERS
index b56232af1..886d3f69e 100644
--- a/MAINTAINERS
+++ b/MAINTAINERS
@@ -17294,8 +17294,6 @@ T:	git https://git.kernel.org/pub/scm/linux/kernel/git/crng/random.git
 S:	Maintained
 F:	drivers/char/random.c
 F:	drivers/virt/vmgenid.c
-F:	include/vdso/getrandom.h
-F:	lib/vdso/getrandom.c
 
 RAPIDIO SUBSYSTEM
 M:	Matt Porter <mporter@kernel.crashing.org>
diff --git a/arch/alpha/kernel/syscalls/syscall.tbl b/arch/alpha/kernel/syscalls/syscall.tbl
index a4bfd7b53..8ebacf37a 100644
--- a/arch/alpha/kernel/syscalls/syscall.tbl
+++ b/arch/alpha/kernel/syscalls/syscall.tbl
@@ -490,4 +490,3 @@
 558	common	process_mrelease		sys_process_mrelease
 559	common  futex_waitv                     sys_futex_waitv
 560	common	set_mempolicy_home_node		sys_ni_syscall
-561	common	vgetrandom_alloc		sys_vgetrandom_alloc
diff --git a/arch/arm/tools/syscall.tbl b/arch/arm/tools/syscall.tbl
index e10319cc6..ac964612d 100644
--- a/arch/arm/tools/syscall.tbl
+++ b/arch/arm/tools/syscall.tbl
@@ -464,4 +464,3 @@
 448	common	process_mrelease		sys_process_mrelease
 449	common	futex_waitv			sys_futex_waitv
 450	common	set_mempolicy_home_node		sys_set_mempolicy_home_node
-451	common	vgetrandom_alloc		sys_vgetrandom_alloc
diff --git a/arch/arm64/include/asm/unistd.h b/arch/arm64/include/asm/unistd.h
index 64a514f90..037feba03 100644
--- a/arch/arm64/include/asm/unistd.h
+++ b/arch/arm64/include/asm/unistd.h
@@ -39,7 +39,7 @@
 #define __ARM_NR_compat_set_tls		(__ARM_NR_COMPAT_BASE + 5)
 #define __ARM_NR_COMPAT_END		(__ARM_NR_COMPAT_BASE + 0x800)
 
-#define __NR_compat_syscalls		452
+#define __NR_compat_syscalls		451
 #endif
 
 #define __ARCH_WANT_SYS_CLONE
diff --git a/arch/arm64/include/asm/unistd32.h b/arch/arm64/include/asm/unistd32.h
index 7285b5a83..604a2053d 100644
--- a/arch/arm64/include/asm/unistd32.h
+++ b/arch/arm64/include/asm/unistd32.h
@@ -907,8 +907,6 @@ __SYSCALL(__NR_process_mrelease, sys_process_mrelease)
 __SYSCALL(__NR_futex_waitv, sys_futex_waitv)
 #define __NR_set_mempolicy_home_node 450
 __SYSCALL(__NR_set_mempolicy_home_node, sys_set_mempolicy_home_node)
-#define __NR_vgetrandom_alloc 451
-__SYSCALL(__NR_vgetrandom_alloc, sys_vgetrandom_alloc)
 
 /*
  * Please add new compat syscalls above this comment and update
diff --git a/arch/ia64/kernel/syscalls/syscall.tbl b/arch/ia64/kernel/syscalls/syscall.tbl
index 5ed966705..72c929d99 100644
--- a/arch/ia64/kernel/syscalls/syscall.tbl
+++ b/arch/ia64/kernel/syscalls/syscall.tbl
@@ -371,4 +371,3 @@
 448	common	process_mrelease		sys_process_mrelease
 449	common  futex_waitv                     sys_futex_waitv
 450	common	set_mempolicy_home_node		sys_set_mempolicy_home_node
-451	common	vgetrandom_alloc		sys_vgetrandom_alloc
diff --git a/arch/m68k/kernel/syscalls/syscall.tbl b/arch/m68k/kernel/syscalls/syscall.tbl
index d9e7ea26d..b1f3940bc 100644
--- a/arch/m68k/kernel/syscalls/syscall.tbl
+++ b/arch/m68k/kernel/syscalls/syscall.tbl
@@ -450,4 +450,3 @@
 448	common	process_mrelease		sys_process_mrelease
 449	common  futex_waitv                     sys_futex_waitv
 450	common	set_mempolicy_home_node		sys_set_mempolicy_home_node
-451	common	vgetrandom_alloc		sys_vgetrandom_alloc
diff --git a/arch/microblaze/kernel/syscalls/syscall.tbl b/arch/microblaze/kernel/syscalls/syscall.tbl
index c109e307a..820145e47 100644
--- a/arch/microblaze/kernel/syscalls/syscall.tbl
+++ b/arch/microblaze/kernel/syscalls/syscall.tbl
@@ -456,4 +456,3 @@
 448	common	process_mrelease		sys_process_mrelease
 449	common  futex_waitv                     sys_futex_waitv
 450	common	set_mempolicy_home_node		sys_set_mempolicy_home_node
-451	common	vgetrandom_alloc		sys_vgetrandom_alloc
diff --git a/arch/mips/kernel/syscalls/syscall_n32.tbl b/arch/mips/kernel/syscalls/syscall_n32.tbl
index 6d47d8231..253ff994e 100644
--- a/arch/mips/kernel/syscalls/syscall_n32.tbl
+++ b/arch/mips/kernel/syscalls/syscall_n32.tbl
@@ -389,4 +389,3 @@
 448	n32	process_mrelease		sys_process_mrelease
 449	n32	futex_waitv			sys_futex_waitv
 450	n32	set_mempolicy_home_node		sys_set_mempolicy_home_node
-451	n32	vgetrandom_alloc		sys_vgetrandom_alloc
diff --git a/arch/mips/kernel/syscalls/syscall_n64.tbl b/arch/mips/kernel/syscalls/syscall_n64.tbl
index 890e5b51e..3f1886ad9 100644
--- a/arch/mips/kernel/syscalls/syscall_n64.tbl
+++ b/arch/mips/kernel/syscalls/syscall_n64.tbl
@@ -365,4 +365,3 @@
 448	n64	process_mrelease		sys_process_mrelease
 449	n64	futex_waitv			sys_futex_waitv
 450	common	set_mempolicy_home_node		sys_set_mempolicy_home_node
-451	n64	vgetrandom_alloc		sys_vgetrandom_alloc
diff --git a/arch/mips/kernel/syscalls/syscall_o32.tbl b/arch/mips/kernel/syscalls/syscall_o32.tbl
index de512de14..8f243e35a 100644
--- a/arch/mips/kernel/syscalls/syscall_o32.tbl
+++ b/arch/mips/kernel/syscalls/syscall_o32.tbl
@@ -438,4 +438,3 @@
 448	o32	process_mrelease		sys_process_mrelease
 449	o32	futex_waitv			sys_futex_waitv
 450	o32	set_mempolicy_home_node		sys_set_mempolicy_home_node
-451	o32	vgetrandom_alloc		sys_vgetrandom_alloc
diff --git a/arch/parisc/kernel/syscalls/syscall.tbl b/arch/parisc/kernel/syscalls/syscall.tbl
index bab1cee62..8a99c998d 100644
--- a/arch/parisc/kernel/syscalls/syscall.tbl
+++ b/arch/parisc/kernel/syscalls/syscall.tbl
@@ -448,4 +448,3 @@
 448	common	process_mrelease		sys_process_mrelease
 449	common	futex_waitv			sys_futex_waitv
 450	common	set_mempolicy_home_node		sys_set_mempolicy_home_node
-451	common	vgetrandom_alloc		sys_vgetrandom_alloc
diff --git a/arch/powerpc/kernel/syscalls/syscall.tbl b/arch/powerpc/kernel/syscalls/syscall.tbl
index e6c04eda2..a0be12747 100644
--- a/arch/powerpc/kernel/syscalls/syscall.tbl
+++ b/arch/powerpc/kernel/syscalls/syscall.tbl
@@ -537,4 +537,3 @@
 448	common	process_mrelease		sys_process_mrelease
 449	common  futex_waitv                     sys_futex_waitv
 450 	nospu	set_mempolicy_home_node		sys_set_mempolicy_home_node
-451	common	vgetrandom_alloc		sys_vgetrandom_alloc
diff --git a/arch/s390/kernel/syscalls/syscall.tbl b/arch/s390/kernel/syscalls/syscall.tbl
index 5b0b2bea4..799147658 100644
--- a/arch/s390/kernel/syscalls/syscall.tbl
+++ b/arch/s390/kernel/syscalls/syscall.tbl
@@ -453,4 +453,3 @@
 448  common	process_mrelease	sys_process_mrelease		sys_process_mrelease
 449  common	futex_waitv		sys_futex_waitv			sys_futex_waitv
 450  common	set_mempolicy_home_node	sys_set_mempolicy_home_node	sys_set_mempolicy_home_node
-451  common	vgetrandom_alloc	sys_vgetrandom_alloc		sys_vgetrandom_alloc
diff --git a/arch/sh/kernel/syscalls/syscall.tbl b/arch/sh/kernel/syscalls/syscall.tbl
index 631f0bac0..2de85c977 100644
--- a/arch/sh/kernel/syscalls/syscall.tbl
+++ b/arch/sh/kernel/syscalls/syscall.tbl
@@ -453,4 +453,3 @@
 448	common	process_mrelease		sys_process_mrelease
 449	common  futex_waitv                     sys_futex_waitv
 450	common	set_mempolicy_home_node		sys_set_mempolicy_home_node
-451	common	vgetrandom_alloc		sys_vgetrandom_alloc
diff --git a/arch/sparc/kernel/syscalls/syscall.tbl b/arch/sparc/kernel/syscalls/syscall.tbl
index b4925978a..4398cc6fb 100644
--- a/arch/sparc/kernel/syscalls/syscall.tbl
+++ b/arch/sparc/kernel/syscalls/syscall.tbl
@@ -496,4 +496,3 @@
 448	common	process_mrelease		sys_process_mrelease
 449	common  futex_waitv                     sys_futex_waitv
 450	common	set_mempolicy_home_node		sys_set_mempolicy_home_node
-451	common	vgetrandom_alloc		sys_vgetrandom_alloc
diff --git a/arch/x86/Kconfig b/arch/x86/Kconfig
index 357148c4a..67745ceab 100644
--- a/arch/x86/Kconfig
+++ b/arch/x86/Kconfig
@@ -269,7 +269,6 @@ config X86
 	select HAVE_UNSTABLE_SCHED_CLOCK
 	select HAVE_USER_RETURN_NOTIFIER
 	select HAVE_GENERIC_VDSO
-	select VDSO_GETRANDOM			if X86_64
 	select HOTPLUG_SMT			if SMP
 	select IRQ_FORCED_THREADING
 	select NEED_PER_CPU_EMBED_FIRST_CHUNK
diff --git a/arch/x86/entry/syscalls/syscall_32.tbl b/arch/x86/entry/syscalls/syscall_32.tbl
index f5f863a33..320480a8d 100644
--- a/arch/x86/entry/syscalls/syscall_32.tbl
+++ b/arch/x86/entry/syscalls/syscall_32.tbl
@@ -455,4 +455,3 @@
 448	i386	process_mrelease	sys_process_mrelease
 449	i386	futex_waitv		sys_futex_waitv
 450	i386	set_mempolicy_home_node		sys_set_mempolicy_home_node
-451	i386	vgetrandom_alloc		sys_vgetrandom_alloc
diff --git a/arch/x86/entry/syscalls/syscall_64.tbl b/arch/x86/entry/syscalls/syscall_64.tbl
index 0186f173f..c84d12608 100644
--- a/arch/x86/entry/syscalls/syscall_64.tbl
+++ b/arch/x86/entry/syscalls/syscall_64.tbl
@@ -372,7 +372,6 @@
 448	common	process_mrelease	sys_process_mrelease
 449	common	futex_waitv		sys_futex_waitv
 450	common	set_mempolicy_home_node	sys_set_mempolicy_home_node
-451	common	vgetrandom_alloc	sys_vgetrandom_alloc
 
 #
 # Due to a historical design error, certain syscalls are numbered differently
diff --git a/arch/x86/entry/vdso/Makefile b/arch/x86/entry/vdso/Makefile
index 2de64e522..3e88b9df8 100644
--- a/arch/x86/entry/vdso/Makefile
+++ b/arch/x86/entry/vdso/Makefile
@@ -27,7 +27,7 @@ VDSO32-$(CONFIG_X86_32)		:= y
 VDSO32-$(CONFIG_IA32_EMULATION)	:= y
 
 # files to link into the vdso
-vobjs-y := vdso-note.o vclock_gettime.o vgetcpu.o vgetrandom.o vgetrandom-chacha.o
+vobjs-y := vdso-note.o vclock_gettime.o vgetcpu.o
 vobjs32-y := vdso32/note.o vdso32/system_call.o vdso32/sigreturn.o
 vobjs32-y += vdso32/vclock_gettime.o
 vobjs-$(CONFIG_X86_SGX)	+= vsgx.o
@@ -104,7 +104,6 @@ CFLAGS_REMOVE_vclock_gettime.o = -pg
 CFLAGS_REMOVE_vdso32/vclock_gettime.o = -pg
 CFLAGS_REMOVE_vgetcpu.o = -pg
 CFLAGS_REMOVE_vsgx.o = -pg
-CFLAGS_REMOVE_vgetrandom.o = -pg
 
 #
 # X32 processes use x32 vDSO to access 64bit kernel data.
diff --git a/arch/x86/entry/vdso/vdso.lds.S b/arch/x86/entry/vdso/vdso.lds.S
index 1919cc392..4bf48462f 100644
--- a/arch/x86/entry/vdso/vdso.lds.S
+++ b/arch/x86/entry/vdso/vdso.lds.S
@@ -28,8 +28,6 @@ VERSION {
 		clock_getres;
 		__vdso_clock_getres;
 		__vdso_sgx_enter_enclave;
-		getrandom;
-		__vdso_getrandom;
 	local: *;
 	};
 }
diff --git a/arch/x86/entry/vdso/vgetrandom-chacha.S b/arch/x86/entry/vdso/vgetrandom-chacha.S
deleted file mode 100644
index 91fbb7ac7..000000000
--- a/arch/x86/entry/vdso/vgetrandom-chacha.S
+++ /dev/null
@@ -1,177 +0,0 @@
-// SPDX-License-Identifier: GPL-2.0
-/*
- * Copyright (C) 2022 Jason A. Donenfeld <Jason@zx2c4.com>. All Rights Reserved.
- */
-
-#include <linux/linkage.h>
-#include <asm/frame.h>
-
-.section	.rodata.cst16.CONSTANTS, "aM", @progbits, 16
-.align 16
-CONSTANTS:	.octa 0x6b20657479622d323320646e61707865
-.text
-
-/*
- * Very basic SSE2 implementation of ChaCha20. Produces a given positive number
- * of blocks of output with a nonce of 0, taking an input key and 8-byte
- * counter. Importantly does not spill to the stack. Its arguments are:
- *
- *	rdi: output bytes
- *	rsi: 32-byte key input
- *	rdx: 8-byte counter input/output
- *	rcx: number of 64-byte blocks to write to output
- */
-SYM_FUNC_START(__arch_chacha20_blocks_nostack)
-
-#define output  %rdi
-#define key     %rsi
-#define counter %rdx
-#define nblocks %rcx
-#define i       %al
-#define state0  %xmm0
-#define state1  %xmm1
-#define state2  %xmm2
-#define state3  %xmm3
-#define copy0   %xmm4
-#define copy1   %xmm5
-#define copy2   %xmm6
-#define copy3   %xmm7
-#define temp    %xmm8
-#define one     %xmm9
-
-	/* copy0 = "expand 32-byte k" */
-	movaps		CONSTANTS(%rip),copy0
-	/* copy1,copy2 = key */
-	movups		0x00(key),copy1
-	movups		0x10(key),copy2
-	/* copy3 = counter || zero nonce */
-	movq		0x00(counter),copy3
-	/* one = 1 || 0 */
-	movq		$1,%rax
-	movq		%rax,one
-
-.Lblock:
-	/* state0,state1,state2,state3 = copy0,copy1,copy2,copy3 */
-	movdqa		copy0,state0
-	movdqa		copy1,state1
-	movdqa		copy2,state2
-	movdqa		copy3,state3
-
-	movb		$10,i
-.Lpermute:
-	/* state0 += state1, state3 = rotl32(state3 ^ state0, 16) */
-	paddd		state1,state0
-	pxor		state0,state3
-	movdqa		state3,temp
-	pslld		$16,temp
-	psrld		$16,state3
-	por		temp,state3
-
-	/* state2 += state3, state1 = rotl32(state1 ^ state2, 12) */
-	paddd		state3,state2
-	pxor		state2,state1
-	movdqa		state1,temp
-	pslld		$12,temp
-	psrld		$20,state1
-	por		temp,state1
-
-	/* state0 += state1, state3 = rotl32(state3 ^ state0, 8) */
-	paddd		state1,state0
-	pxor		state0,state3
-	movdqa		state3,temp
-	pslld		$8,temp
-	psrld		$24,state3
-	por		temp,state3
-
-	/* state2 += state3, state1 = rotl32(state1 ^ state2, 7) */
-	paddd		state3,state2
-	pxor		state2,state1
-	movdqa		state1,temp
-	pslld		$7,temp
-	psrld		$25,state1
-	por		temp,state1
-
-	/* state1[0,1,2,3] = state1[0,3,2,1] */
-	pshufd		$0x39,state1,state1
-	/* state2[0,1,2,3] = state2[1,0,3,2] */
-	pshufd		$0x4e,state2,state2
-	/* state3[0,1,2,3] = state3[2,1,0,3] */
-	pshufd		$0x93,state3,state3
-
-	/* state0 += state1, state3 = rotl32(state3 ^ state0, 16) */
-	paddd		state1,state0
-	pxor		state0,state3
-	movdqa		state3,temp
-	pslld		$16,temp
-	psrld		$16,state3
-	por		temp,state3
-
-	/* state2 += state3, state1 = rotl32(state1 ^ state2, 12) */
-	paddd		state3,state2
-	pxor		state2,state1
-	movdqa		state1,temp
-	pslld		$12,temp
-	psrld		$20,state1
-	por		temp,state1
-
-	/* state0 += state1, state3 = rotl32(state3 ^ state0, 8) */
-	paddd		state1,state0
-	pxor		state0,state3
-	movdqa		state3,temp
-	pslld		$8,temp
-	psrld		$24,state3
-	por		temp,state3
-
-	/* state2 += state3, state1 = rotl32(state1 ^ state2, 7) */
-	paddd		state3,state2
-	pxor		state2,state1
-	movdqa		state1,temp
-	pslld		$7,temp
-	psrld		$25,state1
-	por		temp,state1
-
-	/* state1[0,1,2,3] = state1[2,1,0,3] */
-	pshufd		$0x93,state1,state1
-	/* state2[0,1,2,3] = state2[1,0,3,2] */
-	pshufd		$0x4e,state2,state2
-	/* state3[0,1,2,3] = state3[0,3,2,1] */
-	pshufd		$0x39,state3,state3
-
-	decb		i
-	jnz		.Lpermute
-
-	/* output0 = state0 + copy0 */
-	paddd		copy0,state0
-	movups		state0,0x00(output)
-	/* output1 = state1 + copy1 */
-	paddd		copy1,state1
-	movups		state1,0x10(output)
-	/* output2 = state2 + copy2 */
-	paddd		copy2,state2
-	movups		state2,0x20(output)
-	/* output3 = state3 + copy3 */
-	paddd		copy3,state3
-	movups		state3,0x30(output)
-
-	/* ++copy3.counter */
-	paddq		one,copy3
-
-	/* output += 64, --nblocks */
-	addq		$64,output
-	decq		nblocks
-	jnz		.Lblock
-
-	/* counter = copy3.counter */
-	movq		copy3,0x00(counter)
-
-	/* Zero out the potentially sensitive regs, in case nothing uses these again. */
-	pxor		state0,state0
-	pxor		state1,state1
-	pxor		state2,state2
-	pxor		state3,state3
-	pxor		copy1,copy1
-	pxor		copy2,copy2
-	pxor		temp,temp
-
-	ret
-SYM_FUNC_END(__arch_chacha20_blocks_nostack)
diff --git a/arch/x86/entry/vdso/vgetrandom.c b/arch/x86/entry/vdso/vgetrandom.c
deleted file mode 100644
index 6045ded5d..000000000
--- a/arch/x86/entry/vdso/vgetrandom.c
+++ /dev/null
@@ -1,17 +0,0 @@
-// SPDX-License-Identifier: GPL-2.0-only
-/*
- * Copyright (C) 2022 Jason A. Donenfeld <Jason@zx2c4.com>. All Rights Reserved.
- */
-#include <linux/types.h>
-
-#include "../../../../lib/vdso/getrandom.c"
-
-ssize_t __vdso_getrandom(void *buffer, size_t len, unsigned int flags, void *state);
-
-ssize_t __vdso_getrandom(void *buffer, size_t len, unsigned int flags, void *state)
-{
-	return __cvdso_getrandom(buffer, len, flags, state);
-}
-
-ssize_t getrandom(void *, size_t, unsigned int, void *)
-	__attribute__((weak, alias("__vdso_getrandom")));
diff --git a/arch/x86/include/asm/vdso/getrandom.h b/arch/x86/include/asm/vdso/getrandom.h
deleted file mode 100644
index 46f99d735..000000000
--- a/arch/x86/include/asm/vdso/getrandom.h
+++ /dev/null
@@ -1,55 +0,0 @@
-/* SPDX-License-Identifier: GPL-2.0 */
-/*
- * Copyright (C) 2022 Jason A. Donenfeld <Jason@zx2c4.com>. All Rights Reserved.
- */
-#ifndef __ASM_VDSO_GETRANDOM_H
-#define __ASM_VDSO_GETRANDOM_H
-
-#ifndef __ASSEMBLY__
-
-#include <asm/unistd.h>
-#include <asm/vvar.h>
-
-/**
- * getrandom_syscall - Invoke the getrandom() syscall.
- * @buffer:	Destination buffer to fill with random bytes.
- * @len:	Size of @buffer in bytes.
- * @flags:	Zero or more GRND_* flags.
- * Returns the number of random bytes written to @buffer, or a negative value indicating an error.
- */
-static __always_inline ssize_t getrandom_syscall(void *buffer, size_t len, unsigned int flags)
-{
-	long ret;
-
-	asm ("syscall" : "=a" (ret) :
-	     "0" (__NR_getrandom), "D" (buffer), "S" (len), "d" (flags) :
-	     "rcx", "r11", "memory");
-
-	return ret;
-}
-
-#define __vdso_rng_data (VVAR(_vdso_rng_data))
-
-static __always_inline const struct vdso_rng_data *__arch_get_vdso_rng_data(void)
-{
-	if (__vdso_data->clock_mode == VDSO_CLOCKMODE_TIMENS)
-		return (void *)&__vdso_rng_data + ((void *)&__timens_vdso_data - (void *)&__vdso_data);
-	return &__vdso_rng_data;
-}
-
-/**
- * __arch_chacha20_blocks_nostack - Generate ChaCha20 stream without using the stack.
- * @dst_bytes:	Destination buffer to hold @nblocks * 64 bytes of output.
- * @key:	32-byte input key.
- * @counter:	8-byte counter, read on input and updated on return.
- * @nblocks:	Number of blocks to generate.
- *
- * Generates a given positive number of blocks of ChaCha20 output with nonce=0, and does not write
- * to any stack or memory outside of the parameters passed to it, in order to mitigate stack data
- * leaking into forked child processes.
- */
-extern void __arch_chacha20_blocks_nostack(u8 *dst_bytes, const u32 *key, u32 *counter, size_t nblocks);
-
-#endif /* !__ASSEMBLY__ */
-
-#endif /* __ASM_VDSO_GETRANDOM_H */
diff --git a/arch/x86/include/asm/vdso/vsyscall.h b/arch/x86/include/asm/vdso/vsyscall.h
index 71c56586a..be199a9b2 100644
--- a/arch/x86/include/asm/vdso/vsyscall.h
+++ b/arch/x86/include/asm/vdso/vsyscall.h
@@ -11,8 +11,6 @@
 #include <asm/vvar.h>
 
 DEFINE_VVAR(struct vdso_data, _vdso_data);
-DEFINE_VVAR_SINGLE(struct vdso_rng_data, _vdso_rng_data);
-
 /*
  * Update the vDSO data page to keep in sync with kernel timekeeping.
  */
diff --git a/arch/x86/include/asm/vvar.h b/arch/x86/include/asm/vvar.h
index 9d9af37f7..183e98e49 100644
--- a/arch/x86/include/asm/vvar.h
+++ b/arch/x86/include/asm/vvar.h
@@ -26,8 +26,6 @@
  */
 #define DECLARE_VVAR(offset, type, name) \
 	EMIT_VVAR(name, offset)
-#define DECLARE_VVAR_SINGLE(offset, type, name) \
-	EMIT_VVAR(name, offset)
 
 #else
 
@@ -39,10 +37,6 @@ extern char __vvar_page;
 	extern type timens_ ## name[CS_BASES]				\
 	__attribute__((visibility("hidden")));				\
 
-#define DECLARE_VVAR_SINGLE(offset, type, name)				\
-	extern type vvar_ ## name					\
-	__attribute__((visibility("hidden")));				\
-
 #define VVAR(name) (vvar_ ## name)
 #define TIMENS(name) (timens_ ## name)
 
@@ -50,22 +44,12 @@ extern char __vvar_page;
 	type name[CS_BASES]						\
 	__attribute__((section(".vvar_" #name), aligned(16))) __visible
 
-#define DEFINE_VVAR_SINGLE(type, name)					\
-	type name							\
-	__attribute__((section(".vvar_" #name), aligned(16))) __visible
-
 #endif
 
 /* DECLARE_VVAR(offset, type, name) */
 
 DECLARE_VVAR(128, struct vdso_data, _vdso_data)
 
-#if !defined(_SINGLE_DATA)
-#define _SINGLE_DATA
-DECLARE_VVAR_SINGLE(640, struct vdso_rng_data, _vdso_rng_data)
-#endif
-
 #undef DECLARE_VVAR
-#undef DECLARE_VVAR_SINGLE
 
 #endif
diff --git a/arch/xtensa/kernel/syscalls/syscall.tbl b/arch/xtensa/kernel/syscalls/syscall.tbl
index 14d63a119..52c94ab5c 100644
--- a/arch/xtensa/kernel/syscalls/syscall.tbl
+++ b/arch/xtensa/kernel/syscalls/syscall.tbl
@@ -421,4 +421,3 @@
 448	common	process_mrelease		sys_process_mrelease
 449	common  futex_waitv                     sys_futex_waitv
 450	common	set_mempolicy_home_node		sys_set_mempolicy_home_node
-451	common	vgetrandom_alloc		sys_vgetrandom_alloc
diff --git a/drivers/char/random.c b/drivers/char/random.c
index ddf0c8e1f..e872acc12 100644
--- a/drivers/char/random.c
+++ b/drivers/char/random.c
@@ -8,7 +8,6 @@
  * into roughly six sections, each with a section header:
  *
  *   - Initialization and readiness waiting.
- *   - vDSO support helpers.
  *   - Fast key erasure RNG, the "crng".
  *   - Entropy accumulation and extraction routines.
  *   - Entropy collection routines.
@@ -40,7 +39,6 @@
 #include <linux/blkdev.h>
 #include <linux/interrupt.h>
 #include <linux/mm.h>
-#include <linux/mman.h>
 #include <linux/nodemask.h>
 #include <linux/spinlock.h>
 #include <linux/kthread.h>
@@ -58,10 +56,6 @@
 #include <linux/sched/isolation.h>
 #include <crypto/chacha.h>
 #include <crypto/blake2s.h>
-#ifdef CONFIG_VDSO_GETRANDOM
-#include <vdso/getrandom.h>
-#include <vdso/datapage.h>
-#endif
 #include <asm/processor.h>
 #include <asm/irq.h>
 #include <asm/irq_regs.h>
@@ -174,132 +168,6 @@ int __cold execute_with_initialized_rng(struct notifier_block *nb)
 				__func__, (void *)_RET_IP_, crng_init)
 
 
-
-/********************************************************************
- *
- * vDSO support helpers.
- *
- * The actual vDSO function is defined over in lib/vdso/getrandom.c,
- * but this section contains the kernel-mode helpers to support that.
- *
- ********************************************************************/
-
-#ifdef CONFIG_VDSO_GETRANDOM
-/**
- * sys_vgetrandom_alloc - Allocate opaque states for use with vDSO getrandom().
- *
- * @num:	   On input, a pointer to a suggested hint of how many states to
- * 		   allocate, and on return the number of states actually allocated.
- *
- * @size_per_each: On input, must be zero. On return, the size of each state allocated,
- * 		   so that the caller can split up the returned allocation into
- * 		   individual states.
- *
- * @addr:	   Reserved, must be zero.
- *
- * @flags:	   Reserved, must be zero.
- *
- * The getrandom() vDSO function in userspace requires an opaque state, which
- * this function allocates by mapping a certain number of special pages into
- * the calling process. It takes a hint as to the number of opaque states
- * desired, and provides the caller with the number of opaque states actually
- * allocated, the size of each one in bytes, and the address of the first
- * state, which may be split up into @num states of @size_per_each bytes each,
- * by adding @size_per_each to the returned first state @num times.
- *
- * Returns the address of the first state in the allocation on success, or a
- * negative error value on failure.
- *
- * The returned address of the first state may be passed to munmap(2) with a
- * length of `(size_t)num * (size_t)size_per_each`, in order to deallocate the
- * memory, after which it is invalid to pass it to vDSO getrandom().
- *
- * States allocated by this function must not be dereferenced, written, read,
- * or otherwise manipulated. The *only* supported operations are:
- *   - Splitting up the states in intervals of @size_per_each, no more than
- *     @num times from the first state.
- *   - Passing a state to the getrandom() vDSO function's @opaque_state
- *     parameter, but not passing the same state at the same time to two such
- *     calls.
- *   - Passing the first state and the total length to munmap(2), as described
- *     above.
- * All other uses are undefined behavior, which is subject to change or removal.
- */
-SYSCALL_DEFINE4(vgetrandom_alloc, unsigned int __user *, num,
-		unsigned int __user *, size_per_each, unsigned long, addr,
-		unsigned int, flags)
-{
-	struct mm_struct *mm = current->mm;
-	size_t alloc_size, num_states;
-	const size_t state_size = sizeof(struct vgetrandom_state);
-	unsigned long pages_addr, populate, mm_flags;
-	unsigned int num_hint;
-	int ret;
-
-	/*
-	 * @flags and @addr are currently unused, so in order to reserve them
-	 * for the future, force them to be set to zero by current callers.
-	 */
-	if (flags || addr)
-		return -EINVAL;
-
-	/*
-	 * Also enforce that *size_per_each is zero on input, in case this becomes
-	 * useful later on.
-	 */
-	if (get_user(num_hint, size_per_each))
-		return -EFAULT;
-	if (num_hint)
-		return -EINVAL;
-
-	if (get_user(num_hint, num))
-		return -EFAULT;
-
-	num_states = clamp_t(size_t, num_hint, 1, (SIZE_MAX & PAGE_MASK) / state_size);
-	alloc_size = PAGE_ALIGN(num_states * state_size);
-
-	if (mmap_write_lock_killable(mm))
-		return -EINTR;
-	mm_flags = mm->def_flags;
-
-	mm->def_flags |=
-		/*
-		 * Don't allow state to be written to swap, to preserve forward secrecy.
-		 * This works in conjunction with MAP_LOCKED in do_mmap(), below, which
-		 * actually does the locking (and associated permission check and accounting).
-		 * Here, VM_LOCKONFAULT together with VM_NORESERVE simply make the mlocking
-		 * happen the first time it's actually used, the same as when calling
-		 * mlock2(MLOCK_ONFAULT) from userspace.
-		 */
-		VM_LOCKONFAULT | VM_NORESERVE |
-
-		/* Don't allow the state to survive forks, to prevent random number re-use. */
-		VM_WIPEONFORK |
-
-		/* Don't write random state into coredumps. */
-		VM_DONTDUMP;
-
-	pages_addr = do_mmap(NULL, 0, alloc_size, PROT_READ | PROT_WRITE,
-			     MAP_PRIVATE | MAP_ANONYMOUS | MAP_LOCKED, 0,
-			     &populate, NULL);
-
-	mm->def_flags = mm_flags;
-	mmap_write_unlock(mm);
-	if (IS_ERR_VALUE(pages_addr))
-		return pages_addr;
-
-	ret = -EFAULT;
-	if (put_user(alloc_size / state_size, num) || put_user(state_size, size_per_each))
-		goto err_unmap;
-
-	return pages_addr;
-
-err_unmap:
-	vm_munmap(pages_addr, alloc_size);
-	return ret;
-}
-#endif
-
 /*********************************************************************
  *
  * Fast key erasure RNG, the "crng".
@@ -402,9 +270,6 @@ static void crng_reseed(struct work_struct *work)
 	if (next_gen == ULONG_MAX)
 		++next_gen;
 	WRITE_ONCE(base_crng.generation, next_gen);
-#ifdef CONFIG_VDSO_GETRANDOM
-	smp_store_release(&_vdso_rng_data.generation, next_gen + 1);
-#endif
 	if (!static_branch_likely(&crng_is_ready))
 		crng_init = CRNG_READY;
 	spin_unlock_irqrestore(&base_crng.lock, flags);
@@ -855,9 +720,6 @@ static void __cold _credit_init_bits(size_t bits)
 		if (static_key_initialized)
 			execute_in_process_context(crng_set_ready, &set_ready);
 		atomic_notifier_call_chain(&random_ready_notifier, 0, NULL);
-#ifdef CONFIG_VDSO_GETRANDOM
-		smp_store_release(&_vdso_rng_data.is_ready, true);
-#endif
 		wake_up_interruptible(&crng_init_wait);
 		kill_fasync(&fasync, SIGIO, POLL_IN);
 		pr_notice("crng init done\n");
diff --git a/include/linux/syscalls.h b/include/linux/syscalls.h
index dc13b0715..a34b0f9a9 100644
--- a/include/linux/syscalls.h
+++ b/include/linux/syscalls.h
@@ -1006,9 +1006,6 @@ asmlinkage long sys_seccomp(unsigned int op, unsigned int flags,
 			    void __user *uargs);
 asmlinkage long sys_getrandom(char __user *buf, size_t count,
 			      unsigned int flags);
-asmlinkage long sys_vgetrandom_alloc(unsigned int __user *num,
-				     unsigned int __user *size_per_each,
-				     unsigned long addr, unsigned int flags);
 asmlinkage long sys_memfd_create(const char __user *uname_ptr, unsigned int flags);
 asmlinkage long sys_bpf(int cmd, union bpf_attr *attr, unsigned int size);
 asmlinkage long sys_execveat(int dfd, const char __user *filename,
diff --git a/include/uapi/asm-generic/unistd.h b/include/uapi/asm-generic/unistd.h
index 9d2e299f3..45fa180cc 100644
--- a/include/uapi/asm-generic/unistd.h
+++ b/include/uapi/asm-generic/unistd.h
@@ -886,11 +886,8 @@ __SYSCALL(__NR_futex_waitv, sys_futex_waitv)
 #define __NR_set_mempolicy_home_node 450
 __SYSCALL(__NR_set_mempolicy_home_node, sys_set_mempolicy_home_node)
 
-#define __NR_vgetrandom_alloc 451
-__SYSCALL(__NR_vgetrandom_alloc, sys_vgetrandom_alloc)
-
 #undef __NR_syscalls
-#define __NR_syscalls 452
+#define __NR_syscalls 451
 
 /*
  * 32 bit systems traditionally used different
diff --git a/include/vdso/datapage.h b/include/vdso/datapage.h
index d1f800c1c..73eb622e7 100644
--- a/include/vdso/datapage.h
+++ b/include/vdso/datapage.h
@@ -18,7 +18,6 @@
 #include <vdso/time.h>
 #include <vdso/time32.h>
 #include <vdso/time64.h>
-#include <vdso/types.h>
 
 #ifdef CONFIG_ARCH_HAS_VDSO_DATA
 #include <asm/vdso/data.h>
@@ -110,16 +109,6 @@ struct vdso_data {
 	struct arch_vdso_data	arch_data;
 };
 
-/**
- * struct vdso_rng_data - vdso RNG state information
- * @generation:	counter representing the number of RNG reseeds
- * @is_ready:	boolean signaling whether the RNG is initialized
- */
-struct vdso_rng_data {
-	vdso_kernel_ulong	generation;
-	u8			is_ready;
-};
-
 /*
  * We use the hidden visibility to prevent the compiler from generating a GOT
  * relocation. Not only is going through a GOT useless (the entry couldn't and
@@ -131,7 +120,6 @@ struct vdso_rng_data {
  */
 extern struct vdso_data _vdso_data[CS_BASES] __attribute__((visibility("hidden")));
 extern struct vdso_data _timens_data[CS_BASES] __attribute__((visibility("hidden")));
-extern struct vdso_rng_data _vdso_rng_data __attribute__((visibility("hidden")));
 
 /*
  * The generic vDSO implementation requires that gettimeofday.h
diff --git a/include/vdso/getrandom.h b/include/vdso/getrandom.h
deleted file mode 100644
index 7dc93d5f7..000000000
--- a/include/vdso/getrandom.h
+++ /dev/null
@@ -1,44 +0,0 @@
-/* SPDX-License-Identifier: GPL-2.0 */
-/*
- * Copyright (C) 2022 Jason A. Donenfeld <Jason@zx2c4.com>. All Rights Reserved.
- */
-
-#ifndef _VDSO_GETRANDOM_H
-#define _VDSO_GETRANDOM_H
-
-#include <crypto/chacha.h>
-#include <vdso/types.h>
-
-/**
- * struct vgetrandom_state - State used by vDSO getrandom() and allocated by vgetrandom_alloc().
- *
- * @batch:	One and a half ChaCha20 blocks of buffered RNG output.
- *
- * @key:	Key to be used for generating next batch.
- *
- * @batch_key:	Union of the prior two members, which is exactly two full
- * 		ChaCha20 blocks in size, so that @batch and @key can be filled
- * 		together.
- *
- * @generation:	Snapshot of @rng_info->generation in the vDSO data page at
- *		the time @key was generated.
- *
- * @pos:	Offset into @batch of the next available random byte.
- *
- * @in_use:	Reentrancy guard for reusing a state within the same thread
- *		due to signal handlers.
- */
-struct vgetrandom_state {
-	union {
-		struct {
-			u8	batch[CHACHA_BLOCK_SIZE * 3 / 2];
-			u32	key[CHACHA_KEY_SIZE / sizeof(u32)];
-		};
-		u8		batch_key[CHACHA_BLOCK_SIZE * 2];
-	};
-	vdso_kernel_ulong	generation;
-	u8			pos;
-	bool 			in_use;
-};
-
-#endif /* _VDSO_GETRANDOM_H */
diff --git a/include/vdso/types.h b/include/vdso/types.h
deleted file mode 100644
index ce131463a..000000000
--- a/include/vdso/types.h
+++ /dev/null
@@ -1,35 +0,0 @@
-/* SPDX-License-Identifier: GPL-2.0 */
-/*
- * Copyright (C) 2022 Jason A. Donenfeld <Jason@zx2c4.com>. All Rights Reserved.
- */
-#ifndef __VDSO_TYPES_H
-#define __VDSO_TYPES_H
-
-#include <linux/types.h>
-
-/**
- * type vdso_kernel_ulong - unsigned long type that matches kernel's unsigned long
- *
- * Data shared between userspace and the kernel must operate the same way in both 64-bit code and in
- * 32-bit compat code, over the same potentially 64-bit kernel. This type represents the size of an
- * unsigned long as used by kernel code. This isn't necessarily the same as an unsigned long as used
- * by userspace, however.
- *
- *                 +-------------------+-------------------+------------------+-------------------+
- *                 | 32-bit userspace  | 32-bit userspace  | 64-bit userspace | 64-bit userspace  |
- *                 | unsigned long     | vdso_kernel_ulong | unsigned long    | vdso_kernel_ulong |
- * +---------------+-------------------+-------------------+------------------+-------------------+
- * | 32-bit kernel | ✓ same size       | ✓ same size       |
- * | unsigned long |                   |                   |
- * +---------------+-------------------+-------------------+------------------+-------------------+
- * | 64-bit kernel | ✘ different size! | ✓ same size       | ✓ same size      | ✓ same size       |
- * | unsigned long |                   |                   |                  |                   |
- * +---------------+-------------------+-------------------+------------------+-------------------+
- */
-#ifdef CONFIG_64BIT
-typedef u64 vdso_kernel_ulong;
-#else
-typedef u32 vdso_kernel_ulong;
-#endif
-
-#endif /* __VDSO_TYPES_H */
diff --git a/kernel/sys_ni.c b/kernel/sys_ni.c
index f28196cb9..860b2dcf3 100644
--- a/kernel/sys_ni.c
+++ b/kernel/sys_ni.c
@@ -360,9 +360,6 @@ COND_SYSCALL(pkey_free);
 /* memfd_secret */
 COND_SYSCALL(memfd_secret);
 
-/* random */
-COND_SYSCALL(vgetrandom_alloc);
-
 /*
  * Architecture specific weak syscall entries.
  */
diff --git a/lib/vdso/Kconfig b/lib/vdso/Kconfig
index 3b394fa83..d883ac299 100644
--- a/lib/vdso/Kconfig
+++ b/lib/vdso/Kconfig
@@ -31,8 +31,3 @@ config GENERIC_VDSO_TIME_NS
 	  VDSO
 
 endif
-
-config VDSO_GETRANDOM
-	bool
-	help
-	  Selected by architectures that support vDSO getrandom().
diff --git a/lib/vdso/getrandom.c b/lib/vdso/getrandom.c
deleted file mode 100644
index 9ca624756..000000000
--- a/lib/vdso/getrandom.c
+++ /dev/null
@@ -1,205 +0,0 @@
-// SPDX-License-Identifier: GPL-2.0
-/*
- * Copyright (C) 2022 Jason A. Donenfeld <Jason@zx2c4.com>. All Rights Reserved.
- */
-
-#include <linux/cache.h>
-#include <linux/kernel.h>
-#include <linux/time64.h>
-#include <vdso/datapage.h>
-#include <vdso/getrandom.h>
-#include <asm/vdso/getrandom.h>
-#include <asm/vdso/vsyscall.h>
-
-#define MEMCPY_AND_ZERO_SRC(type, dst, src, len) do {				\
-	while (len >= sizeof(type)) {						\
-		__put_unaligned_t(type, __get_unaligned_t(type, src), dst);	\
-		__put_unaligned_t(type, 0, src);				\
-		dst += sizeof(type);						\
-		src += sizeof(type);						\
-		len -= sizeof(type);						\
-	}									\
-} while (0)
-
-static void memcpy_and_zero_src(void *dst, void *src, size_t len)
-{
-	if (IS_ENABLED(CONFIG_HAVE_EFFICIENT_UNALIGNED_ACCESS)) {
-		if (IS_ENABLED(CONFIG_64BIT))
-			MEMCPY_AND_ZERO_SRC(u64, dst, src, len);
-		MEMCPY_AND_ZERO_SRC(u32, dst, src, len);
-		MEMCPY_AND_ZERO_SRC(u16, dst, src, len);
-	}
-	MEMCPY_AND_ZERO_SRC(u8, dst, src, len);
-}
-
-/**
- * __cvdso_getrandom_data - Generic vDSO implementation of getrandom() syscall.
- * @rng_info:		Describes state of kernel RNG, memory shared with kernel.
- * @buffer:		Destination buffer to fill with random bytes.
- * @len:		Size of @buffer in bytes.
- * @flags:		Zero or more GRND_* flags.
- * @opaque_state:	Pointer to an opaque state area.
- *
- * This implements a "fast key erasure" RNG using ChaCha20, in the same way that the kernel's
- * getrandom() syscall does. It periodically reseeds its key from the kernel's RNG, at the same
- * schedule that the kernel's RNG is reseeded. If the kernel's RNG is not ready, then this always
- * calls into the syscall.
- *
- * @opaque_state *must* be allocated using the vgetrandom_alloc() syscall.  Unless external locking
- * is used, one state must be allocated per thread, as it is not safe to call this function
- * concurrently with the same @opaque_state. However, it is safe to call this using the same
- * @opaque_state that is shared between main code and signal handling code, within the same thread.
- *
- * Returns the number of random bytes written to @buffer, or a negative value indicating an error.
- */
-static __always_inline ssize_t
-__cvdso_getrandom_data(const struct vdso_rng_data *rng_info, void *buffer, size_t len,
-		       unsigned int flags, void *opaque_state)
-{
-	ssize_t ret = min_t(size_t, INT_MAX & PAGE_MASK /* = MAX_RW_COUNT */, len);
-	struct vgetrandom_state *state = opaque_state;
-	size_t batch_len, nblocks, orig_len = len;
-	unsigned long current_generation;
-	void *orig_buffer = buffer;
-	u32 counter[2] = { 0 };
-	bool in_use;
-
-	/*
-	 * If the kernel's RNG is not yet ready, then it's not possible to provide random bytes from
-	 * userspace, because A) the various @flags require this to block, or not, depending on
-	 * various factors unavailable to userspace, and B) the kernel's behavior before the RNG is
-	 * ready is to reseed from the entropy pool at every invocation.
-	 */
-	if (unlikely(!READ_ONCE(rng_info->is_ready)))
-		goto fallback_syscall;
-
-	/*
-	 * This condition is checked after @rng_info->is_ready, because before the kernel's RNG is
-	 * initialized, the @flags parameter may require this to block or return an error, even when
-	 * len is zero.
-	 */
-	if (unlikely(!len))
-		return 0;
-
-	/*
-	 * @state->in_use is basic reentrancy protection against this running in a signal handler
-	 * with the same @opaque_state, but obviously not atomic wrt multiple CPUs or more than one
-	 * level of reentrancy. If a signal interrupts this after reading @state->in_use, but before
-	 * writing @state->in_use, there is still no race, because the signal handler will run to
-	 * its completion before returning execution.
-	 */
-	in_use = READ_ONCE(state->in_use);
-	if (unlikely(in_use))
-		goto fallback_syscall;
-	WRITE_ONCE(state->in_use, true);
-
-retry_generation:
-	/*
-	 * @rng_info->generation must always be read here, as it serializes @state->key with the
-	 * kernel's RNG reseeding schedule.
-	 */
-	current_generation = READ_ONCE(rng_info->generation);
-
-	/*
-	 * If @state->generation doesn't match the kernel RNG's generation, then it means the
-	 * kernel's RNG has reseeded, and so @state->key is reseeded as well.
-	 */
-	if (unlikely(state->generation != current_generation)) {
-		/*
-		 * Write the generation before filling the key, in case of fork. If there is a fork
-		 * just after this line, the two forks will get different random bytes from the
-		 * syscall, which is good. However, were this line to occur after the getrandom
-		 * syscall, then both child and parent could have the same bytes and the same
-		 * generation counter, so the fork would not be detected. Therefore, write
-		 * @state->generation before the call to the getrandom syscall.
-		 */
-		WRITE_ONCE(state->generation, current_generation);
-
-		/* Reseed @state->key using fresh bytes from the kernel. */
-		if (getrandom_syscall(state->key, sizeof(state->key), 0) != sizeof(state->key)) {
-			/*
-			 * If the syscall failed to refresh the key, then @state->key is now
-			 * invalid, so invalidate the generation so that it is not used again, and
-			 * fallback to using the syscall entirely.
-			 */
-			WRITE_ONCE(state->generation, 0);
-
-			/*
-			 * Set @state->in_use to false only after the last write to @state in the
-			 * line above.
-			 */
-			WRITE_ONCE(state->in_use, false);
-
-			goto fallback_syscall;
-		}
-
-		/*
-		 * Set @state->pos to beyond the end of the batch, so that the batch is refilled
-		 * using the new key.
-		 */
-		state->pos = sizeof(state->batch);
-	}
-
-	/* Set len to the total amount of bytes that this function is allowed to read, ret. */
-	len = ret;
-more_batch:
-	/*
-	 * First use bytes out of @state->batch, which may have been filled by the last call to this
-	 * function.
-	 */
-	batch_len = min_t(size_t, sizeof(state->batch) - state->pos, len);
-	if (batch_len) {
-		/* Zeroing at the same time as memcpying helps preserve forward secrecy. */
-		memcpy_and_zero_src(buffer, state->batch + state->pos, batch_len);
-		state->pos += batch_len;
-		buffer += batch_len;
-		len -= batch_len;
-	}
-
-	if (!len) {
-		/*
-		 * Since @rng_info->generation will never be 0, re-read @state->generation, rather
-		 * than using the local current_generation variable, to learn whether a fork
-		 * occurred. Primarily, though, this indicates whether the kernel's RNG has
-		 * reseeded, in which case generate a new key and start over.
-		 */
-		if (unlikely(READ_ONCE(state->generation) != READ_ONCE(rng_info->generation))) {
-			buffer = orig_buffer;
-			goto retry_generation;
-		}
-
-		/*
-		 * Set @state->in_use to false only when there will be no more reads or writes of
-		 * @state.
-		 */
-		WRITE_ONCE(state->in_use, false);
-		return ret;
-	}
-
-	/* Generate blocks of RNG output directly into @buffer while there's enough room left. */
-	nblocks = len / CHACHA_BLOCK_SIZE;
-	if (nblocks) {
-		__arch_chacha20_blocks_nostack(buffer, state->key, counter, nblocks);
-		buffer += nblocks * CHACHA_BLOCK_SIZE;
-		len -= nblocks * CHACHA_BLOCK_SIZE;
-	}
-
-	BUILD_BUG_ON(sizeof(state->batch_key) % CHACHA_BLOCK_SIZE != 0);
-
-	/* Refill the batch and then overwrite the key, in order to preserve forward secrecy. */
-	__arch_chacha20_blocks_nostack(state->batch_key, state->key, counter,
-				       sizeof(state->batch_key) / CHACHA_BLOCK_SIZE);
-
-	/* Since the batch was just refilled, set the position back to 0 to indicate a full batch. */
-	state->pos = 0;
-	goto more_batch;
-
-fallback_syscall:
-	return getrandom_syscall(orig_buffer, orig_len, flags);
-}
-
-static __always_inline ssize_t
-__cvdso_getrandom(void *buffer, size_t len, unsigned int flags, void *opaque_state)
-{
-	return __cvdso_getrandom_data(__arch_get_vdso_rng_data(), buffer, len, flags, opaque_state);
-}
diff --git a/tools/include/uapi/asm-generic/unistd.h b/tools/include/uapi/asm-generic/unistd.h
index 9d2e299f3..45fa180cc 100644
--- a/tools/include/uapi/asm-generic/unistd.h
+++ b/tools/include/uapi/asm-generic/unistd.h
@@ -886,11 +886,8 @@ __SYSCALL(__NR_futex_waitv, sys_futex_waitv)
 #define __NR_set_mempolicy_home_node 450
 __SYSCALL(__NR_set_mempolicy_home_node, sys_set_mempolicy_home_node)
 
-#define __NR_vgetrandom_alloc 451
-__SYSCALL(__NR_vgetrandom_alloc, sys_vgetrandom_alloc)
-
 #undef __NR_syscalls
-#define __NR_syscalls 452
+#define __NR_syscalls 451
 
 /*
  * 32 bit systems traditionally used different
diff --git a/tools/perf/arch/mips/entry/syscalls/syscall_n64.tbl b/tools/perf/arch/mips/entry/syscalls/syscall_n64.tbl
index 890e5b51e..3f1886ad9 100644
--- a/tools/perf/arch/mips/entry/syscalls/syscall_n64.tbl
+++ b/tools/perf/arch/mips/entry/syscalls/syscall_n64.tbl
@@ -365,4 +365,3 @@
 448	n64	process_mrelease		sys_process_mrelease
 449	n64	futex_waitv			sys_futex_waitv
 450	common	set_mempolicy_home_node		sys_set_mempolicy_home_node
-451	n64	vgetrandom_alloc		sys_vgetrandom_alloc
diff --git a/tools/perf/arch/powerpc/entry/syscalls/syscall.tbl b/tools/perf/arch/powerpc/entry/syscalls/syscall.tbl
index d58da67a9..e9e0df4f9 100644
--- a/tools/perf/arch/powerpc/entry/syscalls/syscall.tbl
+++ b/tools/perf/arch/powerpc/entry/syscalls/syscall.tbl
@@ -534,4 +534,3 @@
 448	common	process_mrelease		sys_process_mrelease
 449	common  futex_waitv                     sys_futex_waitv
 450 	nospu	set_mempolicy_home_node		sys_set_mempolicy_home_node
-451	common	vgetrandom_alloc		sys_vgetrandom_alloc
diff --git a/tools/perf/arch/s390/entry/syscalls/syscall.tbl b/tools/perf/arch/s390/entry/syscalls/syscall.tbl
index 5b0b2bea4..799147658 100644
--- a/tools/perf/arch/s390/entry/syscalls/syscall.tbl
+++ b/tools/perf/arch/s390/entry/syscalls/syscall.tbl
@@ -453,4 +453,3 @@
 448  common	process_mrelease	sys_process_mrelease		sys_process_mrelease
 449  common	futex_waitv		sys_futex_waitv			sys_futex_waitv
 450  common	set_mempolicy_home_node	sys_set_mempolicy_home_node	sys_set_mempolicy_home_node
-451  common	vgetrandom_alloc	sys_vgetrandom_alloc		sys_vgetrandom_alloc
diff --git a/tools/perf/arch/x86/entry/syscalls/syscall_64.tbl b/tools/perf/arch/x86/entry/syscalls/syscall_64.tbl
index 0186f173f..c84d12608 100644
--- a/tools/perf/arch/x86/entry/syscalls/syscall_64.tbl
+++ b/tools/perf/arch/x86/entry/syscalls/syscall_64.tbl
@@ -372,7 +372,6 @@
 448	common	process_mrelease	sys_process_mrelease
 449	common	futex_waitv		sys_futex_waitv
 450	common	set_mempolicy_home_node	sys_set_mempolicy_home_node
-451	common	vgetrandom_alloc	sys_vgetrandom_alloc
 
 #
 # Due to a historical design error, certain syscalls are numbered differently
diff --git a/tools/testing/selftests/vDSO/.gitignore b/tools/testing/selftests/vDSO/.gitignore
index 30d5c8f0e..a8dc51af5 100644
--- a/tools/testing/selftests/vDSO/.gitignore
+++ b/tools/testing/selftests/vDSO/.gitignore
@@ -6,5 +6,3 @@ vdso_test_correctness
 vdso_test_gettimeofday
 vdso_test_getcpu
 vdso_standalone_test_x86
-vdso_test_getrandom
-vdso_test_chacha
diff --git a/tools/testing/selftests/vDSO/Makefile b/tools/testing/selftests/vDSO/Makefile
index 1b9057974..d53a4d800 100644
--- a/tools/testing/selftests/vDSO/Makefile
+++ b/tools/testing/selftests/vDSO/Makefile
@@ -3,7 +3,6 @@ include ../lib.mk
 
 uname_M := $(shell uname -m 2>/dev/null || echo not)
 ARCH ?= $(shell echo $(uname_M) | sed -e s/i.86/x86/ -e s/x86_64/x86/)
-SODIUM := $(shell pkg-config --libs libsodium 2>/dev/null)
 
 TEST_GEN_PROGS := $(OUTPUT)/vdso_test_gettimeofday $(OUTPUT)/vdso_test_getcpu
 TEST_GEN_PROGS += $(OUTPUT)/vdso_test_abi
@@ -12,16 +11,9 @@ ifeq ($(ARCH),$(filter $(ARCH),x86 x86_64))
 TEST_GEN_PROGS += $(OUTPUT)/vdso_standalone_test_x86
 endif
 TEST_GEN_PROGS += $(OUTPUT)/vdso_test_correctness
-TEST_GEN_PROGS += $(OUTPUT)/vdso_test_getrandom
-ifeq ($(uname_M),x86_64)
-ifneq ($(SODIUM),)
-TEST_GEN_PROGS += $(OUTPUT)/vdso_test_chacha
-endif
-endif
 
 CFLAGS := -std=gnu99
 CFLAGS_vdso_standalone_test_x86 := -nostdlib -fno-asynchronous-unwind-tables -fno-stack-protector
-CFLAGS_vdso_test_chacha := $(SODIUM) -idirafter $(top_srcdir)/include -idirafter $(top_srcdir)/arch/$(ARCH)/include -D__ASSEMBLY__ -Wa,--noexecstack
 LDFLAGS_vdso_test_correctness := -ldl
 ifeq ($(CONFIG_X86_32),y)
 LDLIBS += -lgcc_s
@@ -41,6 +33,3 @@ $(OUTPUT)/vdso_test_correctness: vdso_test_correctness.c
 		vdso_test_correctness.c \
 		-o $@ \
 		$(LDFLAGS_vdso_test_correctness)
-$(OUTPUT)/vdso_test_getrandom: parse_vdso.c
-$(OUTPUT)/vdso_test_chacha: CFLAGS += $(CFLAGS_vdso_test_chacha)
-$(OUTPUT)/vdso_test_chacha: $(top_srcdir)/arch/$(ARCH)/entry/vdso/vgetrandom-chacha.S
diff --git a/tools/testing/selftests/vDSO/vdso_test_chacha.c b/tools/testing/selftests/vDSO/vdso_test_chacha.c
deleted file mode 100644
index 1c76aeb3d..000000000
--- a/tools/testing/selftests/vDSO/vdso_test_chacha.c
+++ /dev/null
@@ -1,43 +0,0 @@
-// SPDX-License-Identifier: GPL-2.0
-/*
- * Copyright (C) 2022 Jason A. Donenfeld <Jason@zx2c4.com>. All Rights Reserved.
- */
-
-#include <sodium/crypto_stream_chacha20.h>
-#include <sys/random.h>
-#include <string.h>
-#include <stdint.h>
-#include "../kselftest.h"
-
-extern void __arch_chacha20_blocks_nostack(uint8_t *dst_bytes, const uint8_t *key, uint32_t *counter, size_t nblocks);
-
-int main(int argc, char *argv[])
-{
-	enum { TRIALS = 1000, BLOCKS = 128, BLOCK_SIZE = 64 };
-	static const uint8_t nonce[8] = { 0 };
-	uint32_t counter[2];
-	uint8_t key[32];
-	uint8_t output1[BLOCK_SIZE * BLOCKS], output2[BLOCK_SIZE * BLOCKS];
-
-	ksft_print_header();
-	ksft_set_plan(1);
-
-	for (unsigned int trial; trial < TRIALS; ++trial) {
-		if (getrandom(key, sizeof(key), 0) != sizeof(key)) {
-			printf("getrandom() failed!\n");
-			return KSFT_SKIP;
-		}
-		crypto_stream_chacha20(output1, sizeof(output1), nonce, key);
-		for (unsigned int split = 0; split < BLOCKS; ++split) {
-			memset(output2, 'X', sizeof(output2));
-			memset(counter, 0, sizeof(counter));
-			if (split)
-				__arch_chacha20_blocks_nostack(output2, key, counter, split);
-			__arch_chacha20_blocks_nostack(output2 + split * BLOCK_SIZE, key, counter, BLOCKS - split);
-			if (memcmp(output1, output2, sizeof(output1)))
-				return KSFT_FAIL;
-		}
-	}
-	ksft_test_result_pass("chacha: PASS\n");
-	return KSFT_PASS;
-}
diff --git a/tools/testing/selftests/vDSO/vdso_test_getrandom.c b/tools/testing/selftests/vDSO/vdso_test_getrandom.c
deleted file mode 100644
index 528674899..000000000
--- a/tools/testing/selftests/vDSO/vdso_test_getrandom.c
+++ /dev/null
@@ -1,279 +0,0 @@
-// SPDX-License-Identifier: GPL-2.0
-/*
- * Copyright (C) 2022 Jason A. Donenfeld <Jason@zx2c4.com>. All Rights Reserved.
- */
-
-#include <assert.h>
-#include <pthread.h>
-#include <stdint.h>
-#include <stdio.h>
-#include <stdlib.h>
-#include <string.h>
-#include <time.h>
-#include <unistd.h>
-#include <sys/auxv.h>
-#include <sys/mman.h>
-#include <sys/random.h>
-#include <sys/syscall.h>
-#include <sys/types.h>
-
-#include "../kselftest.h"
-#include "parse_vdso.h"
-
-#ifndef timespecsub
-#define	timespecsub(tsp, usp, vsp)					\
-	do {								\
-		(vsp)->tv_sec = (tsp)->tv_sec - (usp)->tv_sec;		\
-		(vsp)->tv_nsec = (tsp)->tv_nsec - (usp)->tv_nsec;	\
-		if ((vsp)->tv_nsec < 0) {				\
-			(vsp)->tv_sec--;				\
-			(vsp)->tv_nsec += 1000000000L;			\
-		}							\
-	} while (0)
-#endif
-
-static void *vgetrandom_alloc(unsigned int *num, unsigned int *size_per_each)
-{
-	enum { __NR_vgetrandom_alloc = 451 };
-	*size_per_each = 0;
-	return (void *)syscall(__NR_vgetrandom_alloc, num, size_per_each, 0, 0);
-}
-
-static struct {
-	pthread_mutex_t lock;
-	void **states;
-	size_t len, cap;
-} grnd_allocator = {
-	.lock = PTHREAD_MUTEX_INITIALIZER
-};
-
-static void *vgetrandom_get_state(void)
-{
-	void *state = NULL;
-
-	pthread_mutex_lock(&grnd_allocator.lock);
-	if (!grnd_allocator.len) {
-		size_t new_cap;
-		unsigned int num = sysconf(_SC_NPROCESSORS_ONLN); /* Could be arbitrary, just a hint. */
-		unsigned int size_per_each;
-		void *new_block = vgetrandom_alloc(&num, &size_per_each);
-		void *new_states;
-
-		if (new_block == MAP_FAILED)
-			goto out;
-		new_cap = grnd_allocator.cap + num;
-		new_states = reallocarray(grnd_allocator.states, new_cap, sizeof(*grnd_allocator.states));
-		if (!new_states) {
-			munmap(new_block, num * size_per_each);
-			goto out;
-		}
-		grnd_allocator.cap = new_cap;
-		grnd_allocator.states = new_states;
-
-		for (size_t i = 0; i < num; ++i) {
-			grnd_allocator.states[i] = new_block;
-			new_block += size_per_each;
-		}
-		grnd_allocator.len = num;
-	}
-	state = grnd_allocator.states[--grnd_allocator.len];
-
-out:
-	pthread_mutex_unlock(&grnd_allocator.lock);
-	return state;
-}
-
-static void vgetrandom_put_state(void *state)
-{
-	if (!state)
-		return;
-	pthread_mutex_lock(&grnd_allocator.lock);
-	grnd_allocator.states[grnd_allocator.len++] = state;
-	pthread_mutex_unlock(&grnd_allocator.lock);
-}
-
-static struct {
-	ssize_t(*fn)(void *buf, size_t len, unsigned long flags, void *state);
-	pthread_key_t key;
-	pthread_once_t initialized;
-} grnd_ctx = {
-	.initialized = PTHREAD_ONCE_INIT
-};
-
-static void vgetrandom_init(void)
-{
-	if (pthread_key_create(&grnd_ctx.key, vgetrandom_put_state) != 0)
-		return;
-	unsigned long sysinfo_ehdr = getauxval(AT_SYSINFO_EHDR);
-	if (!sysinfo_ehdr) {
-		printf("AT_SYSINFO_EHDR is not present!\n");
-		exit(KSFT_SKIP);
-	}
-	vdso_init_from_sysinfo_ehdr(sysinfo_ehdr);
-	grnd_ctx.fn = (__typeof__(grnd_ctx.fn))vdso_sym("LINUX_2.6", "__vdso_getrandom");
-	if (!grnd_ctx.fn) {
-		printf("__vdso_getrandom is missing!\n");
-		exit(KSFT_FAIL);
-	}
-}
-
-static ssize_t vgetrandom(void *buf, size_t len, unsigned long flags)
-{
-	void *state;
-
-	pthread_once(&grnd_ctx.initialized, vgetrandom_init);
-	state = pthread_getspecific(grnd_ctx.key);
-	if (!state) {
-		state = vgetrandom_get_state();
-		if (pthread_setspecific(grnd_ctx.key, state) != 0) {
-			vgetrandom_put_state(state);
-			state = NULL;
-		}
-		if (!state) {
-			printf("vgetrandom_get_state failed!\n");
-			exit(KSFT_FAIL);
-		}
-	}
-	return grnd_ctx.fn(buf, len, flags, state);
-}
-
-enum { TRIALS = 25000000, THREADS = 256 };
-
-static void *test_vdso_getrandom(void *)
-{
-	for (size_t i = 0; i < TRIALS; ++i) {
-		unsigned int val;
-		ssize_t ret = vgetrandom(&val, sizeof(val), 0);
-		assert(ret == sizeof(val));
-	}
-	return NULL;
-}
-
-static void *test_libc_getrandom(void *)
-{
-	for (size_t i = 0; i < TRIALS; ++i) {
-		unsigned int val;
-		ssize_t ret = getrandom(&val, sizeof(val), 0);
-		assert(ret == sizeof(val));
-	}
-	return NULL;
-}
-
-static void *test_syscall_getrandom(void *)
-{
-	for (size_t i = 0; i < TRIALS; ++i) {
-		unsigned int val;
-		ssize_t ret = syscall(SYS_getrandom, &val, sizeof(val), 0);
-		assert(ret == sizeof(val));
-	}
-	return NULL;
-}
-
-static void bench_single(void)
-{
-	struct timespec start, end, diff;
-
-	clock_gettime(CLOCK_MONOTONIC, &start);
-	test_vdso_getrandom(NULL);
-	clock_gettime(CLOCK_MONOTONIC, &end);
-	timespecsub(&end, &start, &diff);
-	printf("   vdso: %u times in %lu.%09lu seconds\n", TRIALS, diff.tv_sec, diff.tv_nsec);
-
-	clock_gettime(CLOCK_MONOTONIC, &start);
-	test_libc_getrandom(NULL);
-	clock_gettime(CLOCK_MONOTONIC, &end);
-	timespecsub(&end, &start, &diff);
-	printf("   libc: %u times in %lu.%09lu seconds\n", TRIALS, diff.tv_sec, diff.tv_nsec);
-
-	clock_gettime(CLOCK_MONOTONIC, &start);
-	test_syscall_getrandom(NULL);
-	clock_gettime(CLOCK_MONOTONIC, &end);
-	timespecsub(&end, &start, &diff);
-	printf("syscall: %u times in %lu.%09lu seconds\n", TRIALS, diff.tv_sec, diff.tv_nsec);
-}
-
-static void bench_multi(void)
-{
-	struct timespec start, end, diff;
-	pthread_t threads[THREADS];
-
-	clock_gettime(CLOCK_MONOTONIC, &start);
-	for (size_t i = 0; i < THREADS; ++i)
-		assert(pthread_create(&threads[i], NULL, test_vdso_getrandom, NULL) == 0);
-	for (size_t i = 0; i < THREADS; ++i)
-		pthread_join(threads[i], NULL);
-	clock_gettime(CLOCK_MONOTONIC, &end);
-	timespecsub(&end, &start, &diff);
-	printf("   vdso: %u x %u times in %lu.%09lu seconds\n", TRIALS, THREADS, diff.tv_sec, diff.tv_nsec);
-
-	clock_gettime(CLOCK_MONOTONIC, &start);
-	for (size_t i = 0; i < THREADS; ++i)
-		assert(pthread_create(&threads[i], NULL, test_libc_getrandom, NULL) == 0);
-	for (size_t i = 0; i < THREADS; ++i)
-		pthread_join(threads[i], NULL);
-	clock_gettime(CLOCK_MONOTONIC, &end);
-	timespecsub(&end, &start, &diff);
-	printf("   libc: %u x %u times in %lu.%09lu seconds\n", TRIALS, THREADS, diff.tv_sec, diff.tv_nsec);
-
-	clock_gettime(CLOCK_MONOTONIC, &start);
-	for (size_t i = 0; i < THREADS; ++i)
-		assert(pthread_create(&threads[i], NULL, test_syscall_getrandom, NULL) == 0);
-	for (size_t i = 0; i < THREADS; ++i)
-		pthread_join(threads[i], NULL);
-	clock_gettime(CLOCK_MONOTONIC, &end);
-	timespecsub(&end, &start, &diff);
-	printf("   syscall: %u x %u times in %lu.%09lu seconds\n", TRIALS, THREADS, diff.tv_sec, diff.tv_nsec);
-}
-
-static void fill(void)
-{
-	uint8_t weird_size[323929];
-	for (;;)
-		vgetrandom(weird_size, sizeof(weird_size), 0);
-}
-
-static void kselftest(void)
-{
-	uint8_t weird_size[1263];
-
-	ksft_print_header();
-	ksft_set_plan(1);
-
-	for (size_t i = 0; i < 1000; ++i) {
-		ssize_t ret = vgetrandom(weird_size, sizeof(weird_size), 0);
-		if (ret != sizeof(weird_size))
-			exit(KSFT_FAIL);
-	}
-
-	ksft_test_result_pass("getrandom: PASS\n");
-	exit(KSFT_PASS);
-}
-
-static void usage(const char *argv0)
-{
-	fprintf(stderr, "Usage: %s [bench-single|bench-multi|fill]\n", argv0);
-}
-
-int main(int argc, char *argv[])
-{
-	if (argc == 1) {
-		kselftest();
-		return 0;
-	}
-
-	if (argc != 2) {
-		usage(argv[0]);
-		return 1;
-	}
-	if (!strcmp(argv[1], "bench-single"))
-		bench_single();
-	else if (!strcmp(argv[1], "bench-multi"))
-		bench_multi();
-	else if (!strcmp(argv[1], "fill"))
-		fill();
-	else {
-		usage(argv[0]);
-		return 1;
-	}
-	return 0;
-}
-- 
2.39.0.rc2.1.gbd5df96b79

