From bd401ebe8b527f27fef1cfd06baf62834672dba1 Mon Sep 17 00:00:00 2001
From: Peter Jung <admin@ptr1337.dev>
Date: Fri, 29 Aug 2025 20:24:51 +0200
Subject: [PATCH 5/6] Revert "drm: don't run atomic_async_check for disabled
 planes"

This reverts commit f0c95743e147bbb98e8c81bd38e3bada8ae2d0f6.
---
 drivers/gpu/drm/drm_atomic_uapi.c | 51 ++++++++++---------------------
 1 file changed, 16 insertions(+), 35 deletions(-)

diff --git a/drivers/gpu/drm/drm_atomic_uapi.c b/drivers/gpu/drm/drm_atomic_uapi.c
index e8b6c87bd..ecc73d52b 100644
--- a/drivers/gpu/drm/drm_atomic_uapi.c
+++ b/drivers/gpu/drm/drm_atomic_uapi.c
@@ -1069,6 +1069,7 @@ int drm_atomic_set_property(struct drm_atomic_state *state,
 		struct drm_plane *plane = obj_to_plane(obj);
 		struct drm_plane_state *plane_state;
 		struct drm_mode_config *config = &plane->dev->mode_config;
+		const struct drm_plane_helper_funcs *plane_funcs = plane->helper_private;
 
 		plane_state = drm_atomic_get_plane_state(state, plane);
 		if (IS_ERR(plane_state)) {
@@ -1084,8 +1085,21 @@ int drm_atomic_set_property(struct drm_atomic_state *state,
 				ret = drm_atomic_plane_get_property(plane, plane_state,
 								    prop, &old_val);
 				ret = drm_atomic_check_prop_changes(ret, old_val, prop_value, prop);
-				if (ret)
-				    break;
+			}
+
+			/* ask the driver if this non-primary plane is supported */
+			if (plane->type != DRM_PLANE_TYPE_PRIMARY) {
+				ret = -EINVAL;
+
+				if (plane_funcs && plane_funcs->atomic_async_check)
+					ret = plane_funcs->atomic_async_check(plane, state, true);
+
+				if (ret) {
+					drm_dbg_atomic(prop->dev,
+						       "[PLANE:%d:%s] does not support async flips\n",
+						       obj->id, plane->name);
+					break;
+				}
 			}
 		}
 
@@ -1381,10 +1395,6 @@ int drm_mode_atomic_ioctl(struct drm_device *dev,
 	int ret = 0;
 	unsigned int i, j, num_fences;
 	bool async_flip = false;
-	struct drm_plane *plane;
-	struct drm_plane_state *old_plane_state = NULL;
-	struct drm_plane_state *new_plane_state = NULL;
-	u64 fb_id = 0;
 
 	/* disallow for drivers not supporting atomic: */
 	if (!drm_core_check_feature(dev, DRIVER_ATOMIC))
@@ -1512,35 +1522,6 @@ int drm_mode_atomic_ioctl(struct drm_device *dev,
 			copied_props++;
 		}
 
-		if (async_flip && obj->type == DRM_MODE_OBJECT_PLANE &&
-		    obj_to_plane(obj)->type != DRM_PLANE_TYPE_PRIMARY) {
-			/* need to ask the driver if this plane is supported */
-			plane = obj_to_plane(obj);
-			old_plane_state = drm_atomic_get_old_plane_state(state, plane);
-			new_plane_state = drm_atomic_get_new_plane_state(state, plane);
-			ret = drm_atomic_plane_get_property(plane, new_plane_state,
-							    dev->mode_config.prop_fb_id,
-							    &fb_id);
-			if (ret)
-				break;
-			/*
-			 * Only do the check if the plane was or is enabled.
-			 * Note that the new state doesn't have "visible" set yet,
-			 * so this uses fb_id instead.
-			 */
-			if (old_plane_state->visible || fb_id)
-				ret = -EINVAL;
-			if (ret && plane->helper_private &&
-			    plane->helper_private->atomic_async_check) {
-				ret = plane->helper_private->atomic_async_check(plane, state, true);
-			}
-			if (ret) {
-				drm_dbg_atomic(dev, "[PLANE:%d:%s] does not support async flips\n",
-						obj->id, plane->name);
-				break;
-			}
-		}
-
 		drm_mode_object_put(obj);
 	}
 
-- 
2.51.0

