From 465baa30f74a14033ce5ad72dabc366551746ace Mon Sep 17 00:00:00 2001
From: Kent Overstreet <kent.overstreet@linux.dev>
Date: Thu, 22 Feb 2024 01:40:09 -0500
Subject: [PATCH 40/40] codetag: eytzinger lookup

Signed-off-by: Kent Overstreet <kent.overstreet@linux.dev>
---
 lib/codetag.c | 118 ++++++++++++++++++++++++++++++++++++++------------
 1 file changed, 90 insertions(+), 28 deletions(-)

diff --git a/lib/codetag.c b/lib/codetag.c
index 96c86a1dc..625579790 100644
--- a/lib/codetag.c
+++ b/lib/codetag.c
@@ -1,25 +1,31 @@
 // SPDX-License-Identifier: GPL-2.0-only
 #include <linux/codetag.h>
 #include <linux/darray.h>
+#include <linux/eytzinger.h>
 #include <linux/kallsyms.h>
 #include <linux/module.h>
 #include <linux/seq_buf.h>
 #include <linux/slab.h>
 #include <linux/vmalloc.h>
 
+struct codetag_range {
+	unsigned			idx;
+	unsigned			nr;
+	struct codetag			*start;
+};
+
 struct codetag_module {
-	unsigned		idx;
-	unsigned		nr;
-	struct module		*mod;
-	struct codetag		*start;
+	struct codetag_range		tags;
+	struct module			*mod;
 };
 
 struct codetag_type {
-	struct list_head	link;
-	unsigned int		count;
-	struct rw_semaphore	mod_lock; /* protects mod_idr */
-	DARRAY(struct codetag_module) mods;
-	struct codetag_type_desc desc;
+	struct list_head		link;
+	unsigned int			count;
+	struct rw_semaphore		mod_lock; /* protects mods */
+	DARRAY(struct codetag_module)	mods;
+	DARRAY(struct codetag_range)	eytz;
+	struct codetag_type_desc	desc;
 };
 
 static DEFINE_MUTEX(codetag_lock);
@@ -39,22 +45,56 @@ bool codetag_trylock_module_list(struct codetag_type *cttype)
 }
 
 static struct codetag *mod_idx_to_codetag(struct codetag_type *cttype,
-					  struct codetag_module *cmod,
+					  struct codetag_range *tags,
 					  unsigned idx)
 {
-	return (void *) cmod->start + idx * cttype->desc.tag_size;
+	return (void *) tags->start + idx * cttype->desc.tag_size;
+}
+
+#define cmp_int(l, r)		((l > r) - (l < r))
+
+static inline int codetag_range_cmp(const void *_l, const void *_r)
+{
+	const struct codetag_range *l = _l;
+	const struct codetag_range *r = _r;
+
+	return cmp_int(l->idx, r->idx);
+}
+
+static struct codetag *idx_to_codetag(struct codetag_type *cttype, unsigned idx)
+{
+	struct codetag_range search = { .idx = idx };
+	struct codetag_range *r = cttype->eytz.data +
+		eytzinger0_find_le(cttype->eytz.data,
+				   cttype->eytz.nr,
+				   sizeof(cttype->eytz.data[0]),
+				   codetag_range_cmp,
+				   &search);
+
+	BUG_ON(r >= &darray_top(cttype->eytz));
+	BUG_ON(idx < r->idx || idx >= r->idx + r->nr);
+
+	return mod_idx_to_codetag(cttype, r, idx - r->idx);
 }
 
 static struct codetag *idx_to_codetag_ge(struct codetag_type *cttype, unsigned *idx)
 {
-	darray_for_each(cttype->mods, i) {
-		if (*idx < i->idx)
-			*idx = i->idx;
-		if (*idx < i->idx + i->nr)
-			return mod_idx_to_codetag(cttype, i, *idx - i->idx);
-	}
+	struct codetag_range search = { .idx = *idx };
+	struct codetag_range *r = cttype->eytz.data +
+		eytzinger0_find_le(cttype->eytz.data,
+				   cttype->eytz.nr,
+				   sizeof(cttype->eytz.data[0]),
+				   codetag_range_cmp,
+				   &search);
+
+	if (r < &darray_top(cttype->eytz) && r->idx + r->nr <= *idx)
+		r++;
+
+	if (r >= &darray_top(cttype->eytz))
+		return NULL;
 
-	return NULL;
+	*idx = max(*idx, r->idx);
+	return mod_idx_to_codetag(cttype, r, *idx - r->idx);
 }
 
 struct codetag *codetag_next_ct(struct codetag_iterator *iter)
@@ -96,7 +136,7 @@ static void *get_symbol(struct module *mod, const char *prefix, const char *name
 	return ret;
 }
 
-static int codetag_module_init(struct codetag_type *cttype, struct module *mod)
+static int __codetag_module_init(struct codetag_type *cttype, struct module *mod)
 {
 	struct codetag *start	= get_symbol(mod, "__start_", cttype->desc.section);
 	struct codetag *stop	= get_symbol(mod, "__stop_", cttype->desc.section);
@@ -111,29 +151,51 @@ static int codetag_module_init(struct codetag_type *cttype, struct module *mod)
 	}
 
 	struct codetag_module cmod = {
-		.nr	= ((void *) stop - (void *) start) / cttype->desc.tag_size,
-		.mod	= mod,
-		.start	= start,
+		.tags.nr	= ((void *) stop - (void *) start) / cttype->desc.tag_size,
+		.tags.start	= start,
+		.mod		= mod,
 	};
 
 	/* Ignore empty ranges */
-	if (cmod.nr)
+	if (cmod.tags.nr)
 		return 0;
 
-	down_write(&cttype->mod_lock);
+	err =   darray_make_room(&cttype->mods, 1) ?:
+		darray_resize(&cttype->eytz, cttype->mods.nr + 1);
+	if (err)
+		return err;
+
 	darray_for_each(cttype->mods, i) {
-		if (cmod.idx + cmod.nr <= i->idx) {
+		if (cmod.tags.idx + cmod.tags.nr <= i->tags.idx) {
 			err = darray_insert_item(&cttype->mods, i - cttype->mods.data, cmod);
 			goto insert_done;
 		}
 
-		cmod.idx = i->idx + i->nr;
+		cmod.tags.idx = i->tags.idx + i->tags.nr;
 	}
 
 	err = darray_push(&cttype->mods, cmod);
 insert_done:
+	BUG_ON(err); /* we preallocated */
+
+	cttype->eytz.nr = cttype->mods.nr;
+
+	darray_for_each(cttype->mods, i) {
+		struct codetag_range *dst = cttype->eytz.data +
+			inorder_to_eytzinger0(i - cttype->mods.data, cttype->mods.nr);
+		*dst = i->tags;
+	}
+
+	return 0;
+}
+
+static int codetag_module_init(struct codetag_type *cttype, struct module *mod)
+{
+	down_write(&cttype->mod_lock);
+	int ret = __codetag_module_init(cttype, mod);
 	up_write(&cttype->mod_lock);
-	return err;
+
+	return ret;
 }
 
 #else /* CONFIG_MODULES */
@@ -198,7 +260,7 @@ bool codetag_unload_module(struct module *mod)
 				    !cttype->desc.module_unload(cttype, i))
 					unload_ok = false;
 
-				cttype->count -= i->nr;
+				cttype->count -= i->tags.nr;
 				darray_remove_item(&cttype->mods, i);
 				break;
 			}
-- 
2.43.0.232.ge79552d197

