From 8651edd46244348a271906345c747ec05421622b Mon Sep 17 00:00:00 2001
From: Kent Overstreet <kent.overstreet@linux.dev>
Date: Wed, 21 Feb 2024 23:15:39 -0500
Subject: [PATCH 39/40] codetag: convert from idr to darray

Signed-off-by: Kent Overstreet <kent.overstreet@linux.dev>
---
 include/linux/codetag.h |   9 +-
 lib/codetag.c           | 198 +++++++++++++---------------------------
 2 files changed, 70 insertions(+), 137 deletions(-)

diff --git a/include/linux/codetag.h b/include/linux/codetag.h
index c2a579ccd..3eb11c078 100644
--- a/include/linux/codetag.h
+++ b/include/linux/codetag.h
@@ -42,7 +42,7 @@ struct codetag_type_desc {
 struct codetag_iterator {
 	struct codetag_type *cttype;
 	struct codetag_module *cmod;
-	unsigned long mod_id;
+	unsigned idx;
 	struct codetag *ct;
 };
 
@@ -62,7 +62,12 @@ struct codetag_iterator {
 
 void codetag_lock_module_list(struct codetag_type *cttype, bool lock);
 bool codetag_trylock_module_list(struct codetag_type *cttype);
-struct codetag_iterator codetag_get_ct_iter(struct codetag_type *cttype);
+
+static inline struct codetag_iterator codetag_get_ct_iter(struct codetag_type *cttype)
+{
+	return (struct codetag_iterator) { .cttype = cttype, };
+}
+
 struct codetag *codetag_next_ct(struct codetag_iterator *iter);
 
 void codetag_to_text(struct seq_buf *out, struct codetag *ct);
diff --git a/lib/codetag.c b/lib/codetag.c
index 7b39cec96..96c86a1dc 100644
--- a/lib/codetag.c
+++ b/lib/codetag.c
@@ -1,28 +1,25 @@
 // SPDX-License-Identifier: GPL-2.0-only
 #include <linux/codetag.h>
-#include <linux/idr.h>
+#include <linux/darray.h>
 #include <linux/kallsyms.h>
 #include <linux/module.h>
 #include <linux/seq_buf.h>
 #include <linux/slab.h>
 #include <linux/vmalloc.h>
 
-struct codetag_type {
-	struct list_head link;
-	unsigned int count;
-	struct idr mod_idr;
-	struct rw_semaphore mod_lock; /* protects mod_idr */
-	struct codetag_type_desc desc;
-};
-
-struct codetag_range {
-	struct codetag *start;
-	struct codetag *stop;
+struct codetag_module {
+	unsigned		idx;
+	unsigned		nr;
+	struct module		*mod;
+	struct codetag		*start;
 };
 
-struct codetag_module {
-	struct module *mod;
-	struct codetag_range range;
+struct codetag_type {
+	struct list_head	link;
+	unsigned int		count;
+	struct rw_semaphore	mod_lock; /* protects mod_idr */
+	DARRAY(struct codetag_module) mods;
+	struct codetag_type_desc desc;
 };
 
 static DEFINE_MUTEX(codetag_lock);
@@ -41,88 +38,41 @@ bool codetag_trylock_module_list(struct codetag_type *cttype)
 	return down_read_trylock(&cttype->mod_lock) != 0;
 }
 
-struct codetag_iterator codetag_get_ct_iter(struct codetag_type *cttype)
-{
-	struct codetag_iterator iter = {
-		.cttype = cttype,
-		.cmod = NULL,
-		.mod_id = 0,
-		.ct = NULL,
-	};
-
-	return iter;
-}
-
-static inline struct codetag *get_first_module_ct(struct codetag_module *cmod)
+static struct codetag *mod_idx_to_codetag(struct codetag_type *cttype,
+					  struct codetag_module *cmod,
+					  unsigned idx)
 {
-	return cmod->range.start < cmod->range.stop ? cmod->range.start : NULL;
+	return (void *) cmod->start + idx * cttype->desc.tag_size;
 }
 
-static inline
-struct codetag *get_next_module_ct(struct codetag_iterator *iter)
+static struct codetag *idx_to_codetag_ge(struct codetag_type *cttype, unsigned *idx)
 {
-	struct codetag *res = (struct codetag *)
-			((char *)iter->ct + iter->cttype->desc.tag_size);
+	darray_for_each(cttype->mods, i) {
+		if (*idx < i->idx)
+			*idx = i->idx;
+		if (*idx < i->idx + i->nr)
+			return mod_idx_to_codetag(cttype, i, *idx - i->idx);
+	}
 
-	return res < iter->cmod->range.stop ? res : NULL;
+	return NULL;
 }
 
 struct codetag *codetag_next_ct(struct codetag_iterator *iter)
 {
-	struct codetag_type *cttype = iter->cttype;
-	struct codetag_module *cmod;
-	struct codetag *ct;
-
-	lockdep_assert_held(&cttype->mod_lock);
-
-	if (unlikely(idr_is_empty(&cttype->mod_idr)))
-		return NULL;
-
-	ct = NULL;
-	while (true) {
-		cmod = idr_find(&cttype->mod_idr, iter->mod_id);
-
-		/* If module was removed move to the next one */
-		if (!cmod)
-			cmod = idr_get_next_ul(&cttype->mod_idr,
-					       &iter->mod_id);
-
-		/* Exit if no more modules */
-		if (!cmod)
-			break;
-
-		if (cmod != iter->cmod) {
-			iter->cmod = cmod;
-			ct = get_first_module_ct(cmod);
-		} else
-			ct = get_next_module_ct(iter);
-
-		if (ct)
-			break;
-
-		iter->mod_id++;
-	}
+	lockdep_assert_held(&iter->cttype->mod_lock);
 
-	iter->ct = ct;
-	return ct;
+	iter->ct = idx_to_codetag_ge(iter->cttype, &iter->idx);
+	if (iter->ct)
+		iter->idx++;
+	return iter->ct;
 }
 
 void codetag_to_text(struct seq_buf *out, struct codetag *ct)
 {
+	seq_buf_printf(out, "%s:%u", ct->filename, ct->lineno);
 	if (ct->modname)
-		seq_buf_printf(out, "%s:%u [%s] func:%s",
-			       ct->filename, ct->lineno,
-			       ct->modname, ct->function);
-	else
-		seq_buf_printf(out, "%s:%u func:%s",
-			       ct->filename, ct->lineno, ct->function);
-}
-
-static inline size_t range_size(const struct codetag_type *cttype,
-				const struct codetag_range *range)
-{
-	return ((char *)range->stop - (char *)range->start) /
-			cttype->desc.tag_size;
+		seq_buf_printf(out, " [%s]", ct->modname);
+	seq_buf_printf(out, " func:%s", ct->function);
 }
 
 #ifdef CONFIG_MODULES
@@ -146,57 +96,44 @@ static void *get_symbol(struct module *mod, const char *prefix, const char *name
 	return ret;
 }
 
-static struct codetag_range get_section_range(struct module *mod,
-					      const char *section)
-{
-	return (struct codetag_range) {
-		get_symbol(mod, "__start_", section),
-		get_symbol(mod, "__stop_", section),
-	};
-}
-
 static int codetag_module_init(struct codetag_type *cttype, struct module *mod)
 {
-	struct codetag_range range;
-	struct codetag_module *cmod;
+	struct codetag *start	= get_symbol(mod, "__start_", cttype->desc.section);
+	struct codetag *stop	= get_symbol(mod, "__stop_", cttype->desc.section);
 	int err;
 
-	range = get_section_range(mod, cttype->desc.section);
-	if (!range.start || !range.stop) {
+	BUG_ON(start > stop);
+
+	if (!start || !stop) {
 		pr_warn("Failed to load code tags of type %s from the module %s\n",
-			cttype->desc.section,
-			mod ? mod->name : "(built-in)");
+			cttype->desc.section, mod ? mod->name : "(built-in)");
 		return -EINVAL;
 	}
 
+	struct codetag_module cmod = {
+		.nr	= ((void *) stop - (void *) start) / cttype->desc.tag_size,
+		.mod	= mod,
+		.start	= start,
+	};
+
 	/* Ignore empty ranges */
-	if (range.start == range.stop)
+	if (cmod.nr)
 		return 0;
 
-	BUG_ON(range.start > range.stop);
-
-	cmod = kmalloc(sizeof(*cmod), GFP_KERNEL);
-	if (unlikely(!cmod))
-		return -ENOMEM;
-
-	cmod->mod = mod;
-	cmod->range = range;
-
 	down_write(&cttype->mod_lock);
-	err = idr_alloc(&cttype->mod_idr, cmod, 0, 0, GFP_KERNEL);
-	if (err >= 0) {
-		cttype->count += range_size(cttype, &range);
-		if (cttype->desc.module_load)
-			cttype->desc.module_load(cttype, cmod);
-	}
-	up_write(&cttype->mod_lock);
+	darray_for_each(cttype->mods, i) {
+		if (cmod.idx + cmod.nr <= i->idx) {
+			err = darray_insert_item(&cttype->mods, i - cttype->mods.data, cmod);
+			goto insert_done;
+		}
 
-	if (err < 0) {
-		kfree(cmod);
-		return err;
+		cmod.idx = i->idx + i->nr;
 	}
 
-	return 0;
+	err = darray_push(&cttype->mods, cmod);
+insert_done:
+	up_write(&cttype->mod_lock);
+	return err;
 }
 
 #else /* CONFIG_MODULES */
@@ -216,7 +153,6 @@ codetag_register_type(const struct codetag_type_desc *desc)
 		return ERR_PTR(-ENOMEM);
 
 	cttype->desc = *desc;
-	idr_init(&cttype->mod_idr);
 	init_rwsem(&cttype->mod_lock);
 
 	err = codetag_module_init(cttype, NULL);
@@ -255,25 +191,17 @@ bool codetag_unload_module(struct module *mod)
 
 	mutex_lock(&codetag_lock);
 	list_for_each_entry(cttype, &codetag_types, link) {
-		struct codetag_module *found = NULL;
-		struct codetag_module *cmod;
-		unsigned long mod_id, tmp;
-
 		down_write(&cttype->mod_lock);
-		idr_for_each_entry_ul(&cttype->mod_idr, cmod, tmp, mod_id) {
-			if (cmod->mod && cmod->mod == mod) {
-				found = cmod;
-				break;
-			}
-		}
-		if (found) {
-			if (cttype->desc.module_unload)
-				if (!cttype->desc.module_unload(cttype, cmod))
+		darray_for_each(cttype->mods, i) {
+			if (i->mod == mod) {
+				if (cttype->desc.module_unload &&
+				    !cttype->desc.module_unload(cttype, i))
 					unload_ok = false;
 
-			cttype->count -= range_size(cttype, &cmod->range);
-			idr_remove(&cttype->mod_idr, mod_id);
-			kfree(cmod);
+				cttype->count -= i->nr;
+				darray_remove_item(&cttype->mods, i);
+				break;
+			}
 		}
 		up_write(&cttype->mod_lock);
 	}
-- 
2.43.0.232.ge79552d197

