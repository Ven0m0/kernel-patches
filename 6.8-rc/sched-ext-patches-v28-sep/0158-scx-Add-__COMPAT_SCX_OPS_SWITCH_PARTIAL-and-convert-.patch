From 4ae01779568fe370ab5787b08268e268af519f76 Mon Sep 17 00:00:00 2001
From: Tejun Heo <tj@kernel.org>
Date: Tue, 5 Mar 2024 16:29:40 -1000
Subject: [PATCH 158/166] scx: Add __COMPAT_SCX_OPS_SWITCH_PARTIAL and convert
 scx_qmap

---
 include/linux/sched/ext.h                |  3 +-
 tools/sched_ext/include/scx/common.h     |  2 +
 tools/sched_ext/include/scx/compat.bpf.h |  5 +-
 tools/sched_ext/include/scx/compat.h     | 83 ++++++++++++++++++++++++
 tools/sched_ext/scx_qmap.c               |  1 +
 5 files changed, 92 insertions(+), 2 deletions(-)
 create mode 100644 tools/sched_ext/include/scx/compat.h

diff --git a/include/linux/sched/ext.h b/include/linux/sched/ext.h
index 6aa8132a8..048a68899 100644
--- a/include/linux/sched/ext.h
+++ b/include/linux/sched/ext.h
@@ -125,7 +125,8 @@ enum scx_ops_flags {
 	 */
 	SCX_OPS_CGROUP_KNOB_WEIGHT = 1LLU << 16,	/* cpu.weight */
 
-	SCX_OPS_ALL_FLAGS	= SCX_OPS_KEEP_BUILTIN_IDLE |
+	SCX_OPS_ALL_FLAGS	= SCX_OPS_SWITCH_PARTIAL |
+				  SCX_OPS_KEEP_BUILTIN_IDLE |
 				  SCX_OPS_ENQ_LAST |
 				  SCX_OPS_ENQ_EXITING |
 				  SCX_OPS_CGROUP_KNOB_WEIGHT,
diff --git a/tools/sched_ext/include/scx/common.h b/tools/sched_ext/include/scx/common.h
index 7019d9f2d..fc67e11c4 100644
--- a/tools/sched_ext/include/scx/common.h
+++ b/tools/sched_ext/include/scx/common.h
@@ -66,4 +66,6 @@ typedef int64_t s64;
 			bpf_map__initial_value(skel->maps.elfsec##_##arr, &__sz); \
 	} while (0)
 
+#include "compat.h"
+
 #endif	/* __SCHED_EXT_COMMON_H */
diff --git a/tools/sched_ext/include/scx/compat.bpf.h b/tools/sched_ext/include/scx/compat.bpf.h
index 23959c837..9759cd04f 100644
--- a/tools/sched_ext/include/scx/compat.bpf.h
+++ b/tools/sched_ext/include/scx/compat.bpf.h
@@ -16,7 +16,10 @@ static inline void __COMPAT_scx_bpf_kick_cpu_IDLE(s32 cpu)
 		scx_bpf_kick_cpu(cpu, 0);
 }
 
-/* scx_switch_all() was replaced by SCX_OPS_SWITCH_PARTIAL */
+/*
+ * scx_switch_all() was replaced by %SCX_OPS_SWITCH_PARTIAL. See
+ * %__COMPAT_SCX_OPS_SWITCH_PARTIAL in compat.h.
+ */
 void scx_bpf_switch_all(void) __ksym __weak;
 
 static inline void __COMPAT_scx_bpf_switch_all(void)
diff --git a/tools/sched_ext/include/scx/compat.h b/tools/sched_ext/include/scx/compat.h
new file mode 100644
index 000000000..187d09ca8
--- /dev/null
+++ b/tools/sched_ext/include/scx/compat.h
@@ -0,0 +1,83 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/*
+ * Copyright (c) 2024 Meta Platforms, Inc. and affiliates.
+ * Copyright (c) 2024 Tejun Heo <tj@kernel.org>
+ * Copyright (c) 2024 David Vernet <dvernet@meta.com>
+ */
+#ifndef __SCX_COMPAT_H
+#define __SCX_COMPAT_H
+
+#include <bpf/btf.h>
+#include <errno.h>
+
+struct btf *__COMPAT_vmlinux_btf __attribute__((weak));
+
+static inline void __COMPAT_load_vmlinux_btf(void)
+{
+	if (!__COMPAT_vmlinux_btf) {
+		__COMPAT_vmlinux_btf = btf__load_vmlinux_btf();
+		SCX_BUG_ON(!__COMPAT_vmlinux_btf, "btf__load_vmlinux_btf() (%s)",
+			   strerror(errno));
+	}
+}
+
+static inline bool __COMPAT_read_enum(const char *type, const char *name, u64 *v)
+{
+	const struct btf_type *t;
+	const char *n;
+	s32 tid;
+	int i;
+
+	__COMPAT_load_vmlinux_btf();
+
+	tid = btf__find_by_name_kind(__COMPAT_vmlinux_btf, type, BTF_KIND_ENUM);
+	if (tid < 0)
+		return false;
+
+	t = btf__type_by_id(__COMPAT_vmlinux_btf, tid);
+	SCX_BUG_ON(!t, "btf__type_by_id(%d) (%s)", tid, strerror(errno));
+
+	if (btf_is_enum(t)) {
+		struct btf_enum *e = btf_enum(t);
+
+		for (i = 0; i < BTF_INFO_VLEN(t->info); i++) {
+			n = btf__name_by_offset(__COMPAT_vmlinux_btf, e[i].name_off);
+			SCX_BUG_ON(!n, "btf__name_by_offset() (%s)", strerror(errno));
+			if (!strcmp(n, name)) {
+				*v = e[i].val;
+				return true;
+			}
+		}
+	} else if (btf_is_enum64(t)) {
+		struct btf_enum64 *e = btf_enum64(t);
+
+		for (i = 0; i < BTF_INFO_VLEN(t->info); i++) {
+			n = btf__name_by_offset(__COMPAT_vmlinux_btf, e[i].name_off);
+			SCX_BUG_ON(!n, "btf__name_by_offset() (%s)", strerror(errno));
+			if (!strcmp(n, name)) {
+				*v = btf_enum64_value(&e[i]);
+				return true;
+			}
+		}
+	}
+
+	return false;
+}
+
+static inline u64 __COMPAT_SCX_OPS_SWITCH_PARTIAL(void)
+{
+	u64 v = 0;
+
+	__COMPAT_read_enum("scx_ops_flags", "SCX_OPS_SWITCH_PARTIAL", &v);
+	return v;
+}
+
+/*
+ * An ops flag, %SCX_OPS_SWITCH_PARTIAL, replaced scx_bpf_switch_all() which had
+ * to be called from ops.init(). To support both before and after, use both
+ * %__COMPAT_SCX_OPS_SWITCH_PARTIAL and %__COMPAT_scx_bpf_switch_all() defined
+ * in compat.bpf.h.
+ */
+#define __COMPAT_SCX_OPS_SWITCH_PARTIAL __COMPAT_SCX_OPS_SWITCH_PARTIAL()
+
+#endif
diff --git a/tools/sched_ext/scx_qmap.c b/tools/sched_ext/scx_qmap.c
index 7008b9138..1a71bee00 100644
--- a/tools/sched_ext/scx_qmap.c
+++ b/tools/sched_ext/scx_qmap.c
@@ -75,6 +75,7 @@ int main(int argc, char **argv)
 			break;
 		case 'p':
 			skel->rodata->switch_partial = true;
+			skel->struct_ops.qmap_ops->flags |= __COMPAT_SCX_OPS_SWITCH_PARTIAL;
 			break;
 		default:
 			fprintf(stderr, help_fmt, basename(argv[0]));
-- 
2.43.0.232.ge79552d197

